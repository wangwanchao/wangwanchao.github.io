<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wangsir&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://impwang.cn/"/>
  <updated>2021-04-01T17:10:44.243Z</updated>
  <id>http://impwang.cn/</id>
  
  <author>
    <name>wanchao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux环境下编译JDK11(1)</title>
    <link href="http://impwang.cn/2021/03/20/jvm-compile-11/"/>
    <id>http://impwang.cn/2021/03/20/jvm-compile-11/</id>
    <published>2021-03-19T16:38:17.000Z</published>
    <updated>2021-04-01T17:10:44.243Z</updated>
    
    <content type="html"><![CDATA[<p>第n次编译jdk，以前的编译功力尚浅，之后没再去探索。这次在编译OS之后对C语言有一些更好的理解，希望能够深入JDK。对比<code>OpenJDK1.8-</code>，<code>OpenJDK11+</code>简直是简直是easy模式。</p><a id="more"></a><h1 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h1><p>理解jdk和hotspot的关系：</p><h2 id="Linux下编译"><a href="#Linux下编译" class="headerlink" title="Linux下编译"></a>Linux下编译</h2><p>linux主要分两大分支：<br>基于apt安装库的分支：Debian, Ubuntu, Deepin<br>基于rpm安装库的分支：Fedora, Red Hat, CentOS<br>以下主要基于Deepin系统编译。(不同版本可能会有问题，喜欢Ubuntu的建议Ubuntu)</p><h3 id="编译jdk"><a href="#编译jdk" class="headerlink" title="编译jdk"></a>编译jdk</h3><h4 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install build-essential</span><br></pre></td></tr></table></figure><p>检查依赖工具版本：<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gcc</span> <span class="string">-v </span></span><br><span class="line"><span class="attr">clang</span> <span class="string">-v</span></span><br></pre></td></tr></table></figure></p><p>版本需要<code>gcc 4.8+</code>，<code>clang 3.2+</code>，我的系统为<code>gcc version 6.3.0</code>，<code>clang version 3.8.1-24</code></p><h4 id="安装Boot-JDK"><a href="#安装Boot-JDK" class="headerlink" title="安装Boot JDK"></a>安装Boot JDK</h4><p>JDK的编译需要依赖于前置版本，否则一些依赖类找不到会报错。<code>java -version</code>检查默认JDK的版本，也可以通过<code>--with-boot-jdk</code>指定Boot JDK的路径。</p><h4 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h4><p><code>make -v</code>检测make版本，我的默认<code>GNU Make 4.1</code>。<br><code>bash --version</code>，<code>GNU bash，版本 4.4.12</code></p><h4 id="检测编译依赖环境，同时生成编译脚本-至关重要"><a href="#检测编译依赖环境，同时生成编译脚本-至关重要" class="headerlink" title="检测编译依赖环境，同时生成编译脚本(至关重要)"></a>检测编译依赖环境，同时生成编译脚本(至关重要)</h4><p>在根目录下<code>build/linux-x64-normal-server-${BUILD}</code>，比如编译fastdebug版本，则生成<code>build/linux-x64-normal-server-fastdebug</code>包路径。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="variable">$OPENJDK_SRC_HOME</span></span><br><span class="line">bash configure --enable-<span class="builtin-name">debug</span> <span class="attribute">--with-jvm-variants</span>=server --enable-dtrace</span><br></pre></td></tr></table></figure><p>自定义编译参数：<br><code>--enable-debug</code>：指定fastdebug版本，<code>--with-debug-level=&lt;level&gt;</code>的简洁版本，level可以是：<code>release</code>, <code>fastdebug</code>, <code>slowdebug</code> or <code>optimized</code>。<br><code>--with-native-debug-symbols=&lt;method&gt;</code>：指定本地方法符号是否被构建。method可以是<code>none</code>, <code>internal</code>, <code>external</code>, <code>zipped</code><br><code>--with-jvm-variants=&lt;variant&gt;[,&lt;variant&gt;...]</code>：指定hotspot的模式，variant可以是<code>server</code>, <code>client</code>, <code>minimal</code>, <code>core</code>, <code>zero</code>, <code>custom</code><br><code>--with-target-bits=&lt;bits&gt;</code>：设置编译32/64位系统，可以减少交叉编译。</p><p>本地编译参数：<br><code>--enable-dtrace</code>：开启debug模式</p><p>依赖环境参数：<br><code>--with-boot-jdk=&lt;path&gt;</code>：</p><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>编译可以不指定target，<code>make</code>等同于<code>make default</code>/<code>make jdk</code>。还可以只编译单个模块儿。<br>核心target主要有以下几个：</p><ul><li><code>hotspot</code> - 只编译hotspot</li><li><code>hotspot-&lt;variant&gt;</code> - Build just the specified jvm variant</li><li><code>images</code> or <code>product-images</code> - 编译JDK镜像</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make <span class="attribute">JOBS</span>=4 jdk  # 等同于`bash configure <span class="attribute">--with-jobs</span>=4`</span><br></pre></td></tr></table></figure><p>可以看到编译后的目录如下：<br><img src="https://impwang.oss-cn-beijing.aliyuncs.com/java/jdk-build.png" alt="编译目录"></p><h1 id="hotspot在IDEA下的调试"><a href="#hotspot在IDEA下的调试" class="headerlink" title="hotspot在IDEA下的调试"></a>hotspot在IDEA下的调试</h1><h3 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p examples<span class="regexp">/com/</span>wang</span><br><span class="line"></span><br><span class="line">vi Test.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.wang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Test &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"Hello Hotspot"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cd examples</span><br><span class="line">javac com<span class="regexp">/wang/</span>Test.java</span><br></pre></td></tr></table></figure><p>配置Application<br><img src="https://impwang.oss-cn-beijing.aliyuncs.com/java/hotspot-demo.png" alt="demo"></p><p>配置lib库<br><img src="https://impwang.oss-cn-beijing.aliyuncs.com/java/hotspot-env.png" alt="lib"></p><p>开始debug<br><img src="https://impwang.oss-cn-beijing.aliyuncs.com/java/hotspot-debug.png" alt="debug"></p><p>运行结果<br><img src="https://impwang.oss-cn-beijing.aliyuncs.com/java/hotspot-result.png" alt="result"></p><p>待续…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第n次编译jdk，以前的编译功力尚浅，之后没再去探索。这次在编译OS之后对C语言有一些更好的理解，希望能够深入JDK。对比&lt;code&gt;OpenJDK1.8-&lt;/code&gt;，&lt;code&gt;OpenJDK11+&lt;/code&gt;简直是简直是easy模式。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>邮件传输协议SMTP POP3 IMAP</title>
    <link href="http://impwang.cn/2021/01/09/email-protocol/"/>
    <id>http://impwang.cn/2021/01/09/email-protocol/</id>
    <published>2021-01-09T04:10:38.000Z</published>
    <updated>2021-01-09T04:18:15.902Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kafka环境搭建</title>
    <link href="http://impwang.cn/2020/12/21/kafka-base/"/>
    <id>http://impwang.cn/2020/12/21/kafka-base/</id>
    <published>2020-12-21T14:38:34.000Z</published>
    <updated>2021-04-01T18:53:00.067Z</updated>
    
    <content type="html"><![CDATA[<p>17年使用消息队列时接触到Apache Apollo，是IBM用Scala语言开发的，适用于物联网行业。kafka作为消息队列，大多使用在互联网行业，幸运的是也是用Scala语言开发的。</p><a id="more"></a><h2 id="单节点Kafka"><a href="#单节点Kafka" class="headerlink" title="单节点Kafka"></a>单节点Kafka</h2><p>Kafka是依赖于Scala语言的，所以要先安装Scala。</p><h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">kafka_2</span><span class="selector-class">.11-2</span><span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.tgz</span></span><br><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">-xzvf</span> <span class="selector-tag">kafka_2</span><span class="selector-class">.11-2</span><span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.tgz</span></span><br><span class="line"><span class="selector-tag">mv</span> <span class="selector-tag">kafka_2</span><span class="selector-class">.11-2</span><span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.tgz</span> <span class="selector-tag">kafka</span></span><br></pre></td></tr></table></figure><h3 id="启动zk"><a href="#启动zk" class="headerlink" title="启动zk"></a>启动zk</h3><h4 id="使用独立的zk"><a href="#使用独立的zk" class="headerlink" title="使用独立的zk"></a>使用独立的zk</h4><h4 id="使用kafka内嵌的zk"><a href="#使用kafka内嵌的zk" class="headerlink" title="使用kafka内嵌的zk"></a>使用kafka内嵌的zk</h4><p>启动zk<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/zookeeper-server-start<span class="selector-class">.sh</span> -daemon config/zookeeper.properties</span><br><span class="line"></span><br><span class="line">nohup bin/zookeeper-server-start<span class="selector-class">.sh</span> -daemon config/zookeeper<span class="selector-class">.properties</span> &amp;</span><br></pre></td></tr></table></figure></p><h3 id="启动Kafka，同时注册到zk上"><a href="#启动Kafka，同时注册到zk上" class="headerlink" title="启动Kafka，同时注册到zk上"></a>启动Kafka，同时注册到zk上</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-start<span class="selector-class">.sh</span> config/server.properties</span><br><span class="line"></span><br><span class="line">nohup bin/kafka-server-start<span class="selector-class">.sh</span> config/server<span class="selector-class">.properties</span> &amp;</span><br></pre></td></tr></table></figure><h3 id="创建topic-test"><a href="#创建topic-test" class="headerlink" title="创建topic(test)"></a>创建topic(test)</h3><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">bin/kafka</span><span class="literal">-</span><span class="comment">topics</span><span class="string">.</span><span class="comment">sh</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">create</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">zookeeper</span> <span class="comment">localhost:2181</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">replication</span><span class="literal">-</span><span class="comment">factor</span> <span class="comment">1</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">partitions</span> <span class="comment">1</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">topic</span> <span class="comment">test</span></span><br></pre></td></tr></table></figure><h3 id="查看topic"><a href="#查看topic" class="headerlink" title="查看topic"></a>查看topic</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper localhost:<span class="number">2181</span> --list</span><br><span class="line"></span><br><span class="line">bin/kafka-topics.sh --zookeeper <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">2181</span> --topic test --describe</span><br></pre></td></tr></table></figure><p>消费者分组<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-consumer-groups.sh --bootstrap-server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9092</span> --list</span><br><span class="line"></span><br><span class="line">bin/kafka-consumer-groups.sh --bootstrap-server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9092</span> --group test_group --describe</span><br><span class="line"></span><br><span class="line"># 从头开始消费</span><br><span class="line">/usr/local/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:<span class="number">9092</span> --topic test -group test_group --<span class="keyword">from</span>-beginning</span><br></pre></td></tr></table></figure></p><h3 id="生产消息-可以新起一个terminal"><a href="#生产消息-可以新起一个terminal" class="headerlink" title="生产消息(可以新起一个terminal)"></a>生产消息(可以新起一个terminal)</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.<span class="keyword">sh</span> --broker-<span class="keyword">list</span> localhost:9092 --topic <span class="keyword">test</span></span><br></pre></td></tr></table></figure><h3 id="消费消息-新起一个terminal"><a href="#消费消息-新起一个terminal" class="headerlink" title="消费消息(新起一个terminal)"></a>消费消息(新起一个terminal)</h3><p>旧版本<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">bin/kafka</span><span class="literal">-</span><span class="comment">console</span><span class="literal">-</span><span class="comment">consumer</span><span class="string">.</span><span class="comment">sh</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">zookeeper</span> <span class="comment">localhost:2181</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">topic</span> <span class="comment">test</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">from</span><span class="literal">-</span><span class="comment">beginning</span></span><br></pre></td></tr></table></figure></p><p>新版本<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">bin/kafka</span><span class="literal">-</span><span class="comment">console</span><span class="literal">-</span><span class="comment">consumer</span><span class="string">.</span><span class="comment">sh</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bootstrap</span><span class="literal">-</span><span class="comment">server</span> <span class="comment">localhost:9092</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">topic</span> <span class="comment">test</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">from</span><span class="literal">-</span><span class="comment">beginning</span></span><br></pre></td></tr></table></figure></p><p><strong>注意：</strong>这里可能会遇到问题，旧版本启动参数和新版本参数不一样，根据提示修改即可</p><h2 id="Kafka和zk的关系"><a href="#Kafka和zk的关系" class="headerlink" title="Kafka和zk的关系"></a>Kafka和zk的关系</h2><p>Kafka是一个分布式消息系统，多broker就需要一个管理中心，zk作为注册中心，所有的broker、topics都会注册到zk上，进入zk可以看一下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zookeeper-<span class="keyword">shell</span>.<span class="keyword">sh</span> localhos<span class="variable">t:2121</span></span><br></pre></td></tr></table></figure><p>查看根节点：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> /</span><br><span class="line"><span class="keyword">cluster</span>, controller, controller_epoch, brokers, zookeeper, admin, isr_change_notification, consumers, log_dir_event_notification, latest_producer_id_block, config]</span><br></pre></td></tr></table></figure></p><p>查看brokers节点：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> <span class="string">/brokers</span></span><br><span class="line">[ids, topics, seqid]</span><br></pre></td></tr></table></figure></p><p>查看broker0:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> /brokers/ids/<span class="number">0</span></span><br><span class="line">&#123;<span class="string">"listener_security_protocol_map"</span>:&#123;<span class="string">"PLAINTEXT"</span>:<span class="string">"PLAINTEXT"</span>&#125;,<span class="string">"endpoints"</span>:[<span class="string">"PLAINTEXT://localhost:9092"</span>],<span class="string">"jmx_port"</span>:<span class="number">-1</span>,<span class="string">"host"</span>:<span class="string">"localhost"</span>,<span class="string">"timestamp"</span>:<span class="string">"1535447121995"</span>,<span class="string">"port"</span>:<span class="number">9092</span>,<span class="string">"version"</span>:<span class="number">4</span>&#125;</span><br><span class="line">cZxid = <span class="number">0x2e</span></span><br><span class="line">ctime = Tue Aug <span class="number">28</span> <span class="number">17</span>:<span class="number">05</span>:<span class="number">22</span> CST <span class="number">2018</span></span><br><span class="line">mZxid = <span class="number">0x2e</span></span><br><span class="line">mtime = Tue Aug <span class="number">28</span> <span class="number">17</span>:<span class="number">05</span>:<span class="number">22</span> CST <span class="number">2018</span></span><br><span class="line">pZxid = <span class="number">0x2e</span></span><br><span class="line">cversion = <span class="number">0</span></span><br><span class="line">dataVersion = <span class="number">0</span></span><br><span class="line">aclVersion = <span class="number">0</span></span><br><span class="line">ephemeralOwner = <span class="number">0x1657f0bf1b60003</span></span><br><span class="line">dataLength = <span class="number">188</span></span><br><span class="line">numChildren = <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>查看topics:<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> <span class="string">/brokers/topics</span></span><br><span class="line">[test, __consumer_offsets]</span><br></pre></td></tr></table></figure></p><p>查看主题test:<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">get /brokers/topics/test             </span><br><span class="line"><span class="section">&#123;"version":1,"partitions":&#123;"0":[0]&#125;&#125;</span></span><br><span class="line">cZxid = 0x38</span><br><span class="line">ctime = Tue Aug 28 17:06:39 CST 2018</span><br><span class="line">mZxid = 0x38</span><br><span class="line">mtime = Tue Aug 28 17:06:39 CST 2018</span><br><span class="line">pZxid = 0x3a</span><br><span class="line">cversion = 1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 36</span><br><span class="line">numChildren = 1</span><br></pre></td></tr></table></figure></p><h2 id="单节点安全机制"><a href="#单节点安全机制" class="headerlink" title="单节点安全机制"></a>单节点安全机制</h2><h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;17年使用消息队列时接触到Apache Apollo，是IBM用Scala语言开发的，适用于物联网行业。kafka作为消息队列，大多使用在互联网行业，幸运的是也是用Scala语言开发的。&lt;/p&gt;
    
    </summary>
    
      <category term="Kafka" scheme="http://impwang.cn/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="http://impwang.cn/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>第零天</title>
    <link href="http://impwang.cn/2020/12/20/os-preview/"/>
    <id>http://impwang.cn/2020/12/20/os-preview/</id>
    <published>2020-12-20T04:47:58.000Z</published>
    <updated>2020-12-20T07:19:07.479Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍环境需要的一些工具，越到后面，发现这些工具越重要，遇到问题可以很好地调试。</p><a id="more"></a><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="编译工具"><a href="#编译工具" class="headerlink" title="编译工具"></a>编译工具</h2><p>编译这一块儿可以看看《汇编语言》-王爽，《程序员的自我修养》</p><h3 id="nasm"><a href="#nasm" class="headerlink" title="nasm"></a>nasm</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install nasm</span><br></pre></td></tr></table></figure><h3 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h3><p>c语言编译器，该书中的代码运行在32位系统上，64位系统需要跨平台交叉编译。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">sudo</span> apt-<span class="meta">get</span> install gcc g++ gcc-<span class="keyword">multilib </span>make</span><br></pre></td></tr></table></figure></p><h3 id="ld"><a href="#ld" class="headerlink" title="ld"></a>ld</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ld</span> -m</span><br></pre></td></tr></table></figure><p>-f []: 可以指定elf、elf64、win32、win64不同平台的链接。</p><p><strong>注意：</strong>链接过程中，如果C代码中使用了一些动态库的函数，一定要自己重新实现，内核无法使用系统自带的动态库。例如：mysprintf.c</p><h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><p>虽然QEMU的monitor也支持调试，但是功能有限。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gdb -q</span></span><br></pre></td></tr></table></figure><p>尝试界面化启动<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb -tui </span><br><span class="line">(<span class="name">gdb</span>) layout regs</span><br></pre></td></tr></table></figure></p><h2 id="Qemu"><a href="#Qemu" class="headerlink" title="Qemu"></a>Qemu</h2><p><a href="https://www.qemu.org/download/" target="_blank" rel="noopener">qemu下载地址</a></p><p>QEMU是一款运行模拟器，本质上类似于VMWare、VirtualBox一些软件。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-<span class="keyword">system</span>-i386</span><br></pre></td></tr></table></figure><h3 id="QEMU-Monitor"><a href="#QEMU-Monitor" class="headerlink" title="QEMU Monitor"></a>QEMU Monitor</h3><p>可以实现一些gdb的功能。<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-<span class="keyword">system</span>-i386 -monitor stdio</span><br></pre></td></tr></table></figure></p><p>一些常用的调试命令：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">info</span> block</span><br><span class="line"></span><br><span class="line">gdbserver tcp::<span class="number">12345</span> <span class="comment"># 启动监听端口，也可以直接在qemu启动时监听</span></span><br><span class="line"><span class="literal">info</span> registers</span><br><span class="line">print <span class="variable">$eax</span>           <span class="comment"># 打印寄存器信息</span></span><br><span class="line">mouse_move <span class="number">300</span> <span class="number">300</span>   <span class="comment"># 调试鼠标移动</span></span><br><span class="line">mouse_button <span class="number">1</span>       <span class="comment"># 调试键盘</span></span><br></pre></td></tr></table></figure></p><h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h3><p>中间因为Deepin15.11对qemu的键盘中断支持问题，切换到Ubuntu20.04</p><h4 id="Deepin系统"><a href="#Deepin系统" class="headerlink" title="Deepin系统"></a>Deepin系统</h4><p>apt安装<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="builtin-name">get</span> install qemu</span><br></pre></td></tr></table></figure></p><p>编译安装</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">xz</span> <span class="string">-d</span></span><br><span class="line"><span class="attr">tar</span> <span class="string">-xvf</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">$QEMU_HOME</span></span><br><span class="line"><span class="attr">./configure</span></span><br><span class="line"><span class="attr">make</span> <span class="string">-j4</span></span><br><span class="line"><span class="attr">make</span> <span class="string">install</span></span><br></pre></td></tr></table></figure><h4 id="Ubuntu系统"><a href="#Ubuntu系统" class="headerlink" title="Ubuntu系统"></a>Ubuntu系统</h4><p>命令基本和Deepin系统一样</p><h2 id="Bochs"><a href="#Bochs" class="headerlink" title="Bochs"></a>Bochs</h2><p>这个我个人用的比较少，不是很熟悉。中间在qemu遇到问题时，用来校验过<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install bochs</span><br></pre></td></tr></table></figure></p><p>需要配置<code>.bochsrc</code>文件<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bochs </span>-f .<span class="keyword">bochsrc</span></span><br></pre></td></tr></table></figure></p><h1 id="系统镜像"><a href="#系统镜像" class="headerlink" title="系统镜像"></a>系统镜像</h1><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><h3 id="使用dd命令制作"><a href="#使用dd命令制作" class="headerlink" title="使用dd命令制作"></a>使用dd命令制作</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空镜像ipl.img</span></span><br><span class="line"><span class="selector-tag">dd</span> <span class="keyword">if</span>=/dev/zero of=ipl<span class="selector-class">.img</span> bs=<span class="number">512</span> count=<span class="number">4</span> conv=notrunc</span><br><span class="line"><span class="comment">// ipl.bin输出到ipl.img</span></span><br><span class="line"><span class="selector-tag">dd</span> <span class="keyword">if</span>=ipl<span class="selector-class">.bin</span> of=ipl<span class="selector-class">.img</span> bs=<span class="number">512</span> count=<span class="number">4</span> conv=notrunc</span><br><span class="line"><span class="comment">// 追加模式</span></span><br><span class="line"><span class="selector-tag">dd</span> <span class="keyword">if</span>=haribote<span class="selector-class">.sys</span> of=ipl<span class="selector-class">.img</span> bs=<span class="number">512</span> count=<span class="number">1</span> seek=<span class="number">1</span> conv=notrunc</span><br></pre></td></tr></table></figure><h3 id="使用qemu-img制作"><a href="#使用qemu-img制作" class="headerlink" title="使用qemu-img制作"></a>使用qemu-img制作</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create -f qcow2 -o <span class="attribute">backing_file</span>=ipl.bin</span><br></pre></td></tr></table></figure><h3 id="使用Makefile制作"><a href="#使用Makefile制作" class="headerlink" title="使用Makefile制作"></a>使用Makefile制作</h3><h2 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-<span class="keyword">system</span>-i386 -s -S</span><br></pre></td></tr></table></figure><p>-s: 启动GDB端口，默认1234。等于<code>-gdb tcp:1234</code><br>-S: 加电后CPU挂起<br>-kernel:<br>-m: </p><h2 id="分析镜像"><a href="#分析镜像" class="headerlink" title="分析镜像"></a>分析镜像</h2><p>objdump</p><p>nm</p><p>xxd</p><p>hexdump<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump -C ipl.bin<span class="string">|less</span></span><br></pre></td></tr></table></figure></p><p>gdb<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb <span class="keyword">q</span></span><br><span class="line">(gdb) target remote localhost:<span class="number">1234</span></span><br><span class="line">(gdb) set architecture i8086</span><br><span class="line">(gdb) set disassemble-<span class="keyword">next</span>-line on</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍环境需要的一些工具，越到后面，发现这些工具越重要，遇到问题可以很好地调试。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第十九天 + 第二十天</title>
    <link href="http://impwang.cn/2020/12/19/os-19/"/>
    <id>http://impwang.cn/2020/12/19/os-19/</id>
    <published>2020-12-19T09:42:05.000Z</published>
    <updated>2020-12-20T06:38:36.326Z</updated>
    
    <content type="html"><![CDATA[<p>今天要在系统中运行第一个程序了，有点小激动。但是在编译过程中，程序始终无法正常运行hlt中断，反而会刷新系统页面。最后发现是<code>ld script</code>链接的坑，还是基础不牢啊。</p><a id="more"></a><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="ld-script"><a href="#ld-script" class="headerlink" title="ld script"></a>ld script</h2><p>生成map文件<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -melf hlt<span class="selector-class">.o</span> -o hlt<span class="selector-class">.hrb</span> -M=hlt.map</span><br></pre></td></tr></table></figure></p><h2 id="nasm"><a href="#nasm" class="headerlink" title="nasm"></a>nasm</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天要在系统中运行第一个程序了，有点小激动。但是在编译过程中，程序始终无法正常运行hlt中断，反而会刷新系统页面。最后发现是&lt;code&gt;ld script&lt;/code&gt;链接的坑，还是基础不牢啊。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="http://impwang.cn/2020/12/13/distribute-transaction/"/>
    <id>http://impwang.cn/2020/12/13/distribute-transaction/</id>
    <published>2020-12-13T05:24:28.000Z</published>
    <updated>2020-12-13T05:30:45.187Z</updated>
    
    <content type="html"><![CDATA[<p>从MySQL事务，到Spring事务，再到分布式事，是一个渐进的过程。不论你是在拧螺丝还是造火箭，都应该对一些热点的技术有一些了解，这些技术虽然不一定当下就用到，但是在遇到一些问题时，可以给你不一样的思路。</p><a id="more"></a><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p><code>MySQL InnoDB</code>存储引擎支持XA事务，JTA(Java Transaction Manager)是分布式事务的一种基于XA协议的实现方式，用来解决跨数据库的事务操作。典型的实现框架<code>jotm</code>、<code>Atomikos</code>，实现原理就是基于XA协议</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从MySQL事务，到Spring事务，再到分布式事，是一个渐进的过程。不论你是在拧螺丝还是造火箭，都应该对一些热点的技术有一些了解，这些技术虽然不一定当下就用到，但是在遇到一些问题时，可以给你不一样的思路。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>微服务--注册中心(二)</title>
    <link href="http://impwang.cn/2020/12/13/sc-eureka/"/>
    <id>http://impwang.cn/2020/12/13/sc-eureka/</id>
    <published>2020-12-13T02:32:01.000Z</published>
    <updated>2020-12-13T09:53:59.814Z</updated>
    
    <content type="html"><![CDATA[<p>著名的CAP理论，Eureka满足AP理论，ZK、Consul满足CP理论。C强一致性，A高可用性，P分区容错性。在多节点的分布式环境中，注册中心还是一个比较复杂的中间件，尤其是要考虑跨区域</p><a id="more"></a><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p>Eureka不保证强一致性，只保证最终一致性，架构中增加了很多的缓存机制。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>服务注册快，不需要将注册信息同步到其他节点</li><li>不同的节点注册信息可以不一致，保证了高可用A</li></ol><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h4><p>eureka server集群节点之间都是peer，client向sever注册信息后，接收注册的将信息同步至peer节点。<br><strong>注意：这个同步过程是单向的，类似于主从的概念</strong></p><p>服务状态：<br>|状态|描述|<br>|:-|:-:|<br>|UP| 在线 |<br>|DOWN| 下线 |<br>|STARTING| 正在启动 |<br>|OUT_OF_SERVICE| 失效 |<br>|UNKNOWN| 未知 |</p><h5 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h5><p><code>eureka server</code>维护了3个容器类，用来存储服务信息<br>registry: 实时更新。web根据该类获取信息。<br>readWriteCacheMap: 实时更新。每隔30s同步信息到readOnlyCacheMap，每隔60s清除超过90s未续约的节点。<br>readOnlyCacheMap:周期更新。 eureka client每隔30s根据该类获取信息。</p><h5 id="自我保护机制"><a href="#自我保护机制" class="headerlink" title="自我保护机制"></a>自我保护机制</h5><p>15min内超过85%的服务不可用，则启动自我保护机制，</p><h4 id="Eureka-Client"><a href="#Eureka-Client" class="headerlink" title="Eureka Client"></a>Eureka Client</h4><p>eureka client需要注册、续约、更新状态来维持和eureka server的连接。</p><h5 id="缓存机制-1"><a href="#缓存机制-1" class="headerlink" title="缓存机制"></a>缓存机制</h5><p>client有2种角色：服务提供者、服务消费者。<br>作为提供者，每隔30s向server续约。<br>作为消费者，启动后立即从sever获取全量服务信息，之后每隔30s从server增量更新注册信息。同时和Ribbon的整合，Ribbon延后1s从client获取状态UP的服务信息，默认每隔30s更新。<br><code>eureka client</code>维护了3个容器类，用来存储服务信息<br>localRegionApps: 周期更新。启动后立即从sever获取全量服务信息，之后每隔30s从server增量更新注册信息。<br>upServerListZoneMap: 周期更新。Ribbon保存使用且状态为UP的服务注册信息，启动后延时1s向Client更新，默认每30s更新。</p><h3 id="平滑上下线-无感知"><a href="#平滑上下线-无感知" class="headerlink" title="平滑上下线/无感知"></a>平滑上下线/无感知</h3><p>由于存在多种缓存机制，在极端情况下，服务从注册到发现需要很长的时间，所以就需要做到无感知上线、下线。如果是服务非正常终止，最坏情况下需要240s发现。<br>思考的方向：<br>Eureka Server:</p><blockquote><p>减少readWriteCacheMap到readOnlyCacheMap的更新间隔时间。<br>关闭readOnlyCacheMap，使client直接从readWriteCacheMap获取服务信息。</p></blockquote><p>Eureka Client:</p><blockquote><p>减少client从server获取服务的更新周期，减少Ribbon从server获取UP服务的更新周期.<br>增加容错机制。配置Retry重试下一个节点<br>保证服务提供者尽量正常下线。</p></blockquote><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>为了满足强一致性C，导致以下缺点</p><ol><li>服务注册慢，必须满足半数的节点写入成功才认为注册成功</li><li>Leader宕机，为了强一致性，整个集群不可用，牺牲了高可用</li></ol><h2 id="Etcd"><a href="#Etcd" class="headerlink" title="Etcd"></a>Etcd</h2><h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;著名的CAP理论，Eureka满足AP理论，ZK、Consul满足CP理论。C强一致性，A高可用性，P分区容错性。在多节点的分布式环境中，注册中心还是一个比较复杂的中间件，尤其是要考虑跨区域&lt;/p&gt;
    
    </summary>
    
    
      <category term="注册中心" scheme="http://impwang.cn/tags/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>Spring的事务机制(5)</title>
    <link href="http://impwang.cn/2020/12/13/spring-transaction/"/>
    <id>http://impwang.cn/2020/12/13/spring-transaction/</id>
    <published>2020-12-12T17:06:03.000Z</published>
    <updated>2020-12-13T06:34:47.120Z</updated>
    
    <content type="html"><![CDATA[<p>事务贯穿Spring、Mybatis、MySQL的整个阶段，包括现在的分布式事务。重新巩固一下，温故而知新是永恒的哲理。</p><a id="more"></a><h2 id="Spring事务的5种隔离级别"><a href="#Spring事务的5种隔离级别" class="headerlink" title="Spring事务的5种隔离级别"></a>Spring事务的5种隔离级别</h2><p>对应于数据库的隔离级别，用来解决脏读(未提交读)、不可重复读、幻读一系列问题，常用的数据库MySQL有4种隔离级别。而Spring既可以使用数据库默认的隔离级别，也可以自定义。</p><ol><li>ISOLATION_DEFAULT: <strong>PlatfromTransactionManager默认的隔离级别</strong>，使用后端数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应。MySQL默认使用REPEATABLE_READ，Oracle默认采用READ_COMMITED</li><li>ISOLATION_READ_UNCOMMITTED: 这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。</li><li>ISOLATION_READ_COMMITTED: 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。<strong>可以防止脏读</strong></li><li>ISOLATION_REPEATABLE_READ: 事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。</li><li>ISOLATION_SERIALIZABLE: 花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。</li></ol><h2 id="Spring事务的7种传播机制"><a href="#Spring事务的7种传播机制" class="headerlink" title="Spring事务的7种传播机制"></a>Spring事务的7种传播机制</h2><p>传播机制也就是在多个事务之间调用，调用链后续事务是否处于前序的事务中，以及如果出现异常如何处理完整事务链的提交、回滚。<br>TransactionDefinition接口中定义了7种类型的事务传播机制：</p><ol><li>REQUIRED: 支持当前事务，如果当前没有事务，就新建一个事务。<strong>这是最常见的选择，也是 Spring 默认的事务的传播</strong>。</li><li>REQUIRES_NEW: 新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，<strong>外层事务失败回滚之后，不能回滚内层事务执行的结果</strong>，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作</li><li>SUPPORTS: 支持当前事务，如果当前没有事务，就以非事务方式执行。</li><li>MANDATORY: 支持当前事务，如果当前没有事务，就抛出异常。</li><li>NOT_SUPPORTED: 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>NEVER: 以非事务方式执行，如果当前存在事务，则抛出异常。</li><li>NESTED: 嵌套事务，如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，就新建一个事务，此时类似于TransactionDefinition.PROPAGATION_REQUIRED。</li></ol><h2 id="Spring事务原理"><a href="#Spring事务原理" class="headerlink" title="Spring事务原理"></a>Spring事务原理</h2><p>事务是基于连接(connection)的，不能跨连接进行事务管理。<br>Spring事务基于AOP实现，创建、获取connection连接，<code>TransactionSynchronizationManager</code>通过ThreadLocal将connection、sqlSession和当前事务绑定，<code>SqlSessionFactory</code>用于创建<code>SqlSession</code>会话，</p><ol><li>在调用事务方法时，首先会进入拦截器<code>TransactionInterceptor</code></li><li>创建事务，</li><li>开启事务，从数据源获取一个连接，设置’事务同步’，同时设置事务状态</li><li>在事务中，需要创建不同<code>SqlSessionFactory</code>bean、重写Mybatis中原有的<code>sqlSessionTemplate</code>bean</li><li>执行sql</li></ol><h2 id="Spring事务配置"><a href="#Spring事务配置" class="headerlink" title="Spring事务配置"></a>Spring事务配置</h2><p>TransactionDefinition类定义了事务属性，可以看到隔离级别、传播机制、超时时间、只读属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ReadOnly</code>这个属性只是用来提高事务处理的性能。</p><h3 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h3><p>管控粒度小，可实现代码块级别的事务，需要手动编写代码执行提交、回滚。</p><h4 id="基于PlatformTransactionManager、TransactionDefinition-和-TransactionStatus最底层的接口实现"><a href="#基于PlatformTransactionManager、TransactionDefinition-和-TransactionStatus最底层的接口实现" class="headerlink" title="基于PlatformTransactionManager、TransactionDefinition 和 TransactionStatus最底层的接口实现"></a>基于PlatformTransactionManager、TransactionDefinition 和 TransactionStatus最底层的接口实现</h4><p>这是最底层的接口。</p><h4 id="基于TransactionTemplate实现"><a href="#基于TransactionTemplate实现" class="headerlink" title="基于TransactionTemplate实现"></a>基于TransactionTemplate实现</h4><p><code>TransactionTemplate</code>还是基于底层<code>PlatformTransactionManager</code>。<code>PlatformTransactionManager</code>根据不同的ORM有不同的实现类：</p><blockquote><p>DataSourceTransactionManager：适用于使用JDBC和iBatis进行数据持久化操作的情况。<br>HibernateTransactionManager：适用于使用Hibernate进行数据持久化操作的情况。<br>JpaTransactionManager：适用于使用JPA进行数据持久化操作的情况。<br>另外还有JtaTransactionManager 、JdoTransactionManager、&gt; JmsTransactionManager等等。</p></blockquote><h3 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h3><p>侵入小，事务由Spring管理，底层建立在AOP基础上，本质上还是对方法进行拦截，根据执行结果进行提交、回滚。缺点就是只能作用到方法级别，无法像编程式事务一样做到代码级别的控制。<br>即便是声明式事务也有以下几种不同的实现，前两种比较底层，</p><h4 id="基于TransactionInterceptor实现"><a href="#基于TransactionInterceptor实现" class="headerlink" title="基于TransactionInterceptor实现"></a>基于TransactionInterceptor实现</h4><h4 id="基于TransactionProxyFactoryBean实现"><a href="#基于TransactionProxyFactoryBean实现" class="headerlink" title="基于TransactionProxyFactoryBean实现"></a>基于TransactionProxyFactoryBean实现</h4><h4 id="基于tx和aop命名空间实现"><a href="#基于tx和aop命名空间实现" class="headerlink" title="基于tx和aop命名空间实现"></a>基于tx和aop命名空间实现</h4><p>这是Spring时代比较常用的实现方法。</p><h4 id="基于-Transactional注解实现"><a href="#基于-Transactional注解实现" class="headerlink" title="基于@Transactional注解实现"></a>基于@Transactional注解实现</h4><p>这是一种SpringBoot当下最常见的使用方法，但是也有一些注意事项，否则会导致事务失效。以下是Transactional注解：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public @interface Transactional &#123;</span><br><span class="line">    @AliasFor(<span class="string">"transactionManager"</span>)</span><br><span class="line">    String value()<span class="built_in"> default </span><span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    @AliasFor(<span class="string">"value"</span>)</span><br><span class="line">    String transactionManager()<span class="built_in"> default </span><span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    Propagation propagation()<span class="built_in"> default </span>Propagation.REQUIRED;</span><br><span class="line"></span><br><span class="line">    Isolation isolation()<span class="built_in"> default </span>Isolation.DEFAULT;</span><br><span class="line"></span><br><span class="line">    int timeout()<span class="built_in"> default </span>-1;</span><br><span class="line"></span><br><span class="line">    boolean readOnly()<span class="built_in"> default </span><span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Throwable&gt;[] rollbackFor()<span class="built_in"> default </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] rollbackForClassName()<span class="built_in"> default </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Throwable&gt;[] noRollbackFor()<span class="built_in"> default </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] noRollbackForClassName()<span class="built_in"> default </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h3><p>核心类<br><code>TransactionSynchronizationManager</code>用来控制事务同步器<code>TransactionSynchronization</code>，<br><code>TransactionSynchronization</code>：事务同步器，可以按序定义同步器<br><code>DataSourceUtils</code>：用来管理连接connection，<br><code>TransactionStatus</code>：用来管理事务的状态，</p><h3 id="监听机制"><a href="#监听机制" class="headerlink" title="监听机制"></a>监听机制</h3><h2 id="MyBatis事务"><a href="#MyBatis事务" class="headerlink" title="MyBatis事务"></a>MyBatis事务</h2><h3 id="JdbcTransaction模式"><a href="#JdbcTransaction模式" class="headerlink" title="JdbcTransaction模式"></a>JdbcTransaction模式</h3><h3 id="ManagedTraction模式"><a href="#ManagedTraction模式" class="headerlink" title="ManagedTraction模式"></a>ManagedTraction模式</h3><h2 id="多数据源"><a href="#多数据源" class="headerlink" title="多数据源"></a>多数据源</h2><p>步骤：</p><ol><li>创建多个数据源DataSource，ds1 和 ds2；</li><li>将ds1 和 ds2 数据源放入动态数据源DynamicDataSource；</li><li>将DynamicDataSource注入到SqlSessionFactory。</li><li>在事务中，需要创建不同的<code>SqlSessionFactory</code>bean、重写Mybatis中原有的<code>sqlSessionTemplate</code>bean</li></ol><h2 id="Spring事务失效的情况"><a href="#Spring事务失效的情况" class="headerlink" title="Spring事务失效的情况"></a>Spring事务失效的情况</h2><ol><li><p>MySQL数据表的引擎必须为InnoDB，MyISAM引擎不支持事务; static事务方法失效; 在controller层调用失效; catch异常不处理</p></li><li><p>调用的类必须是由Spring容器管理的代理类</p></li></ol><p>jdk代理<br>cglib代理</p><ol start="3"><li><p>调用的方法必须是public方法，这是由Spring的AOP特性决定的。<br>Spring的AOP是通过CGlibAopProxy和JdkDynamicAopProxy动态代理实现的，在对方法进行拦截前后AbstractFallbackTransactionAttributeSource#computeTransactionAttribute会检查目标方法是否是public。<br>这样修饰符可以有两种选择：<br>private: 使用@Transactional注解编译报错<code>Methods annotated with @Transactional must be overridable</code><br>protected: 事务不生效<br>public: 必须在接口内，如果在controller内，事务不生效</p></li><li><p>抛出runtimeException异常才能回滚。</p></li></ol><p>默认情况下，事务抛出未检查异常、Error才回滚，如果是已检查异常则不回滚。<br>如果需要checked Exception回滚，注解需要标明@Transactional(rollbackFor=Exception.class)，或者try-catch后throw new RuntimeException</p><ol start="5"><li>事务传播策略在内部方法调用时(自调用问题)<br>这是因为在AOP代理下，只有目标方法由外部调用时，目标方法才会由Spring生成的代理对象来管理。<h3 id="情景1："><a href="#情景1：" class="headerlink" title="情景1："></a>情景1：</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Person person, Book book)</span></span>&#123;</span><br><span class="line">    insert(person, book);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">insert2</span><span class="params">(Person person, Book book)</span></span>&#123;</span><br><span class="line">    insertPerson(person);</span><br><span class="line"></span><br><span class="line">    insertBook(book);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">personServiceImpl.insert(person, book)事务不起作用</span><br><span class="line"></span><br><span class="line">personServiceImpl.insert2(person, book)事务起作用</span><br></pre></td></tr></table></figure></li></ol><h3 id="情景2："><a href="#情景2：" class="headerlink" title="情景2："></a>情景2：</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Override</span></span><br><span class="line"><span class="variable">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line">public void insert(Person person, Book book)&#123;</span><br><span class="line">    <span class="selector-tag">insert</span>(person, book);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">Override</span></span><br><span class="line">@<span class="selector-tag">Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">insert2</span>(Person person, Book book)&#123;</span><br><span class="line">    <span class="selector-tag">insertPerson</span>(person);</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">insertBook</span>(book);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="selector-tag">personServiceImpl</span><span class="selector-class">.insert</span>(person, book)事务起作用</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">personServiceImpl</span><span class="selector-class">.insert2</span>(person, book)事务不起作用</span><br></pre></td></tr></table></figure><h3 id="解决方案1："><a href="#解决方案1：" class="headerlink" title="解决方案1："></a>解决方案1：</h3><blockquote><p>增加&lt;aop:config proxy-target-class=”true” expose-proxy=”true”&gt;&lt;/aop:config&gt;</p><p>在外层调用内层的事务方法时使用AopContext代理<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="variable">@Override</span></span><br><span class="line">public void insert(Person person, Book book)&#123;</span><br><span class="line">    ((<span class="selector-tag">PersonServiceImpl</span>)<span class="selector-tag">AopContext</span><span class="selector-class">.currentProxy</span>())<span class="selector-class">.insert2</span>(person, book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="解决方案2："><a href="#解决方案2：" class="headerlink" title="解决方案2："></a>解决方案2：</h3><blockquote><p>在外层调用内层的事务方法时使用Spring的IOC容器代理<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Autowired</span></span><br><span class="line">private ApplicationContext ctx;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="variable">@Override</span></span><br><span class="line">public void insert(Person person, Book book)&#123;</span><br><span class="line">    <span class="selector-tag">ctx</span><span class="selector-class">.getBean</span>(PersonServiceImpl.class)<span class="selector-class">.insert2</span>(person, book);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="解决方案3："><a href="#解决方案3：" class="headerlink" title="解决方案3："></a>解决方案3：</h3><blockquote><p>注入自身类<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Autowired</span></span><br><span class="line">private BookService bookService;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="variable">@Override</span></span><br><span class="line">public void insert(Person person, Book book)&#123;</span><br><span class="line">    <span class="selector-tag">bookService</span><span class="selector-class">.insert2</span>(person, book);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事务贯穿Spring、Mybatis、MySQL的整个阶段，包括现在的分布式事务。重新巩固一下，温故而知新是永恒的哲理。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://impwang.cn/categories/Spring/"/>
    
    
      <category term="事务" scheme="http://impwang.cn/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Shenandoah论文(译)</title>
    <link href="http://impwang.cn/2020/12/10/paper-shenandoah/"/>
    <id>http://impwang.cn/2020/12/10/paper-shenandoah/</id>
    <published>2020-12-10T09:43:49.000Z</published>
    <updated>2020-12-13T06:58:17.158Z</updated>
    
    <content type="html"><![CDATA[<p>Shenandoah垃圾回收器在JDK15进入生产阶段。</p><a id="more"></a><p>Shenandoah是一种面向大堆的基于region、低停顿、并行、并发的垃圾回收算法。SATB并发标记和Brooks风格间接指针。<br>现代机器有更多的内存、更多的处理器。SLA应用保证响应时间在10-500ms。</p><h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>压缩垃圾回收算法比CMS算法有更少的内存指纹、更好的本地缓存。达到这种效果要求垃圾回收算法可以在Java运行中压缩堆。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>并发压缩是复杂的，当移动一个可能正在使用当对象时，你可能不得不原子性的更新对象的引用，简单点就需要扫描整个堆。S的解决方案是为每个对象添加一个前向指针<code>forwarding pointer</code>，所有使用这个对象都需要经过这个指针，这就使得即便应用正在运行，仍然可以移动这个对象。GC线程和增量线程使用原子性的CAS操作来更新这个指针。如果多个线程竞争移动同一个对象也只会有一个线程成功。引用的更新在下一个并发标记阶段完成。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="对象布局"><a href="#对象布局" class="headerlink" title="对象布局"></a>对象布局</h3><p>每个对象有2个header，一个指向class；另一个叫<code>mark word</code>，用来作为forwarding pointer、年龄、锁、哈希值。Shenandoah为每个对象添加了一个word，这个word只有在使用S回收器时才被分配，允许不更新引用就可以移动这个对象。移动这个对象的线程通过CAS算法原子的修改这个word使它指向新的地址。所有对这个对象的使用都通过<code>forwarding pointer</code>指向新的地址。</p><h3 id="堆布局"><a href="#堆布局" class="headerlink" title="堆布局"></a>堆布局</h3><p>堆被划分成相等大小的region，一个region可以包括新对象、长时间存活的对象、或者混合的对象。</p><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>初始标记: STW，扫描<code>GC root</code><br>并发标记:<br>最终标记: STW，重新扫描<code>GC root</code>，初始化并发压缩，释放上一次压缩后所有放空的regions<br>并发压缩: 从目标regions中抽取所有存活的对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Shenandoah垃圾回收器在JDK15进入生产阶段。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>paper-g1</title>
    <link href="http://impwang.cn/2020/12/10/paper-g1/"/>
    <id>http://impwang.cn/2020/12/10/paper-g1/</id>
    <published>2020-12-10T05:54:55.000Z</published>
    <updated>2020-12-13T06:59:49.841Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="堆布局"><a href="#堆布局" class="headerlink" title="堆布局"></a>堆布局</h3><p>G1堆被划分成大小相同的Region，每个Region都是一段连续的虚拟内存。我们主要关心的是多处理器、增量线程。增量线程只分配<code>thread-local allocation buffers</code>和<code>TLABs</code>，然后将对象分配在这些buffers中，来减少资源竞争。当前Region填满以后，会选择一个新的Region，所有都Regions组成一个链表使所有的分配时间是线性的。<br>更大的对象可能直接分配在Region，不考虑<code>TLABs</code>，超过Region大小3/4的对象称为大对象(humongous)。大对象直接分配在连续的regions中，这些regions只存储大对象。</p><h3 id="RSets"><a href="#RSets" class="headerlink" title="RSets"></a>RSets</h3><p>每个Region都有一个Region，用来记录一些指向该Region内存活对象的指针。当指针被修改而创建一些垮Region的指针时，就需要一些线程来通知垃圾收集器。这种通知机制使用了一种<code>card table</code>的技术：<br>通知使用了一种<code>card table</code>机制，堆中每512字节的card映射到<code>card table</code>中1字节的对象。每个线程都有一个关联的<code>remembered set log</code>、一个buffer、一些连续的修改过的cards。也就是说，有一个全局的<code>filled RS buffers</code>集合<br>RSets实际上是cards的集合，使用<code>hash tables</code>存储。由于并行机制，每个Region都有一个<code>hash tables</code>组成的数组、一个GC线程，GC线程允许这些线程更新RSets而不相互干扰。<br>RSets在指针改写后会执行<code>write barrier</code>，<br>例如：x、y分别放在寄存器<code>rX</code>和<code>rY</code>中，执行代码<code>x.f = y</code>，执行屏障的伪代码如下<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>| rTmp := rX XOR rY</span><br><span class="line"><span class="number">2</span>| rTmp := rTmp &gt;&gt; LogOfHeapRegionSize</span><br><span class="line"><span class="number">3</span>| <span class="comment">// Below is a conditional move instr</span></span><br><span class="line"><span class="number">4</span>| rTmp := (rY == NULL) then <span class="number">0</span> <span class="keyword">else</span> rTmp</span><br><span class="line"><span class="number">5</span>| <span class="keyword">if</span> (rTmp == <span class="number">0</span>) goto filtered</span><br><span class="line"><span class="number">6</span>| call rs_enqueue(rX)</span><br><span class="line"><span class="number">7</span>| filtered:</span><br></pre></td></tr></table></figure></p><p>屏障使用了一种filter的技术，如果写操作在同一个Region中创建了一个对象到另一个对象的指针操作，则不需要记录在RSets中。代码中如果x、y在同一个Region中，<br>行1、2异或、右移操作后rTmp为0。<br>行4对空指针进行过滤，如果执行了过滤检查，则创建一个跨Region的指针。<br><code>rs_enqueue</code>读取rX的<code>card table entry</code>。如果该entry已经脏了，则什么也不做，这就减少了对同一个card写操作的工作，典型的像初始化操作；如果该entry还没有脏，则先修改为<code>dirty card</code>，同时指向该card的指针被记录到这个线程的<code>remembered set log</code>。如果该线程的<code>log buffer</code>已经满了，则该buffer被添加到全局<code>filled RS buffers</code>集合，接着分配一个新的buffer。<code>log buffer</code>默认可以存储256个元素。<br>并发的RSet线程会先初始化<code>filled RS buffers</code>数量，默认是5个。每个buffer需要处理每个<code>card table</code>的entry，一些cards被频繁写入，为了避免重复处理过热的cards，尽量识别出最热的cards，直到下一个阶段(evacuation pause)去处理。这种机制通过一个<code>二级 card table</code>实现，这个table记录了从上一次evacuation pause到现在该card被dirty的总次数，每次处理card就加1。如果这个数值超过阈值(默认4)，则该card被添加到一个称为<code>hot queue</code>的<code>circular buffer</code>，该queue默认为1k。处理结束后queue为空，如果<code>circular buffer</code>满了，则从尾端取出一个card进行处理。<br>并发RSet线程会处理card，首先，重置entry为clean值，以便并发线程可以重新dirty、enqueue。然后，检查所有对象的指针字段</p><h3 id="垃圾回收阶段-evacuation-pause"><a href="#垃圾回收阶段-evacuation-pause" class="headerlink" title="垃圾回收阶段 evacuation pause"></a>垃圾回收阶段 evacuation pause</h3><p>在合适的时间点，停止所有的增量线程，执行一次垃圾回收。选中regions的CSet，复制regions内的存货对象到其它的位置，然后释放这些regions。该阶段允许压缩，所有对象的移动必须是原子性的，这在并发系统中是非常浪费的，所以把对象迁移放到STW阶段执行。<br>如果多线程程序运行在多处理器服务器上，使用单线程垃圾回收器会导致性能瓶颈。<br>首先，单线程顺序选择CSet<br>其次，并行阶段，GC线程请求执行任务，扫描<code>log buffers</code>更细RSets、扫描RSets和其它<code>root groups</code>查找存活对象、回收存活对象。<br>为了实现快速的并行回收，使用一种<code>GCLABs</code>技术，</p><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>新分配的对象通常更可能成为垃圾，当Region被选择作为<code>mutator allocation region</code>时，我们可以尝试指定它为young。这个Region进入下一次的CSet，这种尝试虽然有损失，但却可以获得很大的收益：<br>一个CSet可以包括<code>young regions</code>和<code>non-young regions</code>，<br>G1可以运行在2种模式下：普通模式、<code>pure garbage-first</code>模式。默认是普通模式。普通模式包括2种子模式：<code>evacuation pauses</code>可以是<code>fully young</code>和<code>partially young</code>，全量模式会把所有已分配的<code>young regions</code>添加到CSet，增量模式除了添加所有<code>young regions</code>之外，如果停顿时间允许，还会添加一部分<code>non-young regions</code>。</p><h3 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h3><p>使用一种SATB(snapshot-at-the-beginning)并发标记技术，标记用来识别开始就存在的垃圾对象。在标记中间分配的对象必须判断是否存活。但是已经被标记的对象不需要再重新标记、跟踪。这种方法大大的较少了标记耗时。</p><h4 id="标记数据结构"><a href="#标记数据结构" class="headerlink" title="标记数据结构"></a>标记数据结构</h4><p>G1维护了2种类型的<code>marking bitmaps</code>，<br>previous: 已经标记完成的bitmap<br>next: 可能正在构建的bitmap<br>这2种bitmap在标记完成后交换角色，每个bitmap都包含1个bit，默认都是8字节对齐，意味着1个bitmap bit需要64bit。</p><h4 id="初始标记-并发标记"><a href="#初始标记-并发标记" class="headerlink" title="初始标记/并发标记"></a>初始标记/并发标记</h4><p>首先，清空<code>next bitmap</code>，<br>其次，初始化标记会停止所有的增量线程，同时标记所有可到达的对象。每个Region包括2个TAMS(top at mark start)变量，分别为previous、next使用，这些变量用来识别在标记期间分配的对象。<br>初始化阶段会遍历所有的regions，复制region的top属性值到<code>next TAMS</code></p><h4 id="并发标记写屏障"><a href="#并发标记写屏障" class="headerlink" title="并发标记写屏障"></a>并发标记写屏障</h4><p>例如：<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>| rTmp := <span class="keyword">load</span>(rThread + MarkingInProgressOffset)</span><br><span class="line"><span class="number">2</span>| <span class="keyword">if</span> (!rTmp) <span class="keyword">goto</span> filtered</span><br><span class="line"><span class="number">3</span>| rTmp := <span class="keyword">load</span>(rX + FieldOffset)</span><br><span class="line"><span class="number">4</span>| <span class="keyword">if</span> (rTmp == <span class="built_in">null</span>) <span class="keyword">goto</span> filtered</span><br><span class="line"><span class="number">5</span>| <span class="keyword">call</span> <span class="built_in">satb_enqueue</span>(rTmp)</span><br><span class="line"><span class="number">6</span>| filtered:</span><br></pre></td></tr></table></figure></p><p>行1、行2: 如果不执行标记，则跳过以下代码。对于很多程序来说，这个会过滤掉很多动态屏障<br>行3、行4: 加载对象属性的值，检查是否为null，只需要记录非空的值。<br>行5: 添加指针到线程的<code>marking buffer</code>，如果buffer被填满，则添加到全局的<code>marking buffers</code>集合中，</p><h4 id="最终标记"><a href="#最终标记" class="headerlink" title="最终标记"></a>最终标记</h4><h4 id="统计存活对象并清理"><a href="#统计存活对象并清理" class="headerlink" title="统计存活对象并清理"></a>统计存活对象并清理</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h2&gt;&lt;h3 id=&quot;堆布局&quot;&gt;&lt;a href=&quot;#堆布局&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>devops-publish</title>
    <link href="http://impwang.cn/2020/12/09/devops-publish/"/>
    <id>http://impwang.cn/2020/12/09/devops-publish/</id>
    <published>2020-12-09T13:23:49.000Z</published>
    <updated>2020-12-09T13:23:49.051Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jvm垃圾回收</title>
    <link href="http://impwang.cn/2020/12/09/java-jvm-gc/"/>
    <id>http://impwang.cn/2020/12/09/java-jvm-gc/</id>
    <published>2020-12-09T06:41:46.000Z</published>
    <updated>2020-12-09T15:58:50.450Z</updated>
    
    <content type="html"><![CDATA[<p>垃圾回收器应该是架构师必备的核心技能，从回收算法、回收器、GC Roots、安全点/安全区域、分配策略、回收策略，整个过程都需要清晰。最后通过配置参数进行调优。<br>这是一篇持续更新的博客，随着认知的变化、GC的更新不断更新</p><a id="more"></a><h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><h3 id="1-标记-清除算法-Mark-Sweep"><a href="#1-标记-清除算法-Mark-Sweep" class="headerlink" title="1. 标记-清除算法(Mark-Sweep):"></a>1. 标记-清除算法(Mark-Sweep):</h3><p>缺点：</p><blockquote><p>效率不高</p><p>产生大量不连续的内存碎片</p></blockquote><h3 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2. 复制算法"></a>2. 复制算法</h3><p>优点：</p><blockquote><p>实现简单，运行高效</p></blockquote><p>缺点：</p><blockquote><p>内存浪费</p></blockquote><p>商业用例：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Eden:Survivor = <span class="number">8</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure></p><h3 id="3-标记-整理算法-标记-压缩算法"><a href="#3-标记-整理算法-标记-压缩算法" class="headerlink" title="3. 标记-整理算法/标记-压缩算法"></a>3. 标记-整理算法/标记-压缩算法</h3><h3 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4. 分代收集算法"></a>4. 分代收集算法</h3><blockquote><p>新生代：复制算法<br>老年代：标记-清除/标记-整理</p></blockquote><h2 id="安全点-安全区域"><a href="#安全点-安全区域" class="headerlink" title="安全点/安全区域"></a>安全点/安全区域</h2><p>1.枚举根节点</p><p>2.安全点</p><p>3.安全区域</p><h2 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h2><p>年轻代：复制算法<br>老年代：</p><ol><li>标记-清除</li><li>标记-整理<br>分代算法：年轻代使用复制算法，老年代使用标记清除/标记整理</li></ol><h2 id="回收器"><a href="#回收器" class="headerlink" title="回收器"></a>回收器</h2><h3 id="年轻代收集器"><a href="#年轻代收集器" class="headerlink" title="年轻代收集器"></a>年轻代收集器</h3><table><thead><tr><th style="text-align:left">收集器</th><th style="text-align:center">描述</th><th style="text-align:center">算法</th><th style="text-align:center">过程</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th><th style="text-align:center">参数</th></tr></thead><tbody><tr><td style="text-align:left">Serial</td><td style="text-align:center">单线程，使用一个CPU/一个线程完成垃圾收集工作，收集过程必须STW，直到收集结束</td><td style="text-align:center">复制算法</td><td style="text-align:center">-</td><td style="text-align:center">简单高效</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left">ParNew</td><td style="text-align:center">多线程，基于Serial的多线程版本，默认GC线程数等于CPU数量。除了Serial，只有ParNew可以和老年代的CMS收集器搭配</td><td style="text-align:center">复制算法</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">在单CPU下性能不如Serial</td><td style="text-align:center">ParallelGCThreads:GC线程数</td></tr><tr><td style="text-align:left">Parallel Scavenge</td><td style="text-align:center">并行，多线程，目标是达到可控制的吞吐量</td><td style="text-align:center">复制算法</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">MaxGCPauseMillis:GC停顿时间;GCTimeRatio:GC停顿时间比例;UseAdaptiveSizePolicy:自适应调整参数</td></tr></tbody></table><h3 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h3><table><thead><tr><th style="text-align:left">收集器</th><th style="text-align:center">描述</th><th style="text-align:center">算法</th><th style="text-align:center">过程</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th><th style="text-align:center">参数</th></tr></thead><tbody><tr><td style="text-align:left">Serial Old</td><td style="text-align:center">单线程</td><td style="text-align:center">标记-整理</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left">Parallel Old</td><td style="text-align:center">多线程</td><td style="text-align:center">标记-整理</td><td style="text-align:center">-</td><td style="text-align:center">在吞吐量、CPU资源敏感的场景，优先考虑Parallel Scavenge + Parallel Old</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left">CMS</td><td style="text-align:center">并发，最短停顿时间</td><td style="text-align:center">标记-清除</td><td style="text-align:center">初始标记(STW)；并发标记；重新标记(STW)；并发清除</td><td style="text-align:center">-</td><td style="text-align:center">并发对CPU资源敏感；无法处理浮动垃圾导致并发模式失败；空间碎片导致无法分配大对象</td><td style="text-align:center">CMSInitiatingOccupancyFraction:设置老年代占用率达到该阈值后，执行一次FullGC;+UseCMSCompactAtFullCollection:空间不足执行FullGC时同时执行碎片整理;CMSFullGCsBeforeCompaction:执行多少次不压缩的FullGC后执行一次碎片整理;</td></tr></tbody></table><p>CMS、G1垃圾回收都采用<strong>三色标记法</strong>，但是具体实现不同：<br>思想：将对象标记为黑、灰、白三种颜色</p><blockquote><p>从<code>GC Root</code>对象向下查找，根据三色标记法标记出所有连接的对象<br>第一次并发标记后，会产生浮动垃圾，即灰色对象，这时候进行一次STW的短暂停顿对灰色对象进行扫描标记<br>GC线程扫描所有内存，找出被标记为白色的对象。</p></blockquote><p><strong>规则</strong><br>黑色：该对象已经被标记过了，且该对象下的属性也全部都被标记过了。(存活对象)<br>灰色：该对象已经被标记过了，但该对象下的属性没有全被标记完。(存活对象下存在垃圾)<br>白色：该对象没有被标记过。(垃圾对象)</p><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>(并发低停顿收集器), 基于标记-清除算法<br>目标：主要针对老年代，以获取最短回收停顿时间</p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><blockquote><p>初始标记：stop-the-world，仅仅标记GC Roots能关联到的对象<br>并发标记：进行GC Roots Tracing的过程<br>重新标记：stop-the-world，修正并发标记期间程序运行变化的对象<br>并发清除：用户程序同时运行</p></blockquote><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li><p>对CPU资源非常敏感：</p><blockquote><p>并发处理对CPU要求就比较高，占用一部分线程，会导致吞吐量降低。<br><strong>默认</strong>垃圾回收线程数量(NUM(cpu) + 3)/4；<br>CPU不足4个时，对应用的影响就会比较大</p></blockquote></li><li>无法处理浮动垃圾：concurrent mode failure(并发模式失败)<blockquote><p>浮动垃圾：并发清理和用户程序同时运行，这样在清理期间就会产生对象垃圾，这部分垃圾需要留到下一次GC去处理，就会产生浮动垃圾。<br>由于用户程序需要同时运行，所以老年代需要为用户程序预留一部分空间，预留空间无法满足用户程序，就会导致<code>Concurrent Mode Failure</code>，接着产生Full GC<br>jdk1.5增加参数<code>-XX:CMSInitiatingOccupancyFraction</code>，老年代使用超过该阈值，触发CMS垃圾回收，如果老年代不是增长太快，可以适当调高该值<br>jdk1.6<br>参数<code>-XX:ConGCThreads=N</code>，可以设置垃圾收集线程数量</p></blockquote></li><li>产生大量空间碎片：promoration failure(晋升失败)<blockquote><p>标记-清除算法会导致空间碎片，碎片过多在大对象分配的时候，虽然有足够的时间，无法找到连续空间，不得不触发一次Full GC<br>参数<code>-XX:+UseCMSCompactAtFullCollection</code>，默认开启，在执行Full GC的时候，开启内存碎片的整理<br>参数<code>-XX:CMSFullGCsBeforeCompaction</code>，默认值为0，用于控制执行多少次不压缩的Full GC后执行一次带压缩的Full GC。</p></blockquote></li></ol><h4 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h4><table><thead><tr><th>参数</th><th style="text-align:center">详解</th></tr></thead><tbody><tr><td>-XX:+UseConcMarkSweepGC</td><td style="text-align:center">激活CMS收集器</td></tr><tr><td>-XX:ConcGCThreads</td><td style="text-align:center">设置CMS线程的数量</td></tr><tr><td>-XX:+UseCMSInitiatingOccupancyOnly</td><td style="text-align:center">只根据老年代使用比例来决定是否进行CMS</td></tr><tr><td>-XX:CMSInitiatingOccupancyFraction</td><td style="text-align:center">设置触发CMS老年代回收的内存使用率占比</td></tr><tr><td>-XX:+CMSParallelRemarkEnabled</td><td style="text-align:center">并行运行最终标记阶段，加快最终标记的速度</td></tr><tr><td>-XX:+UseCMSCompactAtFullCollection</td><td style="text-align:center">每次触发CMS Full GC的时候都整理一次碎片</td></tr><tr><td>-XX:CMSFullGCsBeforeCompaction</td><td style="text-align:center">经过几次CMS Full GC的时候整理一次碎片</td></tr><tr><td>-XX:+CMSClassUnloadingEnabled</td><td style="text-align:center">让CMS可以收集永久带，默认不会收集</td></tr><tr><td>-XX:+CMSScavengeBeforeRemark</td><td style="text-align:center">最终标记之前强制进行一个Minor GC</td></tr><tr><td>-XX:+ExplicitGCInvokesConcurrent</td><td style="text-align:center">当调用System.gc()的时候，执行并行gc，只有在CMS或者G1下该参数才</td></tr></tbody></table><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>目标：</p><h4 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h4><p>概念：<br>优先列表</p><h5 id="Region："><a href="#Region：" class="headerlink" title="Region："></a>Region：</h5><blockquote><p>默认堆内存分为1024个region分区。每个region大小相等<br>region分为：Eden Survivor Old Humongous(巨型对象)，垃圾收集时，一个对象可以跨region<br>参数<code>-XX:G1HeapRegionSize</code>可以设置region大小，最小1Mb，最大32Mb</p></blockquote><h5 id="CSet-Collection-Set"><a href="#CSet-Collection-Set" class="headerlink" title="CSet(Collection Set)"></a>CSet(Collection Set)</h5><p>一组可被回收的Region分区的集合。</p><h5 id="RSet-Remembered-Set-："><a href="#RSet-Remembered-Set-：" class="headerlink" title="RSet(Remembered Set)："></a>RSet(Remembered Set)：</h5><p>每个Region都有一个RSet，RSet其实是Card的集合，这个RSet用来记录其它Region引用自身Region内部对象的信息，对象可以跨代引用，<code>old-&gt;young</code>或者<code>young-&gt;old</code>，这样垃圾回收时只需要扫描RSet</p><h5 id="CarTable"><a href="#CarTable" class="headerlink" title="CarTable"></a>CarTable</h5><blockquote><p>CardTable是一种特殊类型的RSet，JVM使用一个字节数组作为CardTable，每一个字节都指向一个Card(512字节)，<br>老年代分为多个Card，如果Card中有指向年轻代的对象，则标记为<code>Dirty Card</code>，执行<code>Young GC</code>只需要扫描<code>Dirty Card</code>即可<br>底层使用<code>Bit Map</code>结构存储</p></blockquote><h5 id="SATB-Snapchat-At-The-Beginning-："><a href="#SATB-Snapchat-At-The-Beginning-：" class="headerlink" title="SATB(Snapchat-At-The-Beginning)："></a>SATB(Snapchat-At-The-Beginning)：</h5><blockquote><p>并发GC时用户程序同时运行，可能会生成新对象，所以在GC前，会先执行SATB，生成快照记录存活的对象<br>每个Region记录两个TAMS(top-at-mark-start)指针，GC过程中生成的新对象，在TAMS上的对象就是新分配的对象<br>Write Barrier</p></blockquote><h4 id="垃圾回收-1"><a href="#垃圾回收-1" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><h5 id="全局并发标记阶段"><a href="#全局并发标记阶段" class="headerlink" title="全局并发标记阶段"></a>全局并发标记阶段</h5><blockquote><p>初始标记：stop-the-world，仅仅标记GC Roots能关联到的对象<br>并发标记：<br>最终标记：stop-the-world，会处理在并发标记阶段write barrier记录下来的对象；与CMS最大的差别就是，CMS会扫描整个GC Roots，包括Eden区<br>筛选回收：stop-the-world，这一阶段并不会收集垃圾，而是根据停顿预测模型预测出CSet，等待下一个Evacuation阶段回收</p></blockquote><h5 id="拷贝存活对象阶段-Evacuation"><a href="#拷贝存活对象阶段-Evacuation" class="headerlink" title="拷贝存活对象阶段 Evacuation"></a>拷贝存活对象阶段 Evacuation</h5><blockquote><p>stop-the-world，将一部分region中的存活对象拷贝到另一部分region，只剩下垃圾对象的region被记录在CSet，<br>evacuation failure：堆空间垃圾太多，导致无法完成region之间的拷贝，导致执行一次Full GC。类似于CMS的<code>promoration failure</code>。</p></blockquote><h5 id="收集模式"><a href="#收集模式" class="headerlink" title="收集模式"></a>收集模式</h5><p>Young GC：<br>Mix GC：</p><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ol><li>并行与并发</li><li>分代收集</li><li><p>空间整合：</p><blockquote><p>与CMS的标记-清除算法不同，G1整体看是标记-整理算法，局部(Region)看则是复制算法，不会产生内存碎片。</p></blockquote></li><li><p>可预测的停顿：</p><blockquote><p>这是G1相比CMS的一大优势，降低停顿时间时G1和CMS共同的关注点，但G1除了追求低停顿，还能建立可预测的停顿时间模型<br>参数<code>-XX:MaxGCPauseMillis</code>，可以设置停顿时间</p></blockquote></li></ol><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><ol><li>不断调优停顿时间</li><li>不设置新生代/老年代大小，由JVM自动调整，设置大小后会导致停顿时间设置失效</li><li>关注Evacuation Failure问题</li></ol><h4 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h4><table><thead><tr><th>参数</th><th style="text-align:center">详解</th></tr></thead><tbody><tr><td>-XX:+UseG1GC</td><td style="text-align:center">使用 G1 垃圾收集器</td></tr><tr><td>-XX:MaxGCPauseMillis=200</td><td style="text-align:center">设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）</td></tr><tr><td>-XX:InitiatingHeapOccupancyPercent=45</td><td style="text-align:center">启动并发GC周期时的堆内存占用百分比. G1之类的垃圾收集器用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比. 值为 0 则表示”一直执行GC循环”. 默认值为 45</td></tr><tr><td>-XX:NewRatio=n</td><td style="text-align:center">新生代与老生代(new/old generation)的大小比例(Ratio). 默认值为 2</td></tr><tr><td>-XX:SurvivorRatio=n</td><td style="text-align:center">eden/survivor 空间大小的比例(Ratio). 默认值为 8.</td></tr><tr><td>-XX:MaxTenuringThreshold=n</td><td style="text-align:center">提升年老代的最大临界值(tenuring threshold). 默认值15</td></tr><tr><td>-XX:ParallelGCThreads=n</td><td style="text-align:center">设置垃圾收集器在并行阶段使用的线程数,默认值随JVM运行的平台不同而不同.</td></tr><tr><td>-XX:ConcGCThreads=n</td><td style="text-align:center">并发垃圾收集器使用的线程数量. 默认值随JVM运行的平台不同而不同.</td></tr><tr><td>-XX:G1ReservePercent=n</td><td style="text-align:center">设置堆内存保留为假天花板的总量,以降低提升失败的可能性. 默认值是 10.</td></tr><tr><td>-XX:G1HeapRegionSize=n</td><td style="text-align:center">使用G1时Java堆会被分为大小统一的的区(region)。此参数可以指定每个heap区的大小. 默认值将根据 heap size 算出最优解. 最小值为 1Mb, 最大值为 32Mb.</td></tr></tbody></table><h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><blockquote><p>GC停顿时间不超过10ms<br>处理堆从MB到TB<br>相比G1减少了15%的吞吐量</p></blockquote><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><h3 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h3><p>目标：低停顿时间</p><h3 id="混合收集器"><a href="#混合收集器" class="headerlink" title="混合收集器"></a>混合收集器</h3><table><thead><tr><th style="text-align:left">收集器</th><th style="text-align:center">描述</th><th style="text-align:center">算法</th><th style="text-align:center">过程</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th><th style="text-align:center">参数</th></tr></thead><tbody><tr><td style="text-align:left">+UseG1GC</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">+UseZGC</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h3 id="回收器组合"><a href="#回收器组合" class="headerlink" title="回收器组合"></a>回收器组合</h3><table><thead><tr><th style="text-align:left">收集器组合</th><th style="text-align:center">收集器</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:left">+UseSerialGC</td><td style="text-align:center">Serial + Serial Old</td><td style="text-align:center">jdk运行在client模式下默认组合</td></tr><tr><td style="text-align:left">+UseParNewGC</td><td style="text-align:center">ParNew + Serial Old</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left">+UseConcMarkSweepGC</td><td style="text-align:center">ParNew + CMS/Serial Old</td><td style="text-align:center">老年代在并发模式失败后开启Serial Old</td></tr><tr><td style="text-align:left">+UseParrallelGC</td><td style="text-align:center">Parallel Scavenge + Serial Old(PS MarkSweep)</td><td style="text-align:center">jdk运行在server模式下默认开启</td></tr><tr><td style="text-align:left">+UseParallelGC</td><td style="text-align:center">Parallel Scavenge + Parallel Old</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">+UseG1GC</td><td style="text-align:center">G1</td><td style="text-align:center">-</td></tr></tbody></table><h2 id="内存分配、回收策略"><a href="#内存分配、回收策略" class="headerlink" title="内存分配、回收策略"></a>内存分配、回收策略</h2><p>Minor GC: 指发生在新生代的垃圾回收动作</p><p>Full GC/Major GC: 指发生在老年代的GC，出现Full GC，经常会伴随至少一次Minor GC;</p><p><strong>如果更细粒度，Major GC可以认为只对老年的GC，而Full GC是对整个堆来说的。</strong></p><blockquote><p>1、对象优先在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC<br>2、大对象直接进入老年代。大对象典型的就是那些很长的字符串、数组 参数-XX:PretenureSizeThreshold可以设定大对象的标准<br>3、长期存活的对象将进入老年代(默认是15岁)<br>Eden区对象经过Minor GC后，年龄增1，然后在Survivor每经历一次Minor GC，年龄增长1，达到指定年龄，进入老年代<br>参数-XX:MaxTenuringThreshold<br>4、动态年龄判定<br>如果在Survivor区，相同年龄的所有对象大小总和大于Survivor空间的一半，年龄大于等于该年龄的对象可以直接进入老年代。【可以破坏规则3】<br>5、空间分配担保</p></blockquote><h3 id="GC触发"><a href="#GC触发" class="headerlink" title="GC触发"></a>GC触发</h3><p>Minor GC触发条件：</p><blockquote><p>Eden区没有足够空间分配时，触发</p></blockquote><p>Full GC触发条件：</p><blockquote><ol><li>显式调用System.gc()。可以通过-XX:+ DisableExplicitGC禁止显式调用</li><li>方法区(永生代)空间不足。方法区在HotSpot中又被称为永生代/永生区。如果被占满，在未配置为CMS GC的情况下，会执行一次Full GC，如果空间还是不足，则抛出异常java.lang.OutOfMemoryError: PermGen space </li><li>老年代空间不足。出现的原因：新生代对象转入；分配大对象、大数组。如果Full GC后空间仍然不够，则抛出java.lang.OutOfMemoryError: Java heap space </li><li>Eden区对象执行Minor GC后，进入老年代的所有对象和大于老年代可用内存时，触发Full GC</li><li>(promotion failed)Eden + From执行Minor GC时，如果存活对象大于To内存区，则直接进入老年代，如果老年代的可用内存小于该对象，则触发Full G</li><li>(concurrent mode failure)执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足，则执行一次Full GC </li></ol></blockquote><p><strong>注意:</strong>jdk1.6_24之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会执行Minor GC，否则进行Full GC</p><h2 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h2><h3 id="内存参数"><a href="#内存参数" class="headerlink" title="内存参数"></a>内存参数</h3><p>-Xms：初始堆。默认为物理内存的1/64。<br>-Xmx：最大堆。默认为物理内存的1/4。<br>-Xmn：新生代/年轻代大小。增大年轻代后，老年代会减小，官方建议为整个堆的3/8.<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">年轻代大小 = eden + survivor</span><br><span class="line">整个堆大小 = 年轻代大小 + 老年代大小 + 永久代大小(<span class="number">1.8</span>之后弃用)</span><br></pre></td></tr></table></figure></p><p>-XX:NewRatio: 年轻代与老年代的比值。<br>-XX:SurvivorRatio: Eden区与Survicor区的比值。<br>-XX:PermSize：永久代初始大小。默认为物理内存的1/64。<br>-XX:MaxPermSize：永久代最大值。默认为物理内存的1/4。</p><h3 id="编译参数"><a href="#编译参数" class="headerlink" title="编译参数"></a>编译参数</h3><p>-XX:LargePageSizeInBytes: 内存页的大小，默认为，可能会影响Perm。<br>-XX:+UseFastAccessorMethods：<br>-XX:+UseBiasedLocking<br>-XX:PretenureSizeThreshold<br>-XX:TLABWasteTargetPercent：TLAB占Eden区的百分比，默认1%。<br>-XX:SoftRefLRUPolicyMSPerMB<br>-XX:+UseCompressedClassPointers<br>-XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation</p><p>-XX:G1ConcRefinementThreads=4 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=130694848<br>-XX:MaxHeapSize=2091117568<br>-XX:MinHeapSize=6815736<br>-XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240<br>-XX:+SegmentedCodeCache </p><h3 id="日志参数"><a href="#日志参数" class="headerlink" title="日志参数"></a>日志参数</h3><p>-XX:+PrintHeapAtGC：打印GC前后的堆栈信息<br>-XX:+PrintTLAB： 查看TLAB空间的使用情况<br>-Xloggc 日志文件存放位置<br>-XX:+PrintGCDateStamps 打印每个年代对象分布情况<br>-XX:+PrintGCDateStamps / -XX:+PrintGCTimeStamps<br>-XX:+PrintGCApplicationStoppedTime：<br>-XX:+PrintGCApplicationConcurrentTime：打印除了GC之外引起JVM STW的时间<br>-XX:+PrintSafepointStatistics：<br>-XX:PrintSafepointStatisticsCount=1：</p><h2 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h2><p>GC性能调优大致有两个指标：</p><ol><li>吞吐量：工作线程运行时间/总的运行时间</li><li>停顿时间：STW时间</li></ol><h3 id="调优方向"><a href="#调优方向" class="headerlink" title="调优方向"></a>调优方向</h3><ol><li><p>Heap大小<br>Xms、Xmx设置为相同值，避免申请内存带来的压力。</p></li><li><p>年轻代大小<br>年轻代太小，就会导致频繁的Minor GC；太大则占用老年代空间，导致频繁的Full GC；<br>响应时间优先：<br>吞吐量优先：</p></li><li><p>老年代大小<br>响应时间优先：<br>吞吐量优先：</p></li><li><p>CMS收集器<br>使用CMS的好处是用尽量少的年轻代，经验值是128M－256M， 然后老年代可以大一些，由于老年代并发收集， 这样能保证系统低延迟的吞吐效率。<br>实际上cms的收集停顿时间非常的短，2G的内存， 大约20－80ms的应用程序停顿时间。<br>并发模式失败：GC线程在并发标记/并发清理阶段，用户工作线程仍然并发运行，导致浮动垃圾，如果老年代剩余空间不足，则会导致’并发模式失败’。<br>晋升失败：<code>Eden + From Survivor</code>区对象经过Minor GC进入<code>To Survivor</code>，To Survivor空间不足，再次进入<code>Old gen</code>老年代，老年代空间也不足，则会执行<code>Full GC</code>，同时抛出晋升失败<code>Promotion faild</code>。关于晋升失败，前辈大概总结出来一个公式：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMSInitiatingOccupancyFraction &lt;= ((<span class="name">Xmx-Xmn</span>)-(<span class="name">Xmn-Xmn/</span>(<span class="name">SurvivorRatior+2</span>)))/(<span class="name">Xmx-Xmn</span>)*100</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;垃圾回收器应该是架构师必备的核心技能，从回收算法、回收器、GC Roots、安全点/安全区域、分配策略、回收策略，整个过程都需要清晰。最后通过配置参数进行调优。&lt;br&gt;这是一篇持续更新的博客，随着认知的变化、GC的更新不断更新&lt;/p&gt;
    
    </summary>
    
    
      <category term="jvm" scheme="http://impwang.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jdk版本特性概览(一)</title>
    <link href="http://impwang.cn/2020/12/09/a-overview-jdk/"/>
    <id>http://impwang.cn/2020/12/09/a-overview-jdk/</id>
    <published>2020-12-08T16:21:01.000Z</published>
    <updated>2020-12-09T15:16:33.854Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉OpenJDK16快要发布了，大多还停留在jdk6/7/8上，jdk的快速迭代，让人非常兴奋。JDK发布版本分为过渡版本和长时间支持版本(LTS)，一般在生产中采用LTS版本可以满足长期维护。下面大致罗列一下jdk的新特性。</p><a id="more"></a><p>来给jdk15比个yeah!</p><h2 id="JDK15"><a href="#JDK15" class="headerlink" title="JDK15"></a>JDK15</h2><h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><blockquote><p>339:    Edwards-Curve数字签名算法 (EdDSA)<br>360:    密封类 (预览)<br>371:    隐藏类<br>372:    移除了Nashorn JS引擎<br>373:    重新实现了DatagramSocket API<br>374:    禁用并弃用了偏向锁<br>375:    Pattern Matching for instanceof (二次预览)<br>377:    ZGC: 可扩展的低延迟的垃圾收集器 (生产阶段)<br>378:    文本块<br>379:    Shenandoah: 低停顿时间垃圾收集器 (从实验阶段进入生产阶段)<br>381:    移除了对Solaris和SPARC的支持<br>383:    Foreign-Memory Access API (Second Incubator)<br>384:    Records (二次预览)<br>385:    Deprecate RMI Activation for Removal</p></blockquote><h2 id="JDK1-8-LTS"><a href="#JDK1-8-LTS" class="headerlink" title="JDK1.8 LTS"></a>JDK1.8 LTS</h2><p><a href="https://jdk.java.net/java-se-ri/8" target="_blank" rel="noopener">OpenJDK1.8下载</a><br><!--[OracleJDK8文档]()--></p><p>特性表详细的list没有找到，自己手动整理了一下</p><h3 id="Lambda表达式和Functional接口"><a href="#Lambda表达式和Functional接口" class="headerlink" title="Lambda表达式和Functional接口"></a>Lambda表达式和Functional接口</h3><ol><li>接口的默认与静态方法</li><li>方法引用：<br> 对象::实例方法名<br> 类::静态方法名<br> 类::实例方法名<br> 构造器引用 类::new<br> 数组引用<code>Type[]::new</code></li><li>重复注解</li><li>更好的类型推测机制</li><li>扩展注解： ElementType.TYPE_USE、 ElementType.TYPE_PARAMETER；可以为任何代码添加注解(接口、异常)</li></ol><h3 id="编译器新特性"><a href="#编译器新特性" class="headerlink" title="编译器新特性"></a>编译器新特性</h3><p>通过<code>-parameters</code>参数可以将方法参数名添加到字节码</p><h3 id="类库的新特性"><a href="#类库的新特性" class="headerlink" title="类库的新特性"></a>类库的新特性</h3><ol><li><p>Optional：解决空指针异常<br> Consumer<t><br> Supplier<t><br> Function&lt;T, R&gt;<br> Predicate<t><br> Comparator<t></t></t></t></t></p></li><li><p>Stream：<br> filter过滤<br> sort排序<br> map映射<br> match匹配<br> reduce规约</p></li><li><p>Date/Time API<br> Instant<br> Clock时钟<br> Timezones时区<br> LocalTime/LocalDate/LocalDateTime本地时间</p><p> <strong>注意：</strong>和java.text.SimpleDateFormat不同的是，DateTimeFormatter是不可变的，所以它是线程安全的。</p></li><li><p>Base64：Base64编码成为类库标准</p></li><li><p>并行：parallelSort()、</p></li><li><p>并发：java.util.concurrent包</p><blockquote><p>ConcurrentHashMap增加新方法支持聚集<br>ForkJoinPool增加新方法支持共有资源池<br>locks.StampedLock，用来替换locks.ReadWriteLock<br>atomic包下增加DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder</p></blockquote></li><li><p>集合<br> HashMap：链表 + 红黑树<br> ConcurrentHashMap：采用了CAS算法</p></li></ol><h3 id="Java工具"><a href="#Java工具" class="headerlink" title="Java工具"></a>Java工具</h3><ol><li>Norshorn引擎 jjs</li><li>类依赖分析器 jdeps：可以用来分析’.class’、目录、jar</li></ol><h3 id="JVM新特性"><a href="#JVM新特性" class="headerlink" title="JVM新特性"></a>JVM新特性</h3><ol><li>PermGen空间被Metaspace取代<br> -XX:PermSize      -XX:MetaSpaceSize<br> -XX:MaxPermSize   -XX:MaxMetaspaceSize</li></ol><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><h3 id="IO-NIO改进"><a href="#IO-NIO改进" class="headerlink" title="IO/NIO改进"></a>IO/NIO改进</h3><ol><li>改进java.nio.charset.Charset的实现，精简了 jre/lib/charsets.jar 包；优化了 String(byte[],*) 构造方法和 String.getBytes() 方法的性能</li><li>新增API<br> BufferedReader.line(): 返回文本行的流 Stream<string><br> File.lines(Path, Charset):返回文本行的流 Stream<string><br> File.list(Path): 遍历当前目录下的文件和目录<br> File.walk(Path, int, FileVisitOption): 遍历某一个目录下的所有文件和指定深度的子目录<br> File.find(Path, int, BiPredicate, FileVisitOption… ): 查找相应的文件</string></string></li></ol><h2 id="JDK9"><a href="#JDK9" class="headerlink" title="JDK9"></a>JDK9</h2><p><a href="https://openjdk.java.net/projects/jdk9/" target="_blank" rel="noopener">OpenJDK9</a></p><p>“Java SE 9 has reached end of support. Users of Java SE 9 should switch to Java SE 10.”<br><strong>注意：</strong>官网明确表明，jdk9已经不被支持，用户可以切到jdk10</p><h3 id="新特性-1"><a href="#新特性-1" class="headerlink" title="新特性"></a>新特性</h3><blockquote><p>102: Process API Updates<br>110: HTTP 2 Client: HTTP/2 用于替换’HttpURLConnection’<br>143: Improve Contended Locking: 锁争用机制<br>158: Unified JVM Logging<br>165: Compiler Control: 编译控制<br>193: Variable Handles: 操作变量<br>197: Segmented Code Cache: 代码分段缓存<br>199: Smart Java Compilation, Phase Two: 更智能的Java编译器<br>200: The Modular JDK<br>201: Modular Source Code<br>211: Elide Deprecation Warnings on Import Statements<br>212: Resolve Lint and Doclint Warnings<br>213: Milling Project Coin<br>214: Remove GC Combinations Deprecated in JDK 8<br>215: Tiered Attribution for javac<br>216: Process Import Statements Correctly<br>217: Annotations Pipeline 2.0: 注解2.0<br>219: Datagram Transport Layer Security (DTLS)<br>220: Modular Run-Time Images<br>221: Simplified Doclet API<br>222: 增加jshell(Read-Eval-Print Loop)REPL交互<br>223: New Version-String Scheme:<br>224: HTML5 Javadoc<br>225: Javadoc Search<br>226: UTF-8 Property Files<br>227: Unicode 7.0<br>228: Add More Diagnostic Commands<br>229: Create PKCS12 Keystores by Default<br>231: Remove Launch-Time JRE Version Selection<br>232: Improve Secure Application Performance<br>233: Generate Run-Time Compiler Tests Automatically<br>235: Test Class-File Attributes Generated by javac<br>236: JS解析API<br>237: Linux/AArch64 Port<br>238: Multi-Release JAR Files: 多版本的jars<br>240: 移除JVM TI hprof Agent<br>241: 移除jhat工具<br>243: Java-Level JVM Compiler Interface<br>244: TLS Application-Layer Protocol Negotiation Extension<br>245: Validate JVM Command-Line Flag Arguments<br>246: Leverage CPU Instructions for GHASH and RSA<br>247: Compile for Older Platform Versions<br>248: 默认G1为垃圾收集器<br>249: OCSP Stapling for TLS<br>250: Store Interned Strings in CDS Archives<br>251: Multi-Resolution Images<br>252: Use CLDR Locale Data by Default<br>253: Prepare JavaFX UI Controls &amp; CSS APIs for Modularization<br>254: Compact Strings: 压缩字符串<br>255: Merge Selected Xerces 2.11.0 Updates into JAXP<br>256: BeanInfo Annotations<br>257: Update JavaFX/Media to Newer Version of GStreamer<br>258: HarfBuzz Font-Layout Engine<br>259: 栈跟踪API<br>260: Encapsulate Most Internal APIs<br>261: 模块化<br>262: TIFF Image I/O<br>263: HiDPI Graphics on Windows and Linux<br>264: Platform Logging API and Service<br>265: Marlin Graphics Renderer<br>266: More Concurrency Updates<br>267: 支持Unicode 8.0<br>268: XML Catalogs<br>269: Convenience Factory Methods for Collections<br>270: Reserved Stack Areas for Critical Sections<br>271: 统一GC日志<br>272: Platform-Specific Desktop Features<br>273: DRBG-Based SecureRandom Implementations<br>274: Enhanced Method Handles<br>275: Modular Java Application Packaging<br>276: Dynamic Linking of Language-Defined Object Models<br>277: Enhanced Deprecation<br>278: Additional Tests for Humongous Objects in G1<br>279: Improve Test-Failure Troubleshooting<br>280: Indify String Concatenation<br>281: HotSpot C++ Unit-Test Framework<br>282: Java链接jlink<br>283: Enable GTK 3 on Linux<br>284: New HotSpot Build System<br>285: Spin-Wait Hints<br>287: SHA-3 Hash Algorithms<br>288: Disable SHA-1 Certificates<br>289: 废除了Applet API<br>290: Filter Incoming Serialization Data<br>291: 放弃Concurrent Mark Sweep (CMS)垃圾收集器<br>292: Implement Selected ECMAScript 6 Features in Nashorn<br>294: Linux/s390x Port<br>295: Ahead-of-Time (AOT)编译<br>297: Unified arm32/arm64 Port<br>298: 移除Demos和Samples代码<br>299: Reorganize Documentation</p></blockquote><h2 id="JDK10"><a href="#JDK10" class="headerlink" title="JDK10"></a>JDK10</h2><p><a href="https://openjdk.java.net/projects/jdk/10/" target="_blank" rel="noopener">OpenJDK10文档</a><br><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk10-downloads-4416644.html" target="_blank" rel="noopener">OracleJDK下载</a></p><h3 id="新特性-2"><a href="#新特性-2" class="headerlink" title="新特性"></a>新特性</h3><blockquote><p>286: Local-Variable Type Inference:<br>296: 合并JDK到一个仓库<br>304: Garbage-Collector Interface<br>307: G1支持并行Full GC<br>310: 程序类数据共享<br>312: Thread-Local Handshakes: 握手操作是一个回调操作，当线程处于一个安全状态时被调用，目前支持x64平台，可以使用<code>-XX:ThreadLocalHandshakes</code>选项，默认为true<br>313: 移除javah生成工具<br>314: Additional Unicode Language-Tag Extensions<br>316: 堆分配在可以选择内存设备：有些系统提供non-DRAM内存，例如：NTFS DAX模式、ext4 DAX模式，这种模式提供了一种映射到物理内存的虚拟内存直接映射。可使用<code>-XX:AllocateHeapAt=&lt;path&gt;</code>选项配置，<code>-Xmx, -Xms</code>等其他参数正常工作，注意：1.确保该文件的权限，2.当应用终止时移除该文件<br>317: 基于Java的JIT编译器(实验阶段)<br>319: 根证书<br>322: Time-Based Release Versioning</p></blockquote><h2 id="JDK11-LTS"><a href="#JDK11-LTS" class="headerlink" title="JDK11 LTS"></a>JDK11 LTS</h2><p>继jdk8后的大版本LTS<br><a href="https://jdk.java.net/java-se-ri/11" target="_blank" rel="noopener">OpenJDK11下载</a><br><a href="https://openjdk.java.net/projects/jdk/11/" target="_blank" rel="noopener">OpenJDK11文档</a><br><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html" target="_blank" rel="noopener">OracleJDK下载</a><br><a href="https://docs.oracle.com/en/java/javase/11/" target="_blank" rel="noopener">Oracle文档</a></p><h3 id="新特性-3"><a href="#新特性-3" class="headerlink" title="新特性"></a>新特性</h3><blockquote><p>181: Nest-Based Access Control<br>309: Dynamic Class-File Constants: 动态的类文件常量<br>315: Improve Aarch64 Intrinsics<br>318: Epsilon: 一个空操作收集器<br>320: 移除了JavaEE和CORBA模块<br>321: HTTP Client (标准)<br>323: Local-Variable Syntax for Lambda Parameters<br>324: 支持Curve25519和Curve448的key协议<br>327: 支持Unicode 10<br>328: 飞行记录器JFR<br>329: ChaCha20 and Poly1305 xx20和Poly1305加密算法<br>330: Launch Single-File Source-Code Programs<br>331: Low-Overhead Heap Profiling: 低开销的堆分配采样<br>332: TLS升级为1.3<br>333: ZGC(实验阶段): 可扩展低延时的垃圾收集器<br>335: 废除了JS解析器Nashorn<br>336: 弃用Pack200工具类和API</p></blockquote><h2 id="JDK12"><a href="#JDK12" class="headerlink" title="JDK12"></a>JDK12</h2><p>jdk12发布了，jdk20还会远吗?</p><p><a href="https://jdk.java.net/12/" target="_blank" rel="noopener">OpenJDK下载</a><br><a href="https://openjdk.java.net/projects/jdk/12/" target="_blank" rel="noopener">OpenJDK12文档</a><br><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk12-downloads-5295953.html" target="_blank" rel="noopener">OracleJDK12下载</a><br><a href="https://docs.oracle.com/en/java/javase/12/" target="_blank" rel="noopener">OracleJDK12文档</a></p><h3 id="新特性-4"><a href="#新特性-4" class="headerlink" title="新特性"></a>新特性</h3><blockquote><p>189:    Shenandoah(实验阶段): 低停顿的垃圾收集器<br>230:    Microbenchmark Suite<br>325:    Switch语法<br>334:    JVM Constants API<br>340:    One AArch64 Port, Not Two<br>341:    Default CDS Archives<br>344:    G1实现可中止的Mixed GC：如果G1发现collection set重复尝试选择的region数量错误，就会选择一种增量的方式：把collection set分成两部分(强制的、可选择的)。G1回收强制性部分后，如果还有时间就开始以一种更细粒度回收可选择性部分，粒度3取决于时间，更多是一次一个region。当预测足够准确后，可选择部分就会越来越小，直到collection set全部变成强制性。当预测不精确后，下次会重新分成两部分<br>346:    Promptly Return Unused Committed Memory from G1</p></blockquote><h2 id="JDK13"><a href="#JDK13" class="headerlink" title="JDK13"></a>JDK13</h2><h3 id="新特性-5"><a href="#新特性-5" class="headerlink" title="新特性"></a>新特性</h3><blockquote><p>350:    Dynamic CDS Archives<br>351:    ZGC: Uncommit Unused Memory<br>353:    重新实现了Socket API<br>354:    Switch语法(预览)<br>355:    文本块(预览)</p></blockquote><h2 id="JDK14-LTS"><a href="#JDK14-LTS" class="headerlink" title="JDK14 LTS"></a>JDK14 LTS</h2><p><a href="https://jdk.java.net/java-se-ri/14" target="_blank" rel="noopener">OpenJDK14源码</a></p><blockquote><p>305:    Pattern Matching for instanceof (预览)<br>343:    Packaging Tool (孵化阶段)<br>345:    NUMA-Aware Memory Allocation for G1<br>349:    JFR Event Streaming<br>352:    Non-Volatile Mapped Byte Buffers<br>358:    更有用的NullPointerExceptions<br>359:    Records (Preview)<br>361:    Switch语法(预览)<br>362:    废除了对Solaris和SPARC的支持<br>363:    移除了Concurrent Mark Sweep (CMS)垃圾回收器<br>364:    ZGC在macOS平台的实现<br>365:    ZGC在Windows平台的实现<br>366:    弃用ParallelScavenge + SerialOld GC组合模式<br>367:    移除Pack200工具类和API<br>368:    Text Blocks (二次预览)<br>370:    Foreign-Memory Access API (孵化阶段)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知不觉OpenJDK16快要发布了，大多还停留在jdk6/7/8上，jdk的快速迭代，让人非常兴奋。JDK发布版本分为过渡版本和长时间支持版本(LTS)，一般在生产中采用LTS版本可以满足长期维护。下面大致罗列一下jdk的新特性。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://impwang.cn/categories/Java/"/>
    
    
      <category term="java,jdk" scheme="http://impwang.cn/tags/java-jdk/"/>
    
  </entry>
  
  <entry>
    <title>第十七天 + 第十八天</title>
    <link href="http://impwang.cn/2020/12/08/os-17/"/>
    <id>http://impwang.cn/2020/12/08/os-17/</id>
    <published>2020-12-08T04:10:20.000Z</published>
    <updated>2020-12-20T04:15:58.397Z</updated>
    
    <content type="html"><![CDATA[<p>这一卡停歇主要在多任务切换时鼠标focus的切换上出问题了，在Deepin上尝试了很多种方法，其中包括QEMU的多种版本，百思不得其解。最后想着在其它系统上试一下，最后在Ubuntu20.04上竟然很完美的运行没有任何问题。当时就懵逼了。有时候真的是，遇到问题，多试试其它的，也许是系统的问题呢。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一卡停歇主要在多任务切换时鼠标focus的切换上出问题了，在Deepin上尝试了很多种方法，其中包括QEMU的多种版本，百思不得其解。最后想着在其它系统上试一下，最后在Ubuntu20.04上竟然很完美的运行没有任何问题。当时就懵逼了。有时候真的是，遇到问题，多试试其它的，也许是系统的问题呢。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>think-in-career</title>
    <link href="http://impwang.cn/2020/12/07/think-in-career/"/>
    <id>http://impwang.cn/2020/12/07/think-in-career/</id>
    <published>2020-12-07T13:26:34.000Z</published>
    <updated>2020-12-07T13:26:34.836Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>资本主义的胜利</title>
    <link href="http://impwang.cn/2020/11/05/think-in-lism/"/>
    <id>http://impwang.cn/2020/11/05/think-in-lism/</id>
    <published>2020-11-05T07:35:02.000Z</published>
    <updated>2020-12-13T06:58:17.161Z</updated>
    
    <content type="html"><![CDATA[<p>前几年无意中看到一句话，”无论中国文化到哪里，都是对文明的一种毁灭。”，我对这句话的第一次认同是关于国内搜索引擎的的深恶痛绝，网络上到处充斥着复制、粘贴的东西，原创性的缺乏导致泛滥的垃圾，可想而知的结局就是检索成本的增加。如果说背后是利益的驱使，可细想之后，何尝不是文化的问题？<br><a id="more"></a><br>国内经济的快速发展使中国处于全球第二经济体的地位。但是经济的快速发展背后仍然是文明的一片荒芜。建国伊始，我们就面临一次姓社还是姓资的问题，这也那次革命的本质。在很多人的认知里，资本主义是惨无人道的资本家剥削的代表。最终，在稻家人的背叛中，我们走向一种”特色社会主义”，什么”白猫黑猫论”、”造不如买，买不如租”，直接导致中国的科技落后资本主义几十年。<br>“特色社会主义”，既然是特色，就表明既不是资本主义，也不是完全的社会主义。在这种主义里，我们每个人仍然活在”舍小家为大家”、”集体主义”、”先富带动后富”的家国情怀里，而被舍弃的这一部分人已经很难摆脱命运的安排。走到今天，我们已经不得不思考这种制度到底是不是一种优越的制度。”996福报”、”35岁淘汰论”，既然资产阶级已经存在这么多的剥削，我们为什么还要坚持呢？底层劳动人民该有的权益得不到保障，我们还要心肝情愿的付出？<br>在我的学生时代，接触过几家国外的餐饮企业，他们对规章制度的严格要求在国内很多五星级的酒店都无法达到，这就是文化的问题。其中一家是肯德基，一家是希尔顿酒店。肯德基对食物的要求是不留隔夜菜，过期食材必须废弃，油榨食用油每隔多长时间需要更换一次。希尔顿对员工的穿着、食材也是必须遵守规章制度。而这一切到国内很大一部分已经走样了，不再被遵守。我们可能都会说老外太死板，可不知国人的那种”圆滑”已经到了让人深恶痛绝的地步。<br>我对国内的厌倦来源于对北京的失望，甚至绝望。北方文明和南方文明有着巨大的差异，一个是公共服务，一个是服务行业。北京，作为政治中心，可以说是北方唯一一个最文明的城市，昌平图书馆作为一个公共服务场所，那里的服务简直让人对北京这个帝都产生怀疑，网上完全是的服务的控诉，和深圳的图书馆相比完全是两个世界。老外的很多产品卖的都是服务，如果你尝试买一次国内便宜的服务，看似省了不少，而售后服务的恶劣简直让你发狂。比如苹果、微软、肯德基，相信很多狂街的人都经历过满世界找厕所的痛苦，满满的大街上竟然没有一个公共厕所，最后只期待一个肯德基、麦当劳，也许这就是所谓的文明的吧！而如今，就连肯德基也出现了没有厕所、厕所无法使用、不提供充电接口的情况，而且越来越多，如果这样，我为什么要去一个溢价极高的餐厅？这是一种文明的倒退，而这个是否在本土化过程中的一些问题呢？<br>文化，或者说文明，无论是三千年，还是五千年，如果对人类的文明是一种伤害的话，所谓的文化自信，我是不在乎的，一切逆历史潮流的东西，我们也是没有必要去发扬光大的。人是本体，一切都是为人类服务，如果一种文化只追求最大利益化，而舍弃了人类最基本的利益，我希望她早日湮灭在历史潮流中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几年无意中看到一句话，”无论中国文化到哪里，都是对文明的一种毁灭。”，我对这句话的第一次认同是关于国内搜索引擎的的深恶痛绝，网络上到处充斥着复制、粘贴的东西，原创性的缺乏导致泛滥的垃圾，可想而知的结局就是检索成本的增加。如果说背后是利益的驱使，可细想之后，何尝不是文化的问题？&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第十五天 + 第十六天</title>
    <link href="http://impwang.cn/2020/10/26/os-15/"/>
    <id>http://impwang.cn/2020/10/26/os-15/</id>
    <published>2020-10-26T15:09:14.000Z</published>
    <updated>2020-10-27T15:47:25.646Z</updated>
    
    <content type="html"><![CDATA[<p>好久没写了，落了太多，主要中间被鼠标的移动卡住了，解决后一直没心思写。今天的主要任务是<code>多任务</code>。<br>多任务的原理，CPU执行任务切换时，将当前寄存器中的值写入内存(也叫保存现场)，调用任务执行完成后，从内存中将值读取到寄存器，继续执行之前的任务。</p><a id="more"></a><p>EIP: 扩展指令指针寄存器，是一个32位寄存器，对应16位的IP寄存器。CPU使用EIP来存储下一条执行指令内存地址的寄存器。理论上每执行一条指令，EIP寄存器的值会自动累加，指向下一条指令的内存地址。</p><p>JMP: JMP指令本质上还是通过将跳转的内存地址赋值到EIP，同时将EIP状态保存在TSS中，</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct TSS32 &#123;</span><br><span class="line"><span class="keyword">int</span> backlink, esp0, ss0, esp1, ss1, esp2, ss2, <span class="built_in">cr3</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">eip</span>, eflags, <span class="built_in">eax</span>, <span class="built_in">ecx</span>, <span class="built_in">edx</span>, <span class="built_in">ebx</span>, <span class="built_in">esp</span>, <span class="built_in">ebp</span>, <span class="built_in">esi</span>, <span class="built_in">edi</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">es</span>, <span class="built_in">cs</span>, <span class="built_in">ss</span>, <span class="built_in">ds</span>, <span class="built_in">fs</span>, <span class="built_in">gs</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">int</span> ldtr, iomap<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>JMP指令分为两种模式：<br>near模式：只改写EIP寄存器<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">JMP</span>keystatus</span><br></pre></td></tr></table></figure></p><p>far模式：同时改写EIP和CS寄存器，格式中带冒号’:’<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">JMP</span><span class="built_in">DWORD</span> <span class="number">2</span>*<span class="number">8</span>:<span class="number">0x0000001b</span>   // [<span class="built_in">EIP</span>]=<span class="number">0x1b</span><span class="comment">; [CS]=2*8</span></span><br></pre></td></tr></table></figure></p><p><strong>注意：</strong>如果JMP的目标地址不是可执行代码，而是TSS，则CPU不执行对EIP、CS的改写，而是执行任务切换。TSS的判断通过读取GDT的设置来确定。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_segmdesc(<span class="name">gdt</span> + <span class="number">3</span>, <span class="number">103</span>, (<span class="name">int</span>) <span class="symbol">&amp;tss_a</span>, AR_TSS32)<span class="comment">;  // 将任务tss_a定义在gdt的3号位置</span></span><br></pre></td></tr></table></figure></p><p>TR寄存器：任务寄存器。记录CPU当前正在运行的任务，存储GDT的编号乘以8的数值(约定规则)。例如：<code>gdt + 3</code>会在TR中存入<code>3*8</code>，</p><p><code>LTR</code>：改变TR寄存器的值，并不会进行任务切换。</p><p><code>JMP FAR</code>: 从指定的内存地址读取4字节数据存入EIP寄存器，继续读取2字节存入CS寄存器。例如：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMPFAR<span class="string">[ESP+4]</span>    ; <span class="string">[EIP]</span>=<span class="string">[ESP+4]</span>  <span class="string">[CS]</span>=<span class="string">[ESP+8]</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没写了，落了太多，主要中间被鼠标的移动卡住了，解决后一直没心思写。今天的主要任务是&lt;code&gt;多任务&lt;/code&gt;。&lt;br&gt;多任务的原理，CPU执行任务切换时，将当前寄存器中的值写入内存(也叫保存现场)，调用任务执行完成后，从内存中将值读取到寄存器，继续执行之前的任务。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第五天 + 第六天</title>
    <link href="http://impwang.cn/2020/10/05/os-05/"/>
    <id>http://impwang.cn/2020/10/05/os-05/</id>
    <published>2020-10-05T08:23:07.000Z</published>
    <updated>2020-12-13T06:58:17.157Z</updated>
    
    <content type="html"><![CDATA[<p>难度越来越大了。今天的内容设计的中断表，全局分段表，核心就是GDT和IDT。第五天、第六天内容偏理论性比较多，结合放在一篇博客内。</p><a id="more"></a><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>系统中存在多个程序同时运行，如果加载到相同的内存地址，则会导致内存冲突而无法运行。为了解决这个问题就需要用到分段的思想。</p><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>分段就是把整个内存分成很多块(block)，每一块的起始位置都看作0x0000，然后对应到实际的物理地址。段寄存器DS终于派上用场了。<br>如何表示一个段？</p><ol><li>段的大小是多少</li><li>段对应的物理起始位置</li><li>段的权限(禁止写入，禁止执行，系统专用等)</li></ol><p>原理：<br>CPU表示一个段需要8字节，DS为16位，实际上为了兼容，能用的只有13位，所以能表示的段有$ 2^13 = 8192 $个段，表示这些段需要$ 8192 * 8 = 64KB $，显然CPU不具备存储这么多数据的条件，而是放在内存中，这就是GDT(全局段号记录表)，这块内存的起始地址放在CPU的特殊寄存器GDTR内。</p><p>段上限：表示一个段有多少个字节，用low(2)+mid(1)+mid(1)共4个字节表示。最大表示4GB需要4B，加上基地址4B，总共需要8B，段上限只保留20位，2^20 = 1MB，通过将段属性一个位设置为1，段上限的单位解释为页，1页是4KB，这样 1MB * 4KB = 4GB。这20位用low 2个字节和high的高4位表示。</p><p>段的访问属性：使用剩余的12位表示，<code>xxxx0000 xxxxxxxxx</code>，高4位0给段上限使用，低4位使用<code>GD00</code>表示，D-段上限的Gbit，D-段的模式，1是32位模式，0是16位模式。<br>| bit位 | 用途 | 权限 |<br>|:-|:-:|:-:|<br>| 0x00 | 未使用的记录表| - |<br>| 0x92 | 系统专用 | 可读，可写，不可执行 |<br>| 0x9a | 系统专用 | 可读，不可写，可执行 |<br>| 0xf2 | 应用程序用 | 可读，可写，不可执行 |<br>| 0xfa | 应用程序用 | 可读，不可写，可执行 |</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>IDR: 中断记录表。记录中断号和处理函数的对应关系。</p><h3 id="PIC"><a href="#PIC" class="headerlink" title="PIC"></a>PIC</h3><p>IRQ: interrupt request。<br>PIC: 可中断编程控制器。CPU单独只能处理一个中断，主板通过增加几个辅助芯片组成芯片组。PIC是将8个中断信号集合成一个中断信号的装置。主PIC和CPU直连，从PIC连接在主PIC的IRQ2上。<br>PIC内部有很多寄存器，通过端口号进行区分写入哪一个寄存器。即便端口相同，也可以通过规则区分：先写入ICW1，接着写入ICW2。<br>IMR: interrupt mask register 中断屏蔽寄存器。8位分别对应8路IRQ，如果某一位的值置为1，则该位对应的IRQ信号被屏蔽，PIC就忽视该信号。<br>ICW: initial control word 初始化控制数据。总共有4个，编号为1~4。</p><blockquote><p>ICW1和ICW4<br>ICW3<br>ICW2: 决定IRQ以哪一号中断通知CPU。不同的操作系统可以单独设定。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;难度越来越大了。今天的内容设计的中断表，全局分段表，核心就是GDT和IDT。第五天、第六天内容偏理论性比较多，结合放在一篇博客内。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第四天</title>
    <link href="http://impwang.cn/2020/10/04/os-04/"/>
    <id>http://impwang.cn/2020/10/04/os-04/</id>
    <published>2020-10-04T06:22:53.000Z</published>
    <updated>2020-10-06T16:35:02.180Z</updated>
    
    <content type="html"><![CDATA[<p>第四天了，今天的功能就是在画面上显示点东西。本质上，画面的展示还是对VGA显卡的操作。</p><a id="more"></a><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>这一部分主要是C语言的编程，对BIOS的操作通过在<code>bootpack.c</code>调用<code>naskfun.asm</code>汇编来实现。</p><ol><li>显示白色<br>bootpack.c调用write_mem8()方法来实现对VRAM内存的操作。<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> io_hlt(<span class="built_in">void</span>);</span><br><span class="line"><span class="built_in">void</span> write_mem8(<span class="built_in">int</span> addr, <span class="built_in">int</span> data);</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> HariMain(<span class="built_in">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"><span class="comment">// 白色</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0xa0000</span>; i &lt;= <span class="number">0xaffff</span>; i++) &#123;</span><br><span class="line">write_mem8(i, <span class="number">15</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">io_hlt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>naskfunc.asm<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; naskfunc</span></span><br><span class="line"><span class="comment">; TAB=4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">section</span> .data</span><br><span class="line"><span class="meta">section</span> .text</span><br><span class="line"><span class="meta">global</span>io_hlt,write_mem8</span><br><span class="line"></span><br><span class="line"><span class="symbol">io_hlt:</span><span class="comment">; void io_hlt(void);</span></span><br><span class="line"><span class="keyword">HLT</span></span><br><span class="line"><span class="keyword">RET</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">write_mem8:</span><span class="comment">; void write_mem8(int addr, int data);</span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">ECX</span>,[<span class="built_in">ESP</span>+<span class="number">4</span>]<span class="comment">;</span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">AL</span>,[<span class="built_in">ESP</span>+<span class="number">8</span>]<span class="comment">;</span></span><br><span class="line"><span class="keyword">MOV</span>[<span class="built_in">ECX</span>],<span class="built_in">AL</span></span><br><span class="line"><span class="keyword">RET</span></span><br></pre></td></tr></table></figure></p><p><strong>注意：</strong>section伪指令的位置一定要注意，因为对section的语法陌生，导致出现黑屏；其次要注意asm文件中<code>io_hlt</code>函数名的语法，有的编译器需要加前缀<code>_io_hlt</code></p><ol start="2"><li>通过设定调色板显示彩条<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> HariMain(<span class="built_in">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">char *vram;</span><br><span class="line"><span class="built_in">int</span> xsize, ysize;</span><br><span class="line"></span><br><span class="line">init_palette();</span><br><span class="line">vram = (char *) <span class="number">0xa0000</span>;</span><br><span class="line">xsize = <span class="number">320</span>;</span><br><span class="line">ysize = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩形1</span></span><br><span class="line">boxfill8(vram, xsize, COL8_008484,  <span class="number">0</span>,         <span class="number">0</span>,          xsize -  <span class="number">1</span>, ysize - <span class="number">29</span>);</span><br><span class="line">boxfill8(vram, xsize, COL8_C6C6C6,  <span class="number">0</span>,         ysize - <span class="number">28</span>, xsize -  <span class="number">1</span>, ysize - <span class="number">28</span>);</span><br><span class="line">boxfill8(vram, xsize, COL8_FFFFFF,  <span class="number">0</span>,         ysize - <span class="number">27</span>, xsize -  <span class="number">1</span>, ysize - <span class="number">27</span>);</span><br><span class="line">boxfill8(vram, xsize, COL8_C6C6C6,  <span class="number">0</span>,         ysize - <span class="number">26</span>, xsize -  <span class="number">1</span>, ysize -  <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩形2</span></span><br><span class="line">boxfill8(vram, xsize, COL8_FFFFFF,  <span class="number">3</span>,         ysize - <span class="number">24</span>, <span class="number">59</span>,         ysize - <span class="number">24</span>);</span><br><span class="line">boxfill8(vram, xsize, COL8_FFFFFF,  <span class="number">2</span>,         ysize - <span class="number">24</span>,  <span class="number">2</span>,         ysize -  <span class="number">4</span>);</span><br><span class="line">boxfill8(vram, xsize, COL8_848484,  <span class="number">3</span>,         ysize -  <span class="number">4</span>, <span class="number">59</span>,         ysize -  <span class="number">4</span>);</span><br><span class="line">boxfill8(vram, xsize, COL8_848484, <span class="number">59</span>,         ysize - <span class="number">23</span>, <span class="number">59</span>,         ysize -  <span class="number">5</span>);</span><br><span class="line">boxfill8(vram, xsize, COL8_000000,  <span class="number">2</span>,         ysize -  <span class="number">3</span>, <span class="number">59</span>,         ysize -  <span class="number">3</span>);</span><br><span class="line">boxfill8(vram, xsize, COL8_000000, <span class="number">60</span>,         ysize - <span class="number">24</span>, <span class="number">60</span>,         ysize -  <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩形3</span></span><br><span class="line">boxfill8(vram, xsize, COL8_848484, xsize - <span class="number">47</span>, ysize - <span class="number">24</span>, xsize -  <span class="number">4</span>, ysize - <span class="number">24</span>);</span><br><span class="line">boxfill8(vram, xsize, COL8_848484, xsize - <span class="number">47</span>, ysize - <span class="number">23</span>, xsize - <span class="number">47</span>, ysize -  <span class="number">4</span>);</span><br><span class="line">boxfill8(vram, xsize, COL8_FFFFFF, xsize - <span class="number">47</span>, ysize -  <span class="number">3</span>, xsize -  <span class="number">4</span>, ysize -  <span class="number">3</span>);</span><br><span class="line">boxfill8(vram, xsize, COL8_FFFFFF, xsize -  <span class="number">3</span>, ysize - <span class="number">24</span>, xsize -  <span class="number">3</span>, ysize -  <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">io_hlt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><p>i386</p><p>i486</p><p>i586</p><p>ASM装配程序分为3个部分：</p><ol><li>data部分：声明数据</li><li>bss部分：声明变量</li><li>text部分：用于保存实际代码，必须声明<code>global</code>全局函数，并对函数进行实现。</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> .data</span><br><span class="line"><span class="selector-tag">section</span> .bss</span><br><span class="line"><span class="selector-tag">section</span> .text</span><br><span class="line">    global io_hlt</span><br><span class="line">io_hlt:</span><br><span class="line">    HLT</span><br></pre></td></tr></table></figure><h3 id="本节指令"><a href="#本节指令" class="headerlink" title="本节指令"></a>本节指令</h3><p>‘OUT’: CPU向设备发送电信号。每个设备定义了设备号码，即端口(Port)。<br>‘IN’: CPU从设备获取电信号指令。<br>‘CLI’: 将中断标志位置为0。<br>‘STI’: 将中断标志位置为1。<br>‘PUSHFD’: 将标志位的值按照双字长压入栈。实际操作就是<code>PUSH EFLAGS</code>。<br>‘POPFD’: 按照双字长将标志位的值弹出栈。实际操作就是<code>POP EFLAGS</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第四天了，今天的功能就是在画面上显示点东西。本质上，画面的展示还是对VGA显卡的操作。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第三天</title>
    <link href="http://impwang.cn/2020/10/03/os-03/"/>
    <id>http://impwang.cn/2020/10/03/os-03/</id>
    <published>2020-10-03T09:23:51.000Z</published>
    <updated>2020-12-20T05:15:38.441Z</updated>
    
    <content type="html"><![CDATA[<p>开始运行一些画面了，这个地方卡了很长时间，由于原作者是在Windows下开发，我打算在Deepin下来做，中间没有思路爽性就放下了。最开始写盘采用的是<code>dd</code>命令，网上很多人也是采用dd，但是运行一直报错’load error’，更换了好几个版本的qemu都没有效果，使用<code>gdb</code>进行debug，使用<code>objdump</code>反编译，最后偶然之间发现了一位日本网友在Ubuntu系统实现的<code>Makefile</code>，得以成功。<br>编写系统还是需要很深厚的基础功底。祝各位踩坑的，不抛弃，不放弃吧。</p><a id="more"></a><p><a href="https://qiita.com/pollenjp/items/8fcb9573cdf2dc6e2668" target="_blank" rel="noopener">日本网友基于Ubuntu的实现</a></p><p><a href="https://github.com/wangwanchao/os_30day/tree/main" target="_blank" rel="noopener">我的github</a></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>第三天的主要功能是对磁盘的操作。从单个扇区到多个扇区、多个柱面</p><ol><li><p>读取1个扇区：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">entry:</span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">AX</span>,<span class="number">0</span><span class="comment">; 初始化寄存器</span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">SS</span>,<span class="built_in">AX</span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">SP</span>,<span class="number">0x7c00</span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">DS</span>,<span class="built_in">AX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 读取磁盘1个扇区＝512字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">AX</span>,<span class="number">0x0820</span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">ES</span>,<span class="built_in">AX</span></span><br><span class="line"><span class="keyword">MOV</span><span class="number">CH</span>,<span class="number">0</span><span class="comment">; 柱面</span></span><br><span class="line"><span class="keyword">MOV</span><span class="number">DH</span>,<span class="number">0</span><span class="comment">; 磁头</span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">CL</span>,<span class="number">2</span><span class="comment">; 扇区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MOV</span><span class="number">AH</span>,<span class="number">0x02</span><span class="comment">; AH=0x02:读盘 0x03:写盘 0x04:校验 0x0c:寻道</span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">AL</span>,<span class="number">1</span><span class="comment">; 1个扇区</span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">BX</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">DL</span>,<span class="number">0x00</span><span class="comment">; A驱动器</span></span><br><span class="line"><span class="keyword">INT</span><span class="number">0x13</span><span class="comment">; 调用磁盘BIOS</span></span><br><span class="line"><span class="keyword">JC</span>error<span class="comment">; 如果读盘失败，跳转显示错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 读盘成功进入休眠</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">fin:</span></span><br><span class="line"><span class="keyword">HLT</span>  <span class="comment">;</span></span><br><span class="line"><span class="keyword">JMP</span>fin<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">error:</span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">SI</span>,msg</span><br></pre></td></tr></table></figure></li><li><p>读取18个扇区：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 读盘</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">AX</span>,<span class="number">0x0820</span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">ES</span>,<span class="built_in">AX</span></span><br><span class="line"><span class="keyword">MOV</span><span class="number">CH</span>,<span class="number">0</span><span class="comment">; </span></span><br><span class="line"><span class="keyword">MOV</span><span class="number">DH</span>,<span class="number">0</span><span class="comment">; </span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">CL</span>,<span class="number">2</span><span class="comment">; </span></span><br><span class="line"><span class="symbol">readloop:</span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">SI</span>,<span class="number">0</span><span class="comment">; 记录读盘失败次数的寄存器</span></span><br><span class="line"><span class="symbol">retry:</span></span><br><span class="line"><span class="keyword">MOV</span><span class="number">AH</span>,<span class="number">0x02</span><span class="comment">; </span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">AL</span>,<span class="number">1</span><span class="comment">; </span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">BX</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">DL</span>,<span class="number">0x00</span><span class="comment">; </span></span><br><span class="line"><span class="keyword">INT</span><span class="number">0x13</span><span class="comment">; </span></span><br><span class="line"><span class="keyword">JNC</span>next<span class="comment">; 读盘成功则继续</span></span><br><span class="line"><span class="keyword">ADD</span><span class="built_in">SI</span>,<span class="number">1</span><span class="comment">; 读盘失败则重试5次</span></span><br><span class="line"><span class="keyword">CMP</span><span class="built_in">SI</span>,<span class="number">5</span><span class="comment">; </span></span><br><span class="line"><span class="keyword">JAE</span>error<span class="comment">; 重试5次后仍然失败则跳转到'load error'</span></span><br><span class="line"><span class="keyword">MOV</span><span class="number">AH</span>,<span class="number">0x00</span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">DL</span>,<span class="number">0x00</span><span class="comment">; </span></span><br><span class="line"><span class="keyword">INT</span><span class="number">0x13</span><span class="comment">; 重试未满5次则重置驱动器后继续重试</span></span><br><span class="line"><span class="keyword">JMP</span>retry</span><br><span class="line"><span class="symbol">next:</span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">AX</span>,<span class="built_in">ES</span><span class="comment">; 内存地址后移0x200</span></span><br><span class="line"><span class="keyword">ADD</span><span class="built_in">AX</span>,<span class="number">0x0020</span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">ES</span>,<span class="built_in">AX</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">ADD</span><span class="built_in">CL</span>,<span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">CMP</span><span class="built_in">CL</span>,<span class="number">18</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">JBE</span>readloop<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">JMP</span>     success         <span class="comment">; 成功</span></span><br></pre></td></tr></table></figure></li></ol><p>这里设置AL=1通过循环的方式实现，跟设置AL=17的效果是一致的，没有直接使用AL=17的原因在于BIOS的规则：</p><blockquote><p>指定处理的扇区数，范围在0x01 ~ 0xff(指定0x02以上的数值时，要特别注意<strong>连续处理多个扇区</strong>的条件。)</p></blockquote><ol start="3"><li><p>读取10个柱面：</p></li><li><p>启动区后增加执行程序</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; haribote-os</span></span><br><span class="line"><span class="comment">; TAB=4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ORG</span><span class="number">0xc200</span><span class="comment">; </span></span><br><span class="line"></span><br><span class="line"><span class="symbol">fin:</span></span><br><span class="line">HLT</span><br><span class="line"><span class="keyword">JMP</span>fin</span><br></pre></td></tr></table></figure></li></ol><p>这段代码中可以看到org=0x2c00，为什么呢？因为对空软盘写操作时，文件内容一般是在地址<code>0x004200</code>之后，先写入ipl.bin后，再写入haribote.o，基于0x8000的内存位置，0x8000 + 0x4200 = 0xc200。</p><h2 id="32位模式"><a href="#32位模式" class="headerlink" title="32位模式"></a>32位模式</h2><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>‘EQU’: 用来声明常量值。例如：<code>CYLS EQU&amp; 10</code>表示CYLS=10。<br>‘JC’: jump if carry 如果进位标志(FLAGS.CF)是1，则跳转。<br>‘JNC’: jump if not carry 如果进位标志(FLAGS.CF)是0，则跳转。正好相反。<br>‘JAE’: jump if above or equal 如果大于或等于则跳转。<br>‘JE’: jump if below 如果小于则跳转。<br>‘JBE’: jump if below or equal 如果小于等于则跳转。<br>‘INT 0x13’: 操作磁盘<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">操作磁盘</span><br><span class="line">AH</span><br><span class="line">AL</span><br><span class="line"><span class="attribute">CH</span>=柱面号</span><br><span class="line"><span class="attribute">CL</span>=扇区号</span><br><span class="line"><span class="attribute">DH</span>=磁头号</span><br><span class="line"><span class="attribute">DL</span>=驱动器号</span><br><span class="line">ES:<span class="attribute">BX</span>=缓冲地址</span><br><span class="line">返回值：</span><br></pre></td></tr></table></figure></p><p><strong>注意：</strong>可以看出很多指令都是有规律的。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>汇编编译<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nasm</span> <span class="selector-tag">-f</span> <span class="selector-tag">elf</span> <span class="selector-tag">ipl</span><span class="selector-class">.asm</span> <span class="selector-tag">-o</span> <span class="selector-tag">ipl</span><span class="selector-class">.bin</span></span><br></pre></td></tr></table></figure></p><p>链接编译<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">gcc</span> <span class="selector-tag">-nostdlib</span> <span class="selector-tag">-T</span> <span class="selector-tag">har</span><span class="selector-class">.ld</span></span><br></pre></td></tr></table></figure></p><p>‘-T’：指定链接脚本</p><h3 id="ld脚本"><a href="#ld脚本" class="headerlink" title="ld脚本"></a>ld脚本</h3><p>Linker scripts使用一种特殊的脚本语言实现。用来指定最终可执行二进制文件的格式、布局。一些可执行二进制文件为了能够被BootLoader识别，通常需要指定文件布局。<br>语法：<br>ENTRY: 指定应用的入口点，这个点通常是最终输出文件的第一个可执行指令。<br>OUTPUT_FORMAT：指定可执行文件的输出格式。使用<code>objdump -i</code>可以查看系统支持的格式。<br>STARTUP：用来指定将哪个文件放在可执行文件的起始位置。<br>INPUT：用来替代命令行中指定多个obj文件。<br>OUTPUT：指定生成的可执行文件的名称。<br>MEMORY：用来声明多个内存区域的读写权限。<br>SECTIONS：用来指定内存位置、<code>.text/.data/.bss</code>的信息</p><h3 id="DOS指令"><a href="#DOS指令" class="headerlink" title="DOS指令"></a>DOS指令</h3><ol><li>copy指令<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY [<span class="string">/D</span>] [<span class="string">/V</span>] [<span class="string">/N</span>] [<span class="string">/Y</span> | <span class="string">/-Y</span>] [<span class="string">/Z</span>] [<span class="string">/L</span>] [<span class="string">/A</span> | <span class="string">/B</span> ] source [<span class="string">/A</span> | <span class="string">/B</span>] [+ source [<span class="string">/A</span> | <span class="string">/B</span>] [+ <span class="string">...</span>]] [destination [<span class="string">/A</span> | <span class="string">/B</span>]]</span><br></pre></td></tr></table></figure></li></ol><p>‘source’: 指定要复制的文件。<br>‘/A’: 表示一个 ASCII 文本文件。<br>‘/B’: 表示一个二进位文件。<br>‘/D’: 允许解密要创建的目标文件，destination 为新文件指定目录和/或文件名。<br>‘/V 验证新文件写入是否正确。<br>‘/N 复制带有非 8dot3 名称的文件时，尽可能使用短文件名。<br>‘/Y 不使用确认是否要覆盖现有目标文件的提示。<br>‘/-Y’: 使用确认是否要覆盖现有目标文件的提示。<br>‘/Z’: 用可重新启动模式复制已联网的文件。<br>‘/L’: 如果源是符号链接，请将链接复制到目标而不是源链接指向的实际文件。</p><ol start="2"><li><p>mcopy指令</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mcopy</span></span><br></pre></td></tr></table></figure></li><li><p>format指令</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">format</span></span><br></pre></td></tr></table></figure></li><li><p>mformat指令<br>将一个最小化的<code>MS-DOS</code>文件系统添加到已经被Unix系统格式化的磁盘/软盘中，该文件系统包含启动区(boot sector)、FAT、根目录(root directory)。<br>现在的电脑，基本都只有1个软盘，以前一般都是2个。</p></li></ol><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mformat <span class="string">[-t cylinders|-T tot_sectors]</span> <span class="string">[-h heads]</span> <span class="string">[-s sectors]</span></span><br><span class="line">  <span class="string">[-f size]</span> <span class="string">[-1]</span> <span class="string">[-4]</span> <span class="string">[-8]</span></span><br><span class="line">  <span class="string">[-v volume_label]</span></span><br><span class="line">  <span class="string">[-F]</span> <span class="string">[-S sizecode]</span></span><br><span class="line">  <span class="string">[-M software_sector_size]</span></span><br><span class="line">  <span class="string">[-N serial_number]</span> <span class="string">[-a]</span></span><br><span class="line">  <span class="string">[-C]</span> <span class="string">[-H hidden_sectors]</span> <span class="string">[-I fsVersion]</span></span><br><span class="line">  <span class="string">[-r root_sectors]</span> <span class="string">[-L fat_len]</span> </span><br><span class="line">  <span class="string">[-B boot_sector]</span> <span class="string">[-k]</span></span><br><span class="line">  <span class="string">[-m media_descriptor]</span></span><br><span class="line">  <span class="string">[-K backup_boot]</span></span><br><span class="line">  <span class="string">[-R nb_reserved_sectors]</span></span><br><span class="line">  <span class="string">[-c clusters_per_sector]</span></span><br><span class="line">  <span class="string">[-d fat_copies]</span></span><br><span class="line">  <span class="string">[-X]</span> <span class="string">[-2 sectors_on_track_0]</span> <span class="string">[-3]</span></span><br><span class="line">  <span class="string">[-0 rate_on_track_0]</span> <span class="string">[-A rate_on_other_tracks]</span></span><br><span class="line">  drive:</span><br></pre></td></tr></table></figure><p>‘-f’: 指定将要格式化软盘的DOS文件系统的size，仅支持个别参数(160K、180K、320K、360K、720K、1200K、1440K、2880K)，如果需要支持其他参数，可以结合’-h/-t/-s’使用。一张软盘2个面，每个柱面18个扇区，80个柱面，每个扇区512B：$ 2<em>18</em>80*512 = 1440KB $<br>‘-C’: 创建磁盘镜像，并将<code>MS-DOS</code>安装在磁盘上，很明显这个参数在物理设备上是不起作用的，例如：软盘、硬盘。<br>‘-B’: 代替默认的，使用boot sector来存储给定的文件、设备。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始运行一些画面了，这个地方卡了很长时间，由于原作者是在Windows下开发，我打算在Deepin下来做，中间没有思路爽性就放下了。最开始写盘采用的是&lt;code&gt;dd&lt;/code&gt;命令，网上很多人也是采用dd，但是运行一直报错’load error’，更换了好几个版本的qemu都没有效果，使用&lt;code&gt;gdb&lt;/code&gt;进行debug，使用&lt;code&gt;objdump&lt;/code&gt;反编译，最后偶然之间发现了一位日本网友在Ubuntu系统实现的&lt;code&gt;Makefile&lt;/code&gt;，得以成功。&lt;br&gt;编写系统还是需要很深厚的基础功底。祝各位踩坑的，不抛弃，不放弃吧。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
