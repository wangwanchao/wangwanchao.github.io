<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux环境下编译JDK11(1)</title>
    <url>/2021/03/20/jvm-compile-11/</url>
    <content><![CDATA[<p>第n次编译jdk，以前的编译功力尚浅，之后没再去探索。这次在编译OS之后对C语言有一些更好的理解，希望能够深入JDK。对比<code>OpenJDK1.8-</code>，<code>OpenJDK11+</code>简直是简直是easy模式。</p>
<a id="more"></a>
<h1 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h1><p>理解jdk和hotspot的关系：</p>
<h2 id="Linux下编译"><a href="#Linux下编译" class="headerlink" title="Linux下编译"></a>Linux下编译</h2><p>linux主要分两大分支：<br>基于apt安装库的分支：Debian, Ubuntu, Deepin<br>基于rpm安装库的分支：Fedora, Red Hat, CentOS<br>以下主要基于Deepin系统编译。(不同版本可能会有问题，喜欢Ubuntu的建议Ubuntu)</p>
<h3 id="编译jdk"><a href="#编译jdk" class="headerlink" title="编译jdk"></a>编译jdk</h3><h4 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install build-essential</span><br></pre></td></tr></table></figure>
<p>检查依赖工具版本：<br><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">gcc</span> <span class="string">-v </span></span><br><span class="line"><span class="attr">clang</span> <span class="string">-v</span></span><br></pre></td></tr></table></figure></p>
<p>版本需要<code>gcc 4.8+</code>，<code>clang 3.2+</code>，我的系统为<code>gcc version 6.3.0</code>，<code>clang version 3.8.1-24</code></p>
<h4 id="安装Boot-JDK"><a href="#安装Boot-JDK" class="headerlink" title="安装Boot JDK"></a>安装Boot JDK</h4><p>JDK的编译需要依赖于前置版本，否则一些依赖类找不到会报错。<code>java -version</code>检查默认JDK的版本，也可以通过<code>--with-boot-jdk</code>指定Boot JDK的路径。</p>
<h4 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h4><p><code>make -v</code>检测make版本，我的默认<code>GNU Make 4.1</code>。<br><code>bash --version</code>，<code>GNU bash，版本 4.4.12</code></p>
<h4 id="检测编译依赖环境，同时生成编译脚本-至关重要"><a href="#检测编译依赖环境，同时生成编译脚本-至关重要" class="headerlink" title="检测编译依赖环境，同时生成编译脚本(至关重要)"></a>检测编译依赖环境，同时生成编译脚本(至关重要)</h4><p>在根目录下<code>build/linux-x64-normal-server-${BUILD}</code>，比如编译fastdebug版本，则生成<code>build/linux-x64-normal-server-fastdebug</code>包路径。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">cd <span class="variable">$OPENJDK_SRC_HOME</span></span><br><span class="line">bash configure --enable-<span class="builtin-name">debug</span> <span class="attribute">--with-jvm-variants</span>=server --enable-dtrace</span><br></pre></td></tr></table></figure>
<p>自定义编译参数：<br><code>--enable-debug</code>：指定fastdebug版本，<code>--with-debug-level=&lt;level&gt;</code>的简洁版本，level可以是：<code>release</code>, <code>fastdebug</code>, <code>slowdebug</code> or <code>optimized</code>。<br><code>--with-native-debug-symbols=&lt;method&gt;</code>：指定本地方法符号是否被构建。method可以是<code>none</code>, <code>internal</code>, <code>external</code>, <code>zipped</code><br><code>--with-jvm-variants=&lt;variant&gt;[,&lt;variant&gt;...]</code>：指定hotspot的模式，variant可以是<code>server</code>, <code>client</code>, <code>minimal</code>, <code>core</code>, <code>zero</code>, <code>custom</code><br><code>--with-target-bits=&lt;bits&gt;</code>：设置编译32/64位系统，可以减少交叉编译。</p>
<p>本地编译参数：<br><code>--enable-dtrace</code>：开启debug模式</p>
<p>依赖环境参数：<br><code>--with-boot-jdk=&lt;path&gt;</code>：</p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>编译可以不指定target，<code>make</code>等同于<code>make default</code>/<code>make jdk</code>。还可以只编译单个模块儿。<br>核心target主要有以下几个：</p>
<ul>
<li><code>hotspot</code> - 只编译hotspot</li>
<li><code>hotspot-&lt;variant&gt;</code> - Build just the specified jvm variant</li>
<li><code>images</code> or <code>product-images</code> - 编译JDK镜像</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">make <span class="attribute">JOBS</span>=4 jdk  # 等同于`bash configure <span class="attribute">--with-jobs</span>=4`</span><br></pre></td></tr></table></figure>
<p>可以看到编译后的目录如下：<br><img src="https://impwang.oss-cn-beijing.aliyuncs.com/java/jdk-build.png" alt="编译目录"></p>
<h1 id="hotspot在IDEA下的调试"><a href="#hotspot在IDEA下的调试" class="headerlink" title="hotspot在IDEA下的调试"></a>hotspot在IDEA下的调试</h1><h3 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">mkdir -p examples<span class="regexp">/com/</span>wang</span><br><span class="line"></span><br><span class="line">vi Test.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.wang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Test &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"Hello Hotspot"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cd examples</span><br><span class="line">javac com<span class="regexp">/wang/</span>Test.java</span><br></pre></td></tr></table></figure>
<p>配置Application<br><img src="https://impwang.oss-cn-beijing.aliyuncs.com/java/hotspot-demo.png" alt="demo"></p>
<p>配置lib库<br><img src="https://impwang.oss-cn-beijing.aliyuncs.com/java/hotspot-env.png" alt="lib"></p>
<p>开始debug<br><img src="https://impwang.oss-cn-beijing.aliyuncs.com/java/hotspot-debug.png" alt="debug"></p>
<p>运行结果<br><img src="https://impwang.oss-cn-beijing.aliyuncs.com/java/hotspot-result.png" alt="result"></p>
<p>待续…</p>
]]></content>
  </entry>
  <entry>
    <title>邮件传输协议SMTP POP3 IMAP</title>
    <url>/2021/01/09/email-protocol/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Kafka环境搭建</title>
    <url>/2020/12/21/kafka-base/</url>
    <content><![CDATA[<p>17年使用消息队列时接触到Apache Apollo，是IBM用Scala语言开发的，适用于物联网行业。kafka作为消息队列，大多使用在互联网行业，幸运的是也是用Scala语言开发的。</p>
<a id="more"></a>
<h2 id="单节点Kafka"><a href="#单节点Kafka" class="headerlink" title="单节点Kafka"></a>单节点Kafka</h2><p>Kafka是依赖于Scala语言的，所以要先安装Scala。</p>
<h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">kafka_2</span><span class="selector-class">.11-2</span><span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.tgz</span></span><br><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">-xzvf</span> <span class="selector-tag">kafka_2</span><span class="selector-class">.11-2</span><span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.tgz</span></span><br><span class="line"><span class="selector-tag">mv</span> <span class="selector-tag">kafka_2</span><span class="selector-class">.11-2</span><span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.tgz</span> <span class="selector-tag">kafka</span></span><br></pre></td></tr></table></figure>
<h3 id="启动zk"><a href="#启动zk" class="headerlink" title="启动zk"></a>启动zk</h3><h4 id="使用独立的zk"><a href="#使用独立的zk" class="headerlink" title="使用独立的zk"></a>使用独立的zk</h4><h4 id="使用kafka内嵌的zk"><a href="#使用kafka内嵌的zk" class="headerlink" title="使用kafka内嵌的zk"></a>使用kafka内嵌的zk</h4><p>启动zk<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">bin/zookeeper-server-start<span class="selector-class">.sh</span> -daemon config/zookeeper.properties</span><br><span class="line"></span><br><span class="line">nohup bin/zookeeper-server-start<span class="selector-class">.sh</span> -daemon config/zookeeper<span class="selector-class">.properties</span> &amp;</span><br></pre></td></tr></table></figure></p>
<h3 id="启动Kafka，同时注册到zk上"><a href="#启动Kafka，同时注册到zk上" class="headerlink" title="启动Kafka，同时注册到zk上"></a>启动Kafka，同时注册到zk上</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">bin/kafka-server-start<span class="selector-class">.sh</span> config/server.properties</span><br><span class="line"></span><br><span class="line">nohup bin/kafka-server-start<span class="selector-class">.sh</span> config/server<span class="selector-class">.properties</span> &amp;</span><br></pre></td></tr></table></figure>
<h3 id="创建topic-test"><a href="#创建topic-test" class="headerlink" title="创建topic(test)"></a>创建topic(test)</h3><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">bin/kafka</span><span class="literal">-</span><span class="comment">topics</span><span class="string">.</span><span class="comment">sh</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">create</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">zookeeper</span> <span class="comment">localhost:2181</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">replication</span><span class="literal">-</span><span class="comment">factor</span> <span class="comment">1</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">partitions</span> <span class="comment">1</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">topic</span> <span class="comment">test</span></span><br></pre></td></tr></table></figure>
<h3 id="查看topic"><a href="#查看topic" class="headerlink" title="查看topic"></a>查看topic</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper localhost:<span class="number">2181</span> --list</span><br><span class="line"></span><br><span class="line">bin/kafka-topics.sh --zookeeper <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">2181</span> --topic test --describe</span><br></pre></td></tr></table></figure>
<p>消费者分组<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">bin/kafka-consumer-groups.sh --bootstrap-server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9092</span> --list</span><br><span class="line"></span><br><span class="line">bin/kafka-consumer-groups.sh --bootstrap-server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9092</span> --group test_group --describe</span><br><span class="line"></span><br><span class="line"># 从头开始消费</span><br><span class="line">/usr/local/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:<span class="number">9092</span> --topic test -group test_group --<span class="keyword">from</span>-beginning</span><br></pre></td></tr></table></figure></p>
<h3 id="生产消息-可以新起一个terminal"><a href="#生产消息-可以新起一个terminal" class="headerlink" title="生产消息(可以新起一个terminal)"></a>生产消息(可以新起一个terminal)</h3><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-producer.<span class="keyword">sh</span> --broker-<span class="keyword">list</span> localhost:9092 --topic <span class="keyword">test</span></span><br></pre></td></tr></table></figure>
<h3 id="消费消息-新起一个terminal"><a href="#消费消息-新起一个terminal" class="headerlink" title="消费消息(新起一个terminal)"></a>消费消息(新起一个terminal)</h3><p>旧版本<br><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">bin/kafka</span><span class="literal">-</span><span class="comment">console</span><span class="literal">-</span><span class="comment">consumer</span><span class="string">.</span><span class="comment">sh</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">zookeeper</span> <span class="comment">localhost:2181</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">topic</span> <span class="comment">test</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">from</span><span class="literal">-</span><span class="comment">beginning</span></span><br></pre></td></tr></table></figure></p>
<p>新版本<br><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">bin/kafka</span><span class="literal">-</span><span class="comment">console</span><span class="literal">-</span><span class="comment">consumer</span><span class="string">.</span><span class="comment">sh</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bootstrap</span><span class="literal">-</span><span class="comment">server</span> <span class="comment">localhost:9092</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">topic</span> <span class="comment">test</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">from</span><span class="literal">-</span><span class="comment">beginning</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>这里可能会遇到问题，旧版本启动参数和新版本参数不一样，根据提示修改即可</p>
<h2 id="Kafka和zk的关系"><a href="#Kafka和zk的关系" class="headerlink" title="Kafka和zk的关系"></a>Kafka和zk的关系</h2><p>Kafka是一个分布式消息系统，多broker就需要一个管理中心，zk作为注册中心，所有的broker、topics都会注册到zk上，进入zk可以看一下：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">bin/zookeeper-<span class="keyword">shell</span>.<span class="keyword">sh</span> localhos<span class="variable">t:2121</span></span><br></pre></td></tr></table></figure>
<p>查看根节点：<br><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ls</span> /</span><br><span class="line"><span class="keyword">cluster</span>, controller, controller_epoch, brokers, zookeeper, admin, isr_change_notification, consumers, log_dir_event_notification, latest_producer_id_block, config]</span><br></pre></td></tr></table></figure></p>
<p>查看brokers节点：<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ls</span> <span class="string">/brokers</span></span><br><span class="line">[ids, topics, seqid]</span><br></pre></td></tr></table></figure></p>
<p>查看broker0:<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span> /brokers/ids/<span class="number">0</span></span><br><span class="line">&#123;<span class="string">"listener_security_protocol_map"</span>:&#123;<span class="string">"PLAINTEXT"</span>:<span class="string">"PLAINTEXT"</span>&#125;,<span class="string">"endpoints"</span>:[<span class="string">"PLAINTEXT://localhost:9092"</span>],<span class="string">"jmx_port"</span>:<span class="number">-1</span>,<span class="string">"host"</span>:<span class="string">"localhost"</span>,<span class="string">"timestamp"</span>:<span class="string">"1535447121995"</span>,<span class="string">"port"</span>:<span class="number">9092</span>,<span class="string">"version"</span>:<span class="number">4</span>&#125;</span><br><span class="line">cZxid = <span class="number">0x2e</span></span><br><span class="line">ctime = Tue Aug <span class="number">28</span> <span class="number">17</span>:<span class="number">05</span>:<span class="number">22</span> CST <span class="number">2018</span></span><br><span class="line">mZxid = <span class="number">0x2e</span></span><br><span class="line">mtime = Tue Aug <span class="number">28</span> <span class="number">17</span>:<span class="number">05</span>:<span class="number">22</span> CST <span class="number">2018</span></span><br><span class="line">pZxid = <span class="number">0x2e</span></span><br><span class="line">cversion = <span class="number">0</span></span><br><span class="line">dataVersion = <span class="number">0</span></span><br><span class="line">aclVersion = <span class="number">0</span></span><br><span class="line">ephemeralOwner = <span class="number">0x1657f0bf1b60003</span></span><br><span class="line">dataLength = <span class="number">188</span></span><br><span class="line">numChildren = <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>查看topics:<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ls</span> <span class="string">/brokers/topics</span></span><br><span class="line">[test, __consumer_offsets]</span><br></pre></td></tr></table></figure></p>
<p>查看主题test:<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">get /brokers/topics/test             </span><br><span class="line"><span class="section">&#123;"version":1,"partitions":&#123;"0":[0]&#125;&#125;</span></span><br><span class="line">cZxid = 0x38</span><br><span class="line">ctime = Tue Aug 28 17:06:39 CST 2018</span><br><span class="line">mZxid = 0x38</span><br><span class="line">mtime = Tue Aug 28 17:06:39 CST 2018</span><br><span class="line">pZxid = 0x3a</span><br><span class="line">cversion = 1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 36</span><br><span class="line">numChildren = 1</span><br></pre></td></tr></table></figure></p>
<h2 id="单节点安全机制"><a href="#单节点安全机制" class="headerlink" title="单节点安全机制"></a>单节点安全机制</h2><h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2>]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>第零天</title>
    <url>/2020/12/20/os-preview/</url>
    <content><![CDATA[<p>本文主要介绍环境需要的一些工具，越到后面，发现这些工具越重要，遇到问题可以很好地调试。</p>
<a id="more"></a>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="编译工具"><a href="#编译工具" class="headerlink" title="编译工具"></a>编译工具</h2><p>编译这一块儿可以看看《汇编语言》-王爽，《程序员的自我修养》</p>
<h3 id="nasm"><a href="#nasm" class="headerlink" title="nasm"></a>nasm</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install nasm</span><br></pre></td></tr></table></figure>
<h3 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h3><p>c语言编译器，该书中的代码运行在32位系统上，64位系统需要跨平台交叉编译。<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">sudo</span> apt-<span class="meta">get</span> install gcc g++ gcc-<span class="keyword">multilib </span>make</span><br></pre></td></tr></table></figure></p>
<h3 id="ld"><a href="#ld" class="headerlink" title="ld"></a>ld</h3><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ld</span> -m</span><br></pre></td></tr></table></figure>
<p>-f []: 可以指定elf、elf64、win32、win64不同平台的链接。</p>
<p><strong>注意：</strong>链接过程中，如果C代码中使用了一些动态库的函数，一定要自己重新实现，内核无法使用系统自带的动态库。例如：mysprintf.c</p>
<h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><p>虽然QEMU的monitor也支持调试，但是功能有限。</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">gdb -q</span></span><br></pre></td></tr></table></figure>
<p>尝试界面化启动<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">gdb -tui </span><br><span class="line">(<span class="name">gdb</span>) layout regs</span><br></pre></td></tr></table></figure></p>
<h2 id="Qemu"><a href="#Qemu" class="headerlink" title="Qemu"></a>Qemu</h2><p><a href="https://www.qemu.org/download/" target="_blank" rel="noopener">qemu下载地址</a></p>
<p>QEMU是一款运行模拟器，本质上类似于VMWare、VirtualBox一些软件。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">qemu-<span class="keyword">system</span>-i386</span><br></pre></td></tr></table></figure>
<h3 id="QEMU-Monitor"><a href="#QEMU-Monitor" class="headerlink" title="QEMU Monitor"></a>QEMU Monitor</h3><p>可以实现一些gdb的功能。<br><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">qemu-<span class="keyword">system</span>-i386 -monitor stdio</span><br></pre></td></tr></table></figure></p>
<p>一些常用的调试命令：<br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">info</span> block</span><br><span class="line"></span><br><span class="line">gdbserver tcp::<span class="number">12345</span> <span class="comment"># 启动监听端口，也可以直接在qemu启动时监听</span></span><br><span class="line"><span class="literal">info</span> registers</span><br><span class="line">print <span class="variable">$eax</span>           <span class="comment"># 打印寄存器信息</span></span><br><span class="line">mouse_move <span class="number">300</span> <span class="number">300</span>   <span class="comment"># 调试鼠标移动</span></span><br><span class="line">mouse_button <span class="number">1</span>       <span class="comment"># 调试键盘</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h3><p>中间因为Deepin15.11对qemu的键盘中断支持问题，切换到Ubuntu20.04</p>
<h4 id="Deepin系统"><a href="#Deepin系统" class="headerlink" title="Deepin系统"></a>Deepin系统</h4><p>apt安装<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">apt-<span class="builtin-name">get</span> install qemu</span><br></pre></td></tr></table></figure></p>
<p>编译安装</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">xz</span> <span class="string">-d</span></span><br><span class="line"><span class="attr">tar</span> <span class="string">-xvf</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">$QEMU_HOME</span></span><br><span class="line"><span class="attr">./configure</span></span><br><span class="line"><span class="attr">make</span> <span class="string">-j4</span></span><br><span class="line"><span class="attr">make</span> <span class="string">install</span></span><br></pre></td></tr></table></figure>
<h4 id="Ubuntu系统"><a href="#Ubuntu系统" class="headerlink" title="Ubuntu系统"></a>Ubuntu系统</h4><p>命令基本和Deepin系统一样</p>
<h2 id="Bochs"><a href="#Bochs" class="headerlink" title="Bochs"></a>Bochs</h2><p>这个我个人用的比较少，不是很熟悉。中间在qemu遇到问题时，用来校验过<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install bochs</span><br></pre></td></tr></table></figure></p>
<p>需要配置<code>.bochsrc</code>文件<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bochs </span>-f .<span class="keyword">bochsrc</span></span><br></pre></td></tr></table></figure></p>
<h1 id="系统镜像"><a href="#系统镜像" class="headerlink" title="系统镜像"></a>系统镜像</h1><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><h3 id="使用dd命令制作"><a href="#使用dd命令制作" class="headerlink" title="使用dd命令制作"></a>使用dd命令制作</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空镜像ipl.img</span></span><br><span class="line"><span class="selector-tag">dd</span> <span class="keyword">if</span>=/dev/zero of=ipl<span class="selector-class">.img</span> bs=<span class="number">512</span> count=<span class="number">4</span> conv=notrunc</span><br><span class="line"><span class="comment">// ipl.bin输出到ipl.img</span></span><br><span class="line"><span class="selector-tag">dd</span> <span class="keyword">if</span>=ipl<span class="selector-class">.bin</span> of=ipl<span class="selector-class">.img</span> bs=<span class="number">512</span> count=<span class="number">4</span> conv=notrunc</span><br><span class="line"><span class="comment">// 追加模式</span></span><br><span class="line"><span class="selector-tag">dd</span> <span class="keyword">if</span>=haribote<span class="selector-class">.sys</span> of=ipl<span class="selector-class">.img</span> bs=<span class="number">512</span> count=<span class="number">1</span> seek=<span class="number">1</span> conv=notrunc</span><br></pre></td></tr></table></figure>
<h3 id="使用qemu-img制作"><a href="#使用qemu-img制作" class="headerlink" title="使用qemu-img制作"></a>使用qemu-img制作</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">qemu-img create -f qcow2 -o <span class="attribute">backing_file</span>=ipl.bin</span><br></pre></td></tr></table></figure>
<h3 id="使用Makefile制作"><a href="#使用Makefile制作" class="headerlink" title="使用Makefile制作"></a>使用Makefile制作</h3><h2 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h2><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">qemu-<span class="keyword">system</span>-i386 -s -S</span><br></pre></td></tr></table></figure>
<p>-s: 启动GDB端口，默认1234。等于<code>-gdb tcp:1234</code><br>-S: 加电后CPU挂起<br>-kernel:<br>-m: </p>
<h2 id="分析镜像"><a href="#分析镜像" class="headerlink" title="分析镜像"></a>分析镜像</h2><p>objdump</p>
<p>nm</p>
<p>xxd</p>
<p>hexdump<br><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">hexdump -C ipl.bin<span class="string">|less</span></span><br></pre></td></tr></table></figure></p>
<p>gdb<br><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">gdb <span class="keyword">q</span></span><br><span class="line">(gdb) target remote localhost:<span class="number">1234</span></span><br><span class="line">(gdb) set architecture i8086</span><br><span class="line">(gdb) set disassemble-<span class="keyword">next</span>-line on</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>第十九天 + 第二十天</title>
    <url>/2020/12/19/os-19/</url>
    <content><![CDATA[<p>今天要在系统中运行第一个程序了，有点小激动。但是在编译过程中，程序始终无法正常运行hlt中断，反而会刷新系统页面。最后发现是<code>ld script</code>链接的坑，还是基础不牢啊。</p>
<a id="more"></a>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="ld-script"><a href="#ld-script" class="headerlink" title="ld script"></a>ld script</h2><p>生成map文件<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">ld -melf hlt<span class="selector-class">.o</span> -o hlt<span class="selector-class">.hrb</span> -M=hlt.map</span><br></pre></td></tr></table></figure></p>
<h2 id="nasm"><a href="#nasm" class="headerlink" title="nasm"></a>nasm</h2>]]></content>
  </entry>
  <entry>
    <title>分布式事务</title>
    <url>/2020/12/13/distribute-transaction/</url>
    <content><![CDATA[<p>从MySQL事务，到Spring事务，再到分布式事，是一个渐进的过程。不论你是在拧螺丝还是造火箭，都应该对一些热点的技术有一些了解，这些技术虽然不一定当下就用到，但是在遇到一些问题时，可以给你不一样的思路。</p>
<a id="more"></a>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p><code>MySQL InnoDB</code>存储引擎支持XA事务，JTA(Java Transaction Manager)是分布式事务的一种基于XA协议的实现方式，用来解决跨数据库的事务操作。典型的实现框架<code>jotm</code>、<code>Atomikos</code>，实现原理就是基于XA协议</p>
]]></content>
  </entry>
  <entry>
    <title>微服务--注册中心(二)</title>
    <url>/2020/12/13/sc-eureka/</url>
    <content><![CDATA[<p>著名的CAP理论，Eureka满足AP理论，ZK、Consul满足CP理论。C强一致性，A高可用性，P分区容错性。在多节点的分布式环境中，注册中心还是一个比较复杂的中间件，尤其是要考虑跨区域</p>
<a id="more"></a>
<h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p>Eureka不保证强一致性，只保证最终一致性，架构中增加了很多的缓存机制。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>服务注册快，不需要将注册信息同步到其他节点</li>
<li>不同的节点注册信息可以不一致，保证了高可用A</li>
</ol>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h4><p>eureka server集群节点之间都是peer，client向sever注册信息后，接收注册的将信息同步至peer节点。<br><strong>注意：这个同步过程是单向的，类似于主从的概念</strong></p>
<p>服务状态：<br>|状态|描述|<br>|:-|:-:|<br>|UP| 在线 |<br>|DOWN| 下线 |<br>|STARTING| 正在启动 |<br>|OUT_OF_SERVICE| 失效 |<br>|UNKNOWN| 未知 |</p>
<h5 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h5><p><code>eureka server</code>维护了3个容器类，用来存储服务信息<br>registry: 实时更新。web根据该类获取信息。<br>readWriteCacheMap: 实时更新。每隔30s同步信息到readOnlyCacheMap，每隔60s清除超过90s未续约的节点。<br>readOnlyCacheMap:周期更新。 eureka client每隔30s根据该类获取信息。</p>
<h5 id="自我保护机制"><a href="#自我保护机制" class="headerlink" title="自我保护机制"></a>自我保护机制</h5><p>15min内超过85%的服务不可用，则启动自我保护机制，</p>
<h4 id="Eureka-Client"><a href="#Eureka-Client" class="headerlink" title="Eureka Client"></a>Eureka Client</h4><p>eureka client需要注册、续约、更新状态来维持和eureka server的连接。</p>
<h5 id="缓存机制-1"><a href="#缓存机制-1" class="headerlink" title="缓存机制"></a>缓存机制</h5><p>client有2种角色：服务提供者、服务消费者。<br>作为提供者，每隔30s向server续约。<br>作为消费者，启动后立即从sever获取全量服务信息，之后每隔30s从server增量更新注册信息。同时和Ribbon的整合，Ribbon延后1s从client获取状态UP的服务信息，默认每隔30s更新。<br><code>eureka client</code>维护了3个容器类，用来存储服务信息<br>localRegionApps: 周期更新。启动后立即从sever获取全量服务信息，之后每隔30s从server增量更新注册信息。<br>upServerListZoneMap: 周期更新。Ribbon保存使用且状态为UP的服务注册信息，启动后延时1s向Client更新，默认每30s更新。</p>
<h3 id="平滑上下线-无感知"><a href="#平滑上下线-无感知" class="headerlink" title="平滑上下线/无感知"></a>平滑上下线/无感知</h3><p>由于存在多种缓存机制，在极端情况下，服务从注册到发现需要很长的时间，所以就需要做到无感知上线、下线。如果是服务非正常终止，最坏情况下需要240s发现。<br>思考的方向：<br>Eureka Server:</p>
<blockquote>
<p>减少readWriteCacheMap到readOnlyCacheMap的更新间隔时间。<br>关闭readOnlyCacheMap，使client直接从readWriteCacheMap获取服务信息。</p>
</blockquote>
<p>Eureka Client:</p>
<blockquote>
<p>减少client从server获取服务的更新周期，减少Ribbon从server获取UP服务的更新周期.<br>增加容错机制。配置Retry重试下一个节点<br>保证服务提供者尽量正常下线。</p>
</blockquote>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>为了满足强一致性C，导致以下缺点</p>
<ol>
<li>服务注册慢，必须满足半数的节点写入成功才认为注册成功</li>
<li>Leader宕机，为了强一致性，整个集群不可用，牺牲了高可用</li>
</ol>
<h2 id="Etcd"><a href="#Etcd" class="headerlink" title="Etcd"></a>Etcd</h2><h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2>]]></content>
      <tags>
        <tag>注册中心</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring的事务机制(5)</title>
    <url>/2020/12/13/spring-transaction/</url>
    <content><![CDATA[<p>事务贯穿Spring、Mybatis、MySQL的整个阶段，包括现在的分布式事务。重新巩固一下，温故而知新是永恒的哲理。</p>
<a id="more"></a>
<h2 id="Spring事务的5种隔离级别"><a href="#Spring事务的5种隔离级别" class="headerlink" title="Spring事务的5种隔离级别"></a>Spring事务的5种隔离级别</h2><p>对应于数据库的隔离级别，用来解决脏读(未提交读)、不可重复读、幻读一系列问题，常用的数据库MySQL有4种隔离级别。而Spring既可以使用数据库默认的隔离级别，也可以自定义。</p>
<ol>
<li>ISOLATION_DEFAULT: <strong>PlatfromTransactionManager默认的隔离级别</strong>，使用后端数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应。MySQL默认使用REPEATABLE_READ，Oracle默认采用READ_COMMITED</li>
<li>ISOLATION_READ_UNCOMMITTED: 这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。</li>
<li>ISOLATION_READ_COMMITTED: 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。<strong>可以防止脏读</strong></li>
<li>ISOLATION_REPEATABLE_READ: 事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。</li>
<li>ISOLATION_SERIALIZABLE: 花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。</li>
</ol>
<h2 id="Spring事务的7种传播机制"><a href="#Spring事务的7种传播机制" class="headerlink" title="Spring事务的7种传播机制"></a>Spring事务的7种传播机制</h2><p>传播机制也就是在多个事务之间调用，调用链后续事务是否处于前序的事务中，以及如果出现异常如何处理完整事务链的提交、回滚。<br>TransactionDefinition接口中定义了7种类型的事务传播机制：</p>
<ol>
<li>REQUIRED: 支持当前事务，如果当前没有事务，就新建一个事务。<strong>这是最常见的选择，也是 Spring 默认的事务的传播</strong>。</li>
<li>REQUIRES_NEW: 新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，<strong>外层事务失败回滚之后，不能回滚内层事务执行的结果</strong>，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作</li>
<li>SUPPORTS: 支持当前事务，如果当前没有事务，就以非事务方式执行。</li>
<li>MANDATORY: 支持当前事务，如果当前没有事务，就抛出异常。</li>
<li>NOT_SUPPORTED: 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>NEVER: 以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li>NESTED: 嵌套事务，如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，就新建一个事务，此时类似于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ol>
<h2 id="Spring事务原理"><a href="#Spring事务原理" class="headerlink" title="Spring事务原理"></a>Spring事务原理</h2><p>事务是基于连接(connection)的，不能跨连接进行事务管理。<br>Spring事务基于AOP实现，创建、获取connection连接，<code>TransactionSynchronizationManager</code>通过ThreadLocal将connection、sqlSession和当前事务绑定，<code>SqlSessionFactory</code>用于创建<code>SqlSession</code>会话，</p>
<ol>
<li>在调用事务方法时，首先会进入拦截器<code>TransactionInterceptor</code></li>
<li>创建事务，</li>
<li>开启事务，从数据源获取一个连接，设置’事务同步’，同时设置事务状态</li>
<li>在事务中，需要创建不同<code>SqlSessionFactory</code>bean、重写Mybatis中原有的<code>sqlSessionTemplate</code>bean</li>
<li>执行sql</li>
</ol>
<h2 id="Spring事务配置"><a href="#Spring事务配置" class="headerlink" title="Spring事务配置"></a>Spring事务配置</h2><p>TransactionDefinition类定义了事务属性，可以看到隔离级别、传播机制、超时时间、只读属性。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>ReadOnly</code>这个属性只是用来提高事务处理的性能。</p>
<h3 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h3><p>管控粒度小，可实现代码块级别的事务，需要手动编写代码执行提交、回滚。</p>
<h4 id="基于PlatformTransactionManager、TransactionDefinition-和-TransactionStatus最底层的接口实现"><a href="#基于PlatformTransactionManager、TransactionDefinition-和-TransactionStatus最底层的接口实现" class="headerlink" title="基于PlatformTransactionManager、TransactionDefinition 和 TransactionStatus最底层的接口实现"></a>基于PlatformTransactionManager、TransactionDefinition 和 TransactionStatus最底层的接口实现</h4><p>这是最底层的接口。</p>
<h4 id="基于TransactionTemplate实现"><a href="#基于TransactionTemplate实现" class="headerlink" title="基于TransactionTemplate实现"></a>基于TransactionTemplate实现</h4><p><code>TransactionTemplate</code>还是基于底层<code>PlatformTransactionManager</code>。<code>PlatformTransactionManager</code>根据不同的ORM有不同的实现类：</p>
<blockquote>
<p>DataSourceTransactionManager：适用于使用JDBC和iBatis进行数据持久化操作的情况。<br>HibernateTransactionManager：适用于使用Hibernate进行数据持久化操作的情况。<br>JpaTransactionManager：适用于使用JPA进行数据持久化操作的情况。<br>另外还有JtaTransactionManager 、JdoTransactionManager、&gt; JmsTransactionManager等等。</p>
</blockquote>
<h3 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h3><p>侵入小，事务由Spring管理，底层建立在AOP基础上，本质上还是对方法进行拦截，根据执行结果进行提交、回滚。缺点就是只能作用到方法级别，无法像编程式事务一样做到代码级别的控制。<br>即便是声明式事务也有以下几种不同的实现，前两种比较底层，</p>
<h4 id="基于TransactionInterceptor实现"><a href="#基于TransactionInterceptor实现" class="headerlink" title="基于TransactionInterceptor实现"></a>基于TransactionInterceptor实现</h4><h4 id="基于TransactionProxyFactoryBean实现"><a href="#基于TransactionProxyFactoryBean实现" class="headerlink" title="基于TransactionProxyFactoryBean实现"></a>基于TransactionProxyFactoryBean实现</h4><h4 id="基于tx和aop命名空间实现"><a href="#基于tx和aop命名空间实现" class="headerlink" title="基于tx和aop命名空间实现"></a>基于tx和aop命名空间实现</h4><p>这是Spring时代比较常用的实现方法。</p>
<h4 id="基于-Transactional注解实现"><a href="#基于-Transactional注解实现" class="headerlink" title="基于@Transactional注解实现"></a>基于@Transactional注解实现</h4><p>这是一种SpringBoot当下最常见的使用方法，但是也有一些注意事项，否则会导致事务失效。以下是Transactional注解：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public @interface Transactional &#123;</span><br><span class="line">    @AliasFor(<span class="string">"transactionManager"</span>)</span><br><span class="line">    String value()<span class="built_in"> default </span><span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    @AliasFor(<span class="string">"value"</span>)</span><br><span class="line">    String transactionManager()<span class="built_in"> default </span><span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    Propagation propagation()<span class="built_in"> default </span>Propagation.REQUIRED;</span><br><span class="line"></span><br><span class="line">    Isolation isolation()<span class="built_in"> default </span>Isolation.DEFAULT;</span><br><span class="line"></span><br><span class="line">    int timeout()<span class="built_in"> default </span>-1;</span><br><span class="line"></span><br><span class="line">    boolean readOnly()<span class="built_in"> default </span><span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Throwable&gt;[] rollbackFor()<span class="built_in"> default </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] rollbackForClassName()<span class="built_in"> default </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Throwable&gt;[] noRollbackFor()<span class="built_in"> default </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] noRollbackForClassName()<span class="built_in"> default </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h3><p>核心类<br><code>TransactionSynchronizationManager</code>用来控制事务同步器<code>TransactionSynchronization</code>，<br><code>TransactionSynchronization</code>：事务同步器，可以按序定义同步器<br><code>DataSourceUtils</code>：用来管理连接connection，<br><code>TransactionStatus</code>：用来管理事务的状态，</p>
<h3 id="监听机制"><a href="#监听机制" class="headerlink" title="监听机制"></a>监听机制</h3><h2 id="MyBatis事务"><a href="#MyBatis事务" class="headerlink" title="MyBatis事务"></a>MyBatis事务</h2><h3 id="JdbcTransaction模式"><a href="#JdbcTransaction模式" class="headerlink" title="JdbcTransaction模式"></a>JdbcTransaction模式</h3><h3 id="ManagedTraction模式"><a href="#ManagedTraction模式" class="headerlink" title="ManagedTraction模式"></a>ManagedTraction模式</h3><h2 id="多数据源"><a href="#多数据源" class="headerlink" title="多数据源"></a>多数据源</h2><p>步骤：</p>
<ol>
<li>创建多个数据源DataSource，ds1 和 ds2；</li>
<li>将ds1 和 ds2 数据源放入动态数据源DynamicDataSource；</li>
<li>将DynamicDataSource注入到SqlSessionFactory。</li>
<li>在事务中，需要创建不同的<code>SqlSessionFactory</code>bean、重写Mybatis中原有的<code>sqlSessionTemplate</code>bean</li>
</ol>
<h2 id="Spring事务失效的情况"><a href="#Spring事务失效的情况" class="headerlink" title="Spring事务失效的情况"></a>Spring事务失效的情况</h2><ol>
<li><p>MySQL数据表的引擎必须为InnoDB，MyISAM引擎不支持事务; static事务方法失效; 在controller层调用失效; catch异常不处理</p>
</li>
<li><p>调用的类必须是由Spring容器管理的代理类</p>
</li>
</ol>
<p>jdk代理<br>cglib代理</p>
<ol start="3">
<li><p>调用的方法必须是public方法，这是由Spring的AOP特性决定的。<br>Spring的AOP是通过CGlibAopProxy和JdkDynamicAopProxy动态代理实现的，在对方法进行拦截前后AbstractFallbackTransactionAttributeSource#computeTransactionAttribute会检查目标方法是否是public。<br>这样修饰符可以有两种选择：<br>private: 使用@Transactional注解编译报错<code>Methods annotated with @Transactional must be overridable</code><br>protected: 事务不生效<br>public: 必须在接口内，如果在controller内，事务不生效</p>
</li>
<li><p>抛出runtimeException异常才能回滚。</p>
</li>
</ol>
<p>默认情况下，事务抛出未检查异常、Error才回滚，如果是已检查异常则不回滚。<br>如果需要checked Exception回滚，注解需要标明@Transactional(rollbackFor=Exception.class)，或者try-catch后throw new RuntimeException</p>
<ol start="5">
<li>事务传播策略在内部方法调用时(自调用问题)<br>这是因为在AOP代理下，只有目标方法由外部调用时，目标方法才会由Spring生成的代理对象来管理。<h3 id="情景1："><a href="#情景1：" class="headerlink" title="情景1："></a>情景1：</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Person person, Book book)</span></span>&#123;</span><br><span class="line">    insert(person, book);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">insert2</span><span class="params">(Person person, Book book)</span></span>&#123;</span><br><span class="line">    insertPerson(person);</span><br><span class="line"></span><br><span class="line">    insertBook(book);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">personServiceImpl.insert(person, book)事务不起作用</span><br><span class="line"></span><br><span class="line">personServiceImpl.insert2(person, book)事务起作用</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="情景2："><a href="#情景2：" class="headerlink" title="情景2："></a>情景2：</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Override</span></span><br><span class="line"><span class="variable">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line">public void insert(Person person, Book book)&#123;</span><br><span class="line">    <span class="selector-tag">insert</span>(person, book);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">Override</span></span><br><span class="line">@<span class="selector-tag">Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">insert2</span>(Person person, Book book)&#123;</span><br><span class="line">    <span class="selector-tag">insertPerson</span>(person);</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">insertBook</span>(book);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="selector-tag">personServiceImpl</span><span class="selector-class">.insert</span>(person, book)事务起作用</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">personServiceImpl</span><span class="selector-class">.insert2</span>(person, book)事务不起作用</span><br></pre></td></tr></table></figure>
<h3 id="解决方案1："><a href="#解决方案1：" class="headerlink" title="解决方案1："></a>解决方案1：</h3><blockquote>
<p>增加&lt;aop:config proxy-target-class=”true” expose-proxy=”true”&gt;&lt;/aop:config&gt;</p>
<p>在外层调用内层的事务方法时使用AopContext代理<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="variable">@Override</span></span><br><span class="line">public void insert(Person person, Book book)&#123;</span><br><span class="line">    ((<span class="selector-tag">PersonServiceImpl</span>)<span class="selector-tag">AopContext</span><span class="selector-class">.currentProxy</span>())<span class="selector-class">.insert2</span>(person, book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="解决方案2："><a href="#解决方案2：" class="headerlink" title="解决方案2："></a>解决方案2：</h3><blockquote>
<p>在外层调用内层的事务方法时使用Spring的IOC容器代理<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Autowired</span></span><br><span class="line">private ApplicationContext ctx;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="variable">@Override</span></span><br><span class="line">public void insert(Person person, Book book)&#123;</span><br><span class="line">    <span class="selector-tag">ctx</span><span class="selector-class">.getBean</span>(PersonServiceImpl.class)<span class="selector-class">.insert2</span>(person, book);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="解决方案3："><a href="#解决方案3：" class="headerlink" title="解决方案3："></a>解决方案3：</h3><blockquote>
<p>注入自身类<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Autowired</span></span><br><span class="line">private BookService bookService;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="variable">@Override</span></span><br><span class="line">public void insert(Person person, Book book)&#123;</span><br><span class="line">    <span class="selector-tag">bookService</span><span class="selector-class">.insert2</span>(person, book);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Shenandoah论文(译)</title>
    <url>/2020/12/10/paper-shenandoah/</url>
    <content><![CDATA[<p>Shenandoah垃圾回收器在JDK15进入生产阶段。</p>
<a id="more"></a>
<p>Shenandoah是一种面向大堆的基于region、低停顿、并行、并发的垃圾回收算法。SATB并发标记和Brooks风格间接指针。<br>现代机器有更多的内存、更多的处理器。SLA应用保证响应时间在10-500ms。</p>
<h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>压缩垃圾回收算法比CMS算法有更少的内存指纹、更好的本地缓存。达到这种效果要求垃圾回收算法可以在Java运行中压缩堆。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>并发压缩是复杂的，当移动一个可能正在使用当对象时，你可能不得不原子性的更新对象的引用，简单点就需要扫描整个堆。S的解决方案是为每个对象添加一个前向指针<code>forwarding pointer</code>，所有使用这个对象都需要经过这个指针，这就使得即便应用正在运行，仍然可以移动这个对象。GC线程和增量线程使用原子性的CAS操作来更新这个指针。如果多个线程竞争移动同一个对象也只会有一个线程成功。引用的更新在下一个并发标记阶段完成。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="对象布局"><a href="#对象布局" class="headerlink" title="对象布局"></a>对象布局</h3><p>每个对象有2个header，一个指向class；另一个叫<code>mark word</code>，用来作为forwarding pointer、年龄、锁、哈希值。Shenandoah为每个对象添加了一个word，这个word只有在使用S回收器时才被分配，允许不更新引用就可以移动这个对象。移动这个对象的线程通过CAS算法原子的修改这个word使它指向新的地址。所有对这个对象的使用都通过<code>forwarding pointer</code>指向新的地址。</p>
<h3 id="堆布局"><a href="#堆布局" class="headerlink" title="堆布局"></a>堆布局</h3><p>堆被划分成相等大小的region，一个region可以包括新对象、长时间存活的对象、或者混合的对象。</p>
<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>初始标记: STW，扫描<code>GC root</code><br>并发标记:<br>最终标记: STW，重新扫描<code>GC root</code>，初始化并发压缩，释放上一次压缩后所有放空的regions<br>并发压缩: 从目标regions中抽取所有存活的对象。</p>
]]></content>
  </entry>
  <entry>
    <title>paper-g1</title>
    <url>/2020/12/10/paper-g1/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="堆布局"><a href="#堆布局" class="headerlink" title="堆布局"></a>堆布局</h3><p>G1堆被划分成大小相同的Region，每个Region都是一段连续的虚拟内存。我们主要关心的是多处理器、增量线程。增量线程只分配<code>thread-local allocation buffers</code>和<code>TLABs</code>，然后将对象分配在这些buffers中，来减少资源竞争。当前Region填满以后，会选择一个新的Region，所有都Regions组成一个链表使所有的分配时间是线性的。<br>更大的对象可能直接分配在Region，不考虑<code>TLABs</code>，超过Region大小3/4的对象称为大对象(humongous)。大对象直接分配在连续的regions中，这些regions只存储大对象。</p>
<h3 id="RSets"><a href="#RSets" class="headerlink" title="RSets"></a>RSets</h3><p>每个Region都有一个Region，用来记录一些指向该Region内存活对象的指针。当指针被修改而创建一些垮Region的指针时，就需要一些线程来通知垃圾收集器。这种通知机制使用了一种<code>card table</code>的技术：<br>通知使用了一种<code>card table</code>机制，堆中每512字节的card映射到<code>card table</code>中1字节的对象。每个线程都有一个关联的<code>remembered set log</code>、一个buffer、一些连续的修改过的cards。也就是说，有一个全局的<code>filled RS buffers</code>集合<br>RSets实际上是cards的集合，使用<code>hash tables</code>存储。由于并行机制，每个Region都有一个<code>hash tables</code>组成的数组、一个GC线程，GC线程允许这些线程更新RSets而不相互干扰。<br>RSets在指针改写后会执行<code>write barrier</code>，<br>例如：x、y分别放在寄存器<code>rX</code>和<code>rY</code>中，执行代码<code>x.f = y</code>，执行屏障的伪代码如下<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>| rTmp := rX XOR rY</span><br><span class="line"><span class="number">2</span>| rTmp := rTmp &gt;&gt; LogOfHeapRegionSize</span><br><span class="line"><span class="number">3</span>| <span class="comment">// Below is a conditional move instr</span></span><br><span class="line"><span class="number">4</span>| rTmp := (rY == NULL) then <span class="number">0</span> <span class="keyword">else</span> rTmp</span><br><span class="line"><span class="number">5</span>| <span class="keyword">if</span> (rTmp == <span class="number">0</span>) goto filtered</span><br><span class="line"><span class="number">6</span>| call rs_enqueue(rX)</span><br><span class="line"><span class="number">7</span>| filtered:</span><br></pre></td></tr></table></figure></p>
<p>屏障使用了一种filter的技术，如果写操作在同一个Region中创建了一个对象到另一个对象的指针操作，则不需要记录在RSets中。代码中如果x、y在同一个Region中，<br>行1、2异或、右移操作后rTmp为0。<br>行4对空指针进行过滤，如果执行了过滤检查，则创建一个跨Region的指针。<br><code>rs_enqueue</code>读取rX的<code>card table entry</code>。如果该entry已经脏了，则什么也不做，这就减少了对同一个card写操作的工作，典型的像初始化操作；如果该entry还没有脏，则先修改为<code>dirty card</code>，同时指向该card的指针被记录到这个线程的<code>remembered set log</code>。如果该线程的<code>log buffer</code>已经满了，则该buffer被添加到全局<code>filled RS buffers</code>集合，接着分配一个新的buffer。<code>log buffer</code>默认可以存储256个元素。<br>并发的RSet线程会先初始化<code>filled RS buffers</code>数量，默认是5个。每个buffer需要处理每个<code>card table</code>的entry，一些cards被频繁写入，为了避免重复处理过热的cards，尽量识别出最热的cards，直到下一个阶段(evacuation pause)去处理。这种机制通过一个<code>二级 card table</code>实现，这个table记录了从上一次evacuation pause到现在该card被dirty的总次数，每次处理card就加1。如果这个数值超过阈值(默认4)，则该card被添加到一个称为<code>hot queue</code>的<code>circular buffer</code>，该queue默认为1k。处理结束后queue为空，如果<code>circular buffer</code>满了，则从尾端取出一个card进行处理。<br>并发RSet线程会处理card，首先，重置entry为clean值，以便并发线程可以重新dirty、enqueue。然后，检查所有对象的指针字段</p>
<h3 id="垃圾回收阶段-evacuation-pause"><a href="#垃圾回收阶段-evacuation-pause" class="headerlink" title="垃圾回收阶段 evacuation pause"></a>垃圾回收阶段 evacuation pause</h3><p>在合适的时间点，停止所有的增量线程，执行一次垃圾回收。选中regions的CSet，复制regions内的存货对象到其它的位置，然后释放这些regions。该阶段允许压缩，所有对象的移动必须是原子性的，这在并发系统中是非常浪费的，所以把对象迁移放到STW阶段执行。<br>如果多线程程序运行在多处理器服务器上，使用单线程垃圾回收器会导致性能瓶颈。<br>首先，单线程顺序选择CSet<br>其次，并行阶段，GC线程请求执行任务，扫描<code>log buffers</code>更细RSets、扫描RSets和其它<code>root groups</code>查找存活对象、回收存活对象。<br>为了实现快速的并行回收，使用一种<code>GCLABs</code>技术，</p>
<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>新分配的对象通常更可能成为垃圾，当Region被选择作为<code>mutator allocation region</code>时，我们可以尝试指定它为young。这个Region进入下一次的CSet，这种尝试虽然有损失，但却可以获得很大的收益：<br>一个CSet可以包括<code>young regions</code>和<code>non-young regions</code>，<br>G1可以运行在2种模式下：普通模式、<code>pure garbage-first</code>模式。默认是普通模式。普通模式包括2种子模式：<code>evacuation pauses</code>可以是<code>fully young</code>和<code>partially young</code>，全量模式会把所有已分配的<code>young regions</code>添加到CSet，增量模式除了添加所有<code>young regions</code>之外，如果停顿时间允许，还会添加一部分<code>non-young regions</code>。</p>
<h3 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h3><p>使用一种SATB(snapshot-at-the-beginning)并发标记技术，标记用来识别开始就存在的垃圾对象。在标记中间分配的对象必须判断是否存活。但是已经被标记的对象不需要再重新标记、跟踪。这种方法大大的较少了标记耗时。</p>
<h4 id="标记数据结构"><a href="#标记数据结构" class="headerlink" title="标记数据结构"></a>标记数据结构</h4><p>G1维护了2种类型的<code>marking bitmaps</code>，<br>previous: 已经标记完成的bitmap<br>next: 可能正在构建的bitmap<br>这2种bitmap在标记完成后交换角色，每个bitmap都包含1个bit，默认都是8字节对齐，意味着1个bitmap bit需要64bit。</p>
<h4 id="初始标记-并发标记"><a href="#初始标记-并发标记" class="headerlink" title="初始标记/并发标记"></a>初始标记/并发标记</h4><p>首先，清空<code>next bitmap</code>，<br>其次，初始化标记会停止所有的增量线程，同时标记所有可到达的对象。每个Region包括2个TAMS(top at mark start)变量，分别为previous、next使用，这些变量用来识别在标记期间分配的对象。<br>初始化阶段会遍历所有的regions，复制region的top属性值到<code>next TAMS</code></p>
<h4 id="并发标记写屏障"><a href="#并发标记写屏障" class="headerlink" title="并发标记写屏障"></a>并发标记写屏障</h4><p>例如：<br><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>| rTmp := <span class="keyword">load</span>(rThread + MarkingInProgressOffset)</span><br><span class="line"><span class="number">2</span>| <span class="keyword">if</span> (!rTmp) <span class="keyword">goto</span> filtered</span><br><span class="line"><span class="number">3</span>| rTmp := <span class="keyword">load</span>(rX + FieldOffset)</span><br><span class="line"><span class="number">4</span>| <span class="keyword">if</span> (rTmp == <span class="built_in">null</span>) <span class="keyword">goto</span> filtered</span><br><span class="line"><span class="number">5</span>| <span class="keyword">call</span> <span class="built_in">satb_enqueue</span>(rTmp)</span><br><span class="line"><span class="number">6</span>| filtered:</span><br></pre></td></tr></table></figure></p>
<p>行1、行2: 如果不执行标记，则跳过以下代码。对于很多程序来说，这个会过滤掉很多动态屏障<br>行3、行4: 加载对象属性的值，检查是否为null，只需要记录非空的值。<br>行5: 添加指针到线程的<code>marking buffer</code>，如果buffer被填满，则添加到全局的<code>marking buffers</code>集合中，</p>
<h4 id="最终标记"><a href="#最终标记" class="headerlink" title="最终标记"></a>最终标记</h4><h4 id="统计存活对象并清理"><a href="#统计存活对象并清理" class="headerlink" title="统计存活对象并清理"></a>统计存活对象并清理</h4>]]></content>
  </entry>
  <entry>
    <title>devops-publish</title>
    <url>/2020/12/09/devops-publish/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>jvm垃圾回收</title>
    <url>/2020/12/09/java-jvm-gc/</url>
    <content><![CDATA[<p>垃圾回收器应该是架构师必备的核心技能，从回收算法、回收器、GC Roots、安全点/安全区域、分配策略、回收策略，整个过程都需要清晰。最后通过配置参数进行调优。<br>这是一篇持续更新的博客，随着认知的变化、GC的更新不断更新</p>
<a id="more"></a>
<h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><h3 id="1-标记-清除算法-Mark-Sweep"><a href="#1-标记-清除算法-Mark-Sweep" class="headerlink" title="1. 标记-清除算法(Mark-Sweep):"></a>1. 标记-清除算法(Mark-Sweep):</h3><p>缺点：</p>
<blockquote>
<p>效率不高</p>
<p>产生大量不连续的内存碎片</p>
</blockquote>
<h3 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2. 复制算法"></a>2. 复制算法</h3><p>优点：</p>
<blockquote>
<p>实现简单，运行高效</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>内存浪费</p>
</blockquote>
<p>商业用例：<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Eden:Survivor = <span class="number">8</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-标记-整理算法-标记-压缩算法"><a href="#3-标记-整理算法-标记-压缩算法" class="headerlink" title="3. 标记-整理算法/标记-压缩算法"></a>3. 标记-整理算法/标记-压缩算法</h3><h3 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4. 分代收集算法"></a>4. 分代收集算法</h3><blockquote>
<p>新生代：复制算法<br>老年代：标记-清除/标记-整理</p>
</blockquote>
<h2 id="安全点-安全区域"><a href="#安全点-安全区域" class="headerlink" title="安全点/安全区域"></a>安全点/安全区域</h2><p>1.枚举根节点</p>
<p>2.安全点</p>
<p>3.安全区域</p>
<h2 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h2><p>年轻代：复制算法<br>老年代：</p>
<ol>
<li>标记-清除</li>
<li>标记-整理<br>分代算法：年轻代使用复制算法，老年代使用标记清除/标记整理</li>
</ol>
<h2 id="回收器"><a href="#回收器" class="headerlink" title="回收器"></a>回收器</h2><h3 id="年轻代收集器"><a href="#年轻代收集器" class="headerlink" title="年轻代收集器"></a>年轻代收集器</h3><table>
<thead>
<tr>
<th style="text-align:left">收集器</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">算法</th>
<th style="text-align:center">过程</th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
<th style="text-align:center">参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Serial</td>
<td style="text-align:center">单线程，使用一个CPU/一个线程完成垃圾收集工作，收集过程必须STW，直到收集结束</td>
<td style="text-align:center">复制算法</td>
<td style="text-align:center">-</td>
<td style="text-align:center">简单高效</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">ParNew</td>
<td style="text-align:center">多线程，基于Serial的多线程版本，默认GC线程数等于CPU数量。除了Serial，只有ParNew可以和老年代的CMS收集器搭配</td>
<td style="text-align:center">复制算法</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">在单CPU下性能不如Serial</td>
<td style="text-align:center">ParallelGCThreads:GC线程数</td>
</tr>
<tr>
<td style="text-align:left">Parallel Scavenge</td>
<td style="text-align:center">并行，多线程，目标是达到可控制的吞吐量</td>
<td style="text-align:center">复制算法</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">MaxGCPauseMillis:GC停顿时间;GCTimeRatio:GC停顿时间比例;UseAdaptiveSizePolicy:自适应调整参数</td>
</tr>
</tbody>
</table>
<h3 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h3><table>
<thead>
<tr>
<th style="text-align:left">收集器</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">算法</th>
<th style="text-align:center">过程</th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
<th style="text-align:center">参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Serial Old</td>
<td style="text-align:center">单线程</td>
<td style="text-align:center">标记-整理</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">Parallel Old</td>
<td style="text-align:center">多线程</td>
<td style="text-align:center">标记-整理</td>
<td style="text-align:center">-</td>
<td style="text-align:center">在吞吐量、CPU资源敏感的场景，优先考虑Parallel Scavenge + Parallel Old</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">CMS</td>
<td style="text-align:center">并发，最短停顿时间</td>
<td style="text-align:center">标记-清除</td>
<td style="text-align:center">初始标记(STW)；并发标记；重新标记(STW)；并发清除</td>
<td style="text-align:center">-</td>
<td style="text-align:center">并发对CPU资源敏感；无法处理浮动垃圾导致并发模式失败；空间碎片导致无法分配大对象</td>
<td style="text-align:center">CMSInitiatingOccupancyFraction:设置老年代占用率达到该阈值后，执行一次FullGC;+UseCMSCompactAtFullCollection:空间不足执行FullGC时同时执行碎片整理;CMSFullGCsBeforeCompaction:执行多少次不压缩的FullGC后执行一次碎片整理;</td>
</tr>
</tbody>
</table>
<p>CMS、G1垃圾回收都采用<strong>三色标记法</strong>，但是具体实现不同：<br>思想：将对象标记为黑、灰、白三种颜色</p>
<blockquote>
<p>从<code>GC Root</code>对象向下查找，根据三色标记法标记出所有连接的对象<br>第一次并发标记后，会产生浮动垃圾，即灰色对象，这时候进行一次STW的短暂停顿对灰色对象进行扫描标记<br>GC线程扫描所有内存，找出被标记为白色的对象。</p>
</blockquote>
<p><strong>规则</strong><br>黑色：该对象已经被标记过了，且该对象下的属性也全部都被标记过了。(存活对象)<br>灰色：该对象已经被标记过了，但该对象下的属性没有全被标记完。(存活对象下存在垃圾)<br>白色：该对象没有被标记过。(垃圾对象)</p>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>(并发低停顿收集器), 基于标记-清除算法<br>目标：主要针对老年代，以获取最短回收停顿时间</p>
<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><blockquote>
<p>初始标记：stop-the-world，仅仅标记GC Roots能关联到的对象<br>并发标记：进行GC Roots Tracing的过程<br>重新标记：stop-the-world，修正并发标记期间程序运行变化的对象<br>并发清除：用户程序同时运行</p>
</blockquote>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li><p>对CPU资源非常敏感：</p>
<blockquote>
<p>并发处理对CPU要求就比较高，占用一部分线程，会导致吞吐量降低。<br><strong>默认</strong>垃圾回收线程数量(NUM(cpu) + 3)/4；<br>CPU不足4个时，对应用的影响就会比较大</p>
</blockquote>
</li>
<li>无法处理浮动垃圾：concurrent mode failure(并发模式失败)<blockquote>
<p>浮动垃圾：并发清理和用户程序同时运行，这样在清理期间就会产生对象垃圾，这部分垃圾需要留到下一次GC去处理，就会产生浮动垃圾。<br>由于用户程序需要同时运行，所以老年代需要为用户程序预留一部分空间，预留空间无法满足用户程序，就会导致<code>Concurrent Mode Failure</code>，接着产生Full GC<br>jdk1.5增加参数<code>-XX:CMSInitiatingOccupancyFraction</code>，老年代使用超过该阈值，触发CMS垃圾回收，如果老年代不是增长太快，可以适当调高该值<br>jdk1.6<br>参数<code>-XX:ConGCThreads=N</code>，可以设置垃圾收集线程数量</p>
</blockquote>
</li>
<li>产生大量空间碎片：promoration failure(晋升失败)<blockquote>
<p>标记-清除算法会导致空间碎片，碎片过多在大对象分配的时候，虽然有足够的时间，无法找到连续空间，不得不触发一次Full GC<br>参数<code>-XX:+UseCMSCompactAtFullCollection</code>，默认开启，在执行Full GC的时候，开启内存碎片的整理<br>参数<code>-XX:CMSFullGCsBeforeCompaction</code>，默认值为0，用于控制执行多少次不压缩的Full GC后执行一次带压缩的Full GC。</p>
</blockquote>
</li>
</ol>
<h4 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h4><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">详解</th>
</tr>
</thead>
<tbody>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td style="text-align:center">激活CMS收集器</td>
</tr>
<tr>
<td>-XX:ConcGCThreads</td>
<td style="text-align:center">设置CMS线程的数量</td>
</tr>
<tr>
<td>-XX:+UseCMSInitiatingOccupancyOnly</td>
<td style="text-align:center">只根据老年代使用比例来决定是否进行CMS</td>
</tr>
<tr>
<td>-XX:CMSInitiatingOccupancyFraction</td>
<td style="text-align:center">设置触发CMS老年代回收的内存使用率占比</td>
</tr>
<tr>
<td>-XX:+CMSParallelRemarkEnabled</td>
<td style="text-align:center">并行运行最终标记阶段，加快最终标记的速度</td>
</tr>
<tr>
<td>-XX:+UseCMSCompactAtFullCollection</td>
<td style="text-align:center">每次触发CMS Full GC的时候都整理一次碎片</td>
</tr>
<tr>
<td>-XX:CMSFullGCsBeforeCompaction</td>
<td style="text-align:center">经过几次CMS Full GC的时候整理一次碎片</td>
</tr>
<tr>
<td>-XX:+CMSClassUnloadingEnabled</td>
<td style="text-align:center">让CMS可以收集永久带，默认不会收集</td>
</tr>
<tr>
<td>-XX:+CMSScavengeBeforeRemark</td>
<td style="text-align:center">最终标记之前强制进行一个Minor GC</td>
</tr>
<tr>
<td>-XX:+ExplicitGCInvokesConcurrent</td>
<td style="text-align:center">当调用System.gc()的时候，执行并行gc，只有在CMS或者G1下该参数才</td>
</tr>
</tbody>
</table>
<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>目标：</p>
<h4 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h4><p>概念：<br>优先列表</p>
<h5 id="Region："><a href="#Region：" class="headerlink" title="Region："></a>Region：</h5><blockquote>
<p>默认堆内存分为1024个region分区。每个region大小相等<br>region分为：Eden Survivor Old Humongous(巨型对象)，垃圾收集时，一个对象可以跨region<br>参数<code>-XX:G1HeapRegionSize</code>可以设置region大小，最小1Mb，最大32Mb</p>
</blockquote>
<h5 id="CSet-Collection-Set"><a href="#CSet-Collection-Set" class="headerlink" title="CSet(Collection Set)"></a>CSet(Collection Set)</h5><p>一组可被回收的Region分区的集合。</p>
<h5 id="RSet-Remembered-Set-："><a href="#RSet-Remembered-Set-：" class="headerlink" title="RSet(Remembered Set)："></a>RSet(Remembered Set)：</h5><p>每个Region都有一个RSet，RSet其实是Card的集合，这个RSet用来记录其它Region引用自身Region内部对象的信息，对象可以跨代引用，<code>old-&gt;young</code>或者<code>young-&gt;old</code>，这样垃圾回收时只需要扫描RSet</p>
<h5 id="CarTable"><a href="#CarTable" class="headerlink" title="CarTable"></a>CarTable</h5><blockquote>
<p>CardTable是一种特殊类型的RSet，JVM使用一个字节数组作为CardTable，每一个字节都指向一个Card(512字节)，<br>老年代分为多个Card，如果Card中有指向年轻代的对象，则标记为<code>Dirty Card</code>，执行<code>Young GC</code>只需要扫描<code>Dirty Card</code>即可<br>底层使用<code>Bit Map</code>结构存储</p>
</blockquote>
<h5 id="SATB-Snapchat-At-The-Beginning-："><a href="#SATB-Snapchat-At-The-Beginning-：" class="headerlink" title="SATB(Snapchat-At-The-Beginning)："></a>SATB(Snapchat-At-The-Beginning)：</h5><blockquote>
<p>并发GC时用户程序同时运行，可能会生成新对象，所以在GC前，会先执行SATB，生成快照记录存活的对象<br>每个Region记录两个TAMS(top-at-mark-start)指针，GC过程中生成的新对象，在TAMS上的对象就是新分配的对象<br>Write Barrier</p>
</blockquote>
<h4 id="垃圾回收-1"><a href="#垃圾回收-1" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><h5 id="全局并发标记阶段"><a href="#全局并发标记阶段" class="headerlink" title="全局并发标记阶段"></a>全局并发标记阶段</h5><blockquote>
<p>初始标记：stop-the-world，仅仅标记GC Roots能关联到的对象<br>并发标记：<br>最终标记：stop-the-world，会处理在并发标记阶段write barrier记录下来的对象；与CMS最大的差别就是，CMS会扫描整个GC Roots，包括Eden区<br>筛选回收：stop-the-world，这一阶段并不会收集垃圾，而是根据停顿预测模型预测出CSet，等待下一个Evacuation阶段回收</p>
</blockquote>
<h5 id="拷贝存活对象阶段-Evacuation"><a href="#拷贝存活对象阶段-Evacuation" class="headerlink" title="拷贝存活对象阶段 Evacuation"></a>拷贝存活对象阶段 Evacuation</h5><blockquote>
<p>stop-the-world，将一部分region中的存活对象拷贝到另一部分region，只剩下垃圾对象的region被记录在CSet，<br>evacuation failure：堆空间垃圾太多，导致无法完成region之间的拷贝，导致执行一次Full GC。类似于CMS的<code>promoration failure</code>。</p>
</blockquote>
<h5 id="收集模式"><a href="#收集模式" class="headerlink" title="收集模式"></a>收集模式</h5><p>Young GC：<br>Mix GC：</p>
<h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>并行与并发</li>
<li>分代收集</li>
<li><p>空间整合：</p>
<blockquote>
<p>与CMS的标记-清除算法不同，G1整体看是标记-整理算法，局部(Region)看则是复制算法，不会产生内存碎片。</p>
</blockquote>
</li>
<li><p>可预测的停顿：</p>
<blockquote>
<p>这是G1相比CMS的一大优势，降低停顿时间时G1和CMS共同的关注点，但G1除了追求低停顿，还能建立可预测的停顿时间模型<br>参数<code>-XX:MaxGCPauseMillis</code>，可以设置停顿时间</p>
</blockquote>
</li>
</ol>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><ol>
<li>不断调优停顿时间</li>
<li>不设置新生代/老年代大小，由JVM自动调整，设置大小后会导致停顿时间设置失效</li>
<li>关注Evacuation Failure问题</li>
</ol>
<h4 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h4><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">详解</th>
</tr>
</thead>
<tbody>
<tr>
<td>-XX:+UseG1GC</td>
<td style="text-align:center">使用 G1 垃圾收集器</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis=200</td>
<td style="text-align:center">设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）</td>
</tr>
<tr>
<td>-XX:InitiatingHeapOccupancyPercent=45</td>
<td style="text-align:center">启动并发GC周期时的堆内存占用百分比. G1之类的垃圾收集器用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比. 值为 0 则表示”一直执行GC循环”. 默认值为 45</td>
</tr>
<tr>
<td>-XX:NewRatio=n</td>
<td style="text-align:center">新生代与老生代(new/old generation)的大小比例(Ratio). 默认值为 2</td>
</tr>
<tr>
<td>-XX:SurvivorRatio=n</td>
<td style="text-align:center">eden/survivor 空间大小的比例(Ratio). 默认值为 8.</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold=n</td>
<td style="text-align:center">提升年老代的最大临界值(tenuring threshold). 默认值15</td>
</tr>
<tr>
<td>-XX:ParallelGCThreads=n</td>
<td style="text-align:center">设置垃圾收集器在并行阶段使用的线程数,默认值随JVM运行的平台不同而不同.</td>
</tr>
<tr>
<td>-XX:ConcGCThreads=n</td>
<td style="text-align:center">并发垃圾收集器使用的线程数量. 默认值随JVM运行的平台不同而不同.</td>
</tr>
<tr>
<td>-XX:G1ReservePercent=n</td>
<td style="text-align:center">设置堆内存保留为假天花板的总量,以降低提升失败的可能性. 默认值是 10.</td>
</tr>
<tr>
<td>-XX:G1HeapRegionSize=n</td>
<td style="text-align:center">使用G1时Java堆会被分为大小统一的的区(region)。此参数可以指定每个heap区的大小. 默认值将根据 heap size 算出最优解. 最小值为 1Mb, 最大值为 32Mb.</td>
</tr>
</tbody>
</table>
<h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><blockquote>
<p>GC停顿时间不超过10ms<br>处理堆从MB到TB<br>相比G1减少了15%的吞吐量</p>
</blockquote>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><h3 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h3><p>目标：低停顿时间</p>
<h3 id="混合收集器"><a href="#混合收集器" class="headerlink" title="混合收集器"></a>混合收集器</h3><table>
<thead>
<tr>
<th style="text-align:left">收集器</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">算法</th>
<th style="text-align:center">过程</th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
<th style="text-align:center">参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">+UseG1GC</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">+UseZGC</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h3 id="回收器组合"><a href="#回收器组合" class="headerlink" title="回收器组合"></a>回收器组合</h3><table>
<thead>
<tr>
<th style="text-align:left">收集器组合</th>
<th style="text-align:center">收集器</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">+UseSerialGC</td>
<td style="text-align:center">Serial + Serial Old</td>
<td style="text-align:center">jdk运行在client模式下默认组合</td>
</tr>
<tr>
<td style="text-align:left">+UseParNewGC</td>
<td style="text-align:center">ParNew + Serial Old</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">+UseConcMarkSweepGC</td>
<td style="text-align:center">ParNew + CMS/Serial Old</td>
<td style="text-align:center">老年代在并发模式失败后开启Serial Old</td>
</tr>
<tr>
<td style="text-align:left">+UseParrallelGC</td>
<td style="text-align:center">Parallel Scavenge + Serial Old(PS MarkSweep)</td>
<td style="text-align:center">jdk运行在server模式下默认开启</td>
</tr>
<tr>
<td style="text-align:left">+UseParallelGC</td>
<td style="text-align:center">Parallel Scavenge + Parallel Old</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">+UseG1GC</td>
<td style="text-align:center">G1</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h2 id="内存分配、回收策略"><a href="#内存分配、回收策略" class="headerlink" title="内存分配、回收策略"></a>内存分配、回收策略</h2><p>Minor GC: 指发生在新生代的垃圾回收动作</p>
<p>Full GC/Major GC: 指发生在老年代的GC，出现Full GC，经常会伴随至少一次Minor GC;</p>
<p><strong>如果更细粒度，Major GC可以认为只对老年的GC，而Full GC是对整个堆来说的。</strong></p>
<blockquote>
<p>1、对象优先在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC<br>2、大对象直接进入老年代。大对象典型的就是那些很长的字符串、数组 参数-XX:PretenureSizeThreshold可以设定大对象的标准<br>3、长期存活的对象将进入老年代(默认是15岁)<br>Eden区对象经过Minor GC后，年龄增1，然后在Survivor每经历一次Minor GC，年龄增长1，达到指定年龄，进入老年代<br>参数-XX:MaxTenuringThreshold<br>4、动态年龄判定<br>如果在Survivor区，相同年龄的所有对象大小总和大于Survivor空间的一半，年龄大于等于该年龄的对象可以直接进入老年代。【可以破坏规则3】<br>5、空间分配担保</p>
</blockquote>
<h3 id="GC触发"><a href="#GC触发" class="headerlink" title="GC触发"></a>GC触发</h3><p>Minor GC触发条件：</p>
<blockquote>
<p>Eden区没有足够空间分配时，触发</p>
</blockquote>
<p>Full GC触发条件：</p>
<blockquote>
<ol>
<li>显式调用System.gc()。可以通过-XX:+ DisableExplicitGC禁止显式调用</li>
<li>方法区(永生代)空间不足。方法区在HotSpot中又被称为永生代/永生区。如果被占满，在未配置为CMS GC的情况下，会执行一次Full GC，如果空间还是不足，则抛出异常java.lang.OutOfMemoryError: PermGen space </li>
<li>老年代空间不足。出现的原因：新生代对象转入；分配大对象、大数组。如果Full GC后空间仍然不够，则抛出java.lang.OutOfMemoryError: Java heap space </li>
<li>Eden区对象执行Minor GC后，进入老年代的所有对象和大于老年代可用内存时，触发Full GC</li>
<li>(promotion failed)Eden + From执行Minor GC时，如果存活对象大于To内存区，则直接进入老年代，如果老年代的可用内存小于该对象，则触发Full G</li>
<li>(concurrent mode failure)执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足，则执行一次Full GC </li>
</ol>
</blockquote>
<p><strong>注意:</strong>jdk1.6_24之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会执行Minor GC，否则进行Full GC</p>
<h2 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h2><h3 id="内存参数"><a href="#内存参数" class="headerlink" title="内存参数"></a>内存参数</h3><p>-Xms：初始堆。默认为物理内存的1/64。<br>-Xmx：最大堆。默认为物理内存的1/4。<br>-Xmn：新生代/年轻代大小。增大年轻代后，老年代会减小，官方建议为整个堆的3/8.<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">年轻代大小 = eden + survivor</span><br><span class="line">整个堆大小 = 年轻代大小 + 老年代大小 + 永久代大小(<span class="number">1.8</span>之后弃用)</span><br></pre></td></tr></table></figure></p>
<p>-XX:NewRatio: 年轻代与老年代的比值。<br>-XX:SurvivorRatio: Eden区与Survicor区的比值。<br>-XX:PermSize：永久代初始大小。默认为物理内存的1/64。<br>-XX:MaxPermSize：永久代最大值。默认为物理内存的1/4。</p>
<h3 id="编译参数"><a href="#编译参数" class="headerlink" title="编译参数"></a>编译参数</h3><p>-XX:LargePageSizeInBytes: 内存页的大小，默认为，可能会影响Perm。<br>-XX:+UseFastAccessorMethods：<br>-XX:+UseBiasedLocking<br>-XX:PretenureSizeThreshold<br>-XX:TLABWasteTargetPercent：TLAB占Eden区的百分比，默认1%。<br>-XX:SoftRefLRUPolicyMSPerMB<br>-XX:+UseCompressedClassPointers<br>-XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation</p>
<p>-XX:G1ConcRefinementThreads=4 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=130694848<br>-XX:MaxHeapSize=2091117568<br>-XX:MinHeapSize=6815736<br>-XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240<br>-XX:+SegmentedCodeCache </p>
<h3 id="日志参数"><a href="#日志参数" class="headerlink" title="日志参数"></a>日志参数</h3><p>-XX:+PrintHeapAtGC：打印GC前后的堆栈信息<br>-XX:+PrintTLAB： 查看TLAB空间的使用情况<br>-Xloggc 日志文件存放位置<br>-XX:+PrintGCDateStamps 打印每个年代对象分布情况<br>-XX:+PrintGCDateStamps / -XX:+PrintGCTimeStamps<br>-XX:+PrintGCApplicationStoppedTime：<br>-XX:+PrintGCApplicationConcurrentTime：打印除了GC之外引起JVM STW的时间<br>-XX:+PrintSafepointStatistics：<br>-XX:PrintSafepointStatisticsCount=1：</p>
<h2 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h2><p>GC性能调优大致有两个指标：</p>
<ol>
<li>吞吐量：工作线程运行时间/总的运行时间</li>
<li>停顿时间：STW时间</li>
</ol>
<h3 id="调优方向"><a href="#调优方向" class="headerlink" title="调优方向"></a>调优方向</h3><ol>
<li><p>Heap大小<br>Xms、Xmx设置为相同值，避免申请内存带来的压力。</p>
</li>
<li><p>年轻代大小<br>年轻代太小，就会导致频繁的Minor GC；太大则占用老年代空间，导致频繁的Full GC；<br>响应时间优先：<br>吞吐量优先：</p>
</li>
<li><p>老年代大小<br>响应时间优先：<br>吞吐量优先：</p>
</li>
<li><p>CMS收集器<br>使用CMS的好处是用尽量少的年轻代，经验值是128M－256M， 然后老年代可以大一些，由于老年代并发收集， 这样能保证系统低延迟的吞吐效率。<br>实际上cms的收集停顿时间非常的短，2G的内存， 大约20－80ms的应用程序停顿时间。<br>并发模式失败：GC线程在并发标记/并发清理阶段，用户工作线程仍然并发运行，导致浮动垃圾，如果老年代剩余空间不足，则会导致’并发模式失败’。<br>晋升失败：<code>Eden + From Survivor</code>区对象经过Minor GC进入<code>To Survivor</code>，To Survivor空间不足，再次进入<code>Old gen</code>老年代，老年代空间也不足，则会执行<code>Full GC</code>，同时抛出晋升失败<code>Promotion faild</code>。关于晋升失败，前辈大概总结出来一个公式：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">CMSInitiatingOccupancyFraction &lt;= ((<span class="name">Xmx-Xmn</span>)-(<span class="name">Xmn-Xmn/</span>(<span class="name">SurvivorRatior+2</span>)))/(<span class="name">Xmx-Xmn</span>)*100</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk版本特性概览(一)</title>
    <url>/2020/12/09/a-overview-jdk/</url>
    <content><![CDATA[<p>不知不觉OpenJDK16快要发布了，大多还停留在jdk6/7/8上，jdk的快速迭代，让人非常兴奋。JDK发布版本分为过渡版本和长时间支持版本(LTS)，一般在生产中采用LTS版本可以满足长期维护。下面大致罗列一下jdk的新特性。</p>
<a id="more"></a>
<p>来给jdk15比个yeah!</p>
<h2 id="JDK15"><a href="#JDK15" class="headerlink" title="JDK15"></a>JDK15</h2><h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><blockquote>
<p>339:    Edwards-Curve数字签名算法 (EdDSA)<br>360:    密封类 (预览)<br>371:    隐藏类<br>372:    移除了Nashorn JS引擎<br>373:    重新实现了DatagramSocket API<br>374:    禁用并弃用了偏向锁<br>375:    Pattern Matching for instanceof (二次预览)<br>377:    ZGC: 可扩展的低延迟的垃圾收集器 (生产阶段)<br>378:    文本块<br>379:    Shenandoah: 低停顿时间垃圾收集器 (从实验阶段进入生产阶段)<br>381:    移除了对Solaris和SPARC的支持<br>383:    Foreign-Memory Access API (Second Incubator)<br>384:    Records (二次预览)<br>385:    Deprecate RMI Activation for Removal</p>
</blockquote>
<h2 id="JDK1-8-LTS"><a href="#JDK1-8-LTS" class="headerlink" title="JDK1.8 LTS"></a>JDK1.8 LTS</h2><p><a href="https://jdk.java.net/java-se-ri/8" target="_blank" rel="noopener">OpenJDK1.8下载</a><br><!--[OracleJDK8文档]()
--></p>
<p>特性表详细的list没有找到，自己手动整理了一下</p>
<h3 id="Lambda表达式和Functional接口"><a href="#Lambda表达式和Functional接口" class="headerlink" title="Lambda表达式和Functional接口"></a>Lambda表达式和Functional接口</h3><ol>
<li>接口的默认与静态方法</li>
<li>方法引用：<br> 对象::实例方法名<br> 类::静态方法名<br> 类::实例方法名<br> 构造器引用 类::new<br> 数组引用<code>Type[]::new</code></li>
<li>重复注解</li>
<li>更好的类型推测机制</li>
<li>扩展注解： ElementType.TYPE_USE、 ElementType.TYPE_PARAMETER；可以为任何代码添加注解(接口、异常)</li>
</ol>
<h3 id="编译器新特性"><a href="#编译器新特性" class="headerlink" title="编译器新特性"></a>编译器新特性</h3><p>通过<code>-parameters</code>参数可以将方法参数名添加到字节码</p>
<h3 id="类库的新特性"><a href="#类库的新特性" class="headerlink" title="类库的新特性"></a>类库的新特性</h3><ol>
<li><p>Optional：解决空指针异常<br> Consumer<t><br> Supplier<t><br> Function&lt;T, R&gt;<br> Predicate<t><br> Comparator<t></t></t></t></t></p>
</li>
<li><p>Stream：<br> filter过滤<br> sort排序<br> map映射<br> match匹配<br> reduce规约</p>
</li>
<li><p>Date/Time API<br> Instant<br> Clock时钟<br> Timezones时区<br> LocalTime/LocalDate/LocalDateTime本地时间</p>
<p> <strong>注意：</strong>和java.text.SimpleDateFormat不同的是，DateTimeFormatter是不可变的，所以它是线程安全的。</p>
</li>
<li><p>Base64：Base64编码成为类库标准</p>
</li>
<li><p>并行：parallelSort()、</p>
</li>
<li><p>并发：java.util.concurrent包</p>
<blockquote>
<p>ConcurrentHashMap增加新方法支持聚集<br>ForkJoinPool增加新方法支持共有资源池<br>locks.StampedLock，用来替换locks.ReadWriteLock<br>atomic包下增加DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder</p>
</blockquote>
</li>
<li><p>集合<br> HashMap：链表 + 红黑树<br> ConcurrentHashMap：采用了CAS算法</p>
</li>
</ol>
<h3 id="Java工具"><a href="#Java工具" class="headerlink" title="Java工具"></a>Java工具</h3><ol>
<li>Norshorn引擎 jjs</li>
<li>类依赖分析器 jdeps：可以用来分析’.class’、目录、jar</li>
</ol>
<h3 id="JVM新特性"><a href="#JVM新特性" class="headerlink" title="JVM新特性"></a>JVM新特性</h3><ol>
<li>PermGen空间被Metaspace取代<br> -XX:PermSize      -XX:MetaSpaceSize<br> -XX:MaxPermSize   -XX:MaxMetaspaceSize</li>
</ol>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><h3 id="IO-NIO改进"><a href="#IO-NIO改进" class="headerlink" title="IO/NIO改进"></a>IO/NIO改进</h3><ol>
<li>改进java.nio.charset.Charset的实现，精简了 jre/lib/charsets.jar 包；优化了 String(byte[],*) 构造方法和 String.getBytes() 方法的性能</li>
<li>新增API<br> BufferedReader.line(): 返回文本行的流 Stream<string><br> File.lines(Path, Charset):返回文本行的流 Stream<string><br> File.list(Path): 遍历当前目录下的文件和目录<br> File.walk(Path, int, FileVisitOption): 遍历某一个目录下的所有文件和指定深度的子目录<br> File.find(Path, int, BiPredicate, FileVisitOption… ): 查找相应的文件</string></string></li>
</ol>
<h2 id="JDK9"><a href="#JDK9" class="headerlink" title="JDK9"></a>JDK9</h2><p><a href="https://openjdk.java.net/projects/jdk9/" target="_blank" rel="noopener">OpenJDK9</a></p>
<p>“Java SE 9 has reached end of support. Users of Java SE 9 should switch to Java SE 10.”<br><strong>注意：</strong>官网明确表明，jdk9已经不被支持，用户可以切到jdk10</p>
<h3 id="新特性-1"><a href="#新特性-1" class="headerlink" title="新特性"></a>新特性</h3><blockquote>
<p>102: Process API Updates<br>110: HTTP 2 Client: HTTP/2 用于替换’HttpURLConnection’<br>143: Improve Contended Locking: 锁争用机制<br>158: Unified JVM Logging<br>165: Compiler Control: 编译控制<br>193: Variable Handles: 操作变量<br>197: Segmented Code Cache: 代码分段缓存<br>199: Smart Java Compilation, Phase Two: 更智能的Java编译器<br>200: The Modular JDK<br>201: Modular Source Code<br>211: Elide Deprecation Warnings on Import Statements<br>212: Resolve Lint and Doclint Warnings<br>213: Milling Project Coin<br>214: Remove GC Combinations Deprecated in JDK 8<br>215: Tiered Attribution for javac<br>216: Process Import Statements Correctly<br>217: Annotations Pipeline 2.0: 注解2.0<br>219: Datagram Transport Layer Security (DTLS)<br>220: Modular Run-Time Images<br>221: Simplified Doclet API<br>222: 增加jshell(Read-Eval-Print Loop)REPL交互<br>223: New Version-String Scheme:<br>224: HTML5 Javadoc<br>225: Javadoc Search<br>226: UTF-8 Property Files<br>227: Unicode 7.0<br>228: Add More Diagnostic Commands<br>229: Create PKCS12 Keystores by Default<br>231: Remove Launch-Time JRE Version Selection<br>232: Improve Secure Application Performance<br>233: Generate Run-Time Compiler Tests Automatically<br>235: Test Class-File Attributes Generated by javac<br>236: JS解析API<br>237: Linux/AArch64 Port<br>238: Multi-Release JAR Files: 多版本的jars<br>240: 移除JVM TI hprof Agent<br>241: 移除jhat工具<br>243: Java-Level JVM Compiler Interface<br>244: TLS Application-Layer Protocol Negotiation Extension<br>245: Validate JVM Command-Line Flag Arguments<br>246: Leverage CPU Instructions for GHASH and RSA<br>247: Compile for Older Platform Versions<br>248: 默认G1为垃圾收集器<br>249: OCSP Stapling for TLS<br>250: Store Interned Strings in CDS Archives<br>251: Multi-Resolution Images<br>252: Use CLDR Locale Data by Default<br>253: Prepare JavaFX UI Controls &amp; CSS APIs for Modularization<br>254: Compact Strings: 压缩字符串<br>255: Merge Selected Xerces 2.11.0 Updates into JAXP<br>256: BeanInfo Annotations<br>257: Update JavaFX/Media to Newer Version of GStreamer<br>258: HarfBuzz Font-Layout Engine<br>259: 栈跟踪API<br>260: Encapsulate Most Internal APIs<br>261: 模块化<br>262: TIFF Image I/O<br>263: HiDPI Graphics on Windows and Linux<br>264: Platform Logging API and Service<br>265: Marlin Graphics Renderer<br>266: More Concurrency Updates<br>267: 支持Unicode 8.0<br>268: XML Catalogs<br>269: Convenience Factory Methods for Collections<br>270: Reserved Stack Areas for Critical Sections<br>271: 统一GC日志<br>272: Platform-Specific Desktop Features<br>273: DRBG-Based SecureRandom Implementations<br>274: Enhanced Method Handles<br>275: Modular Java Application Packaging<br>276: Dynamic Linking of Language-Defined Object Models<br>277: Enhanced Deprecation<br>278: Additional Tests for Humongous Objects in G1<br>279: Improve Test-Failure Troubleshooting<br>280: Indify String Concatenation<br>281: HotSpot C++ Unit-Test Framework<br>282: Java链接jlink<br>283: Enable GTK 3 on Linux<br>284: New HotSpot Build System<br>285: Spin-Wait Hints<br>287: SHA-3 Hash Algorithms<br>288: Disable SHA-1 Certificates<br>289: 废除了Applet API<br>290: Filter Incoming Serialization Data<br>291: 放弃Concurrent Mark Sweep (CMS)垃圾收集器<br>292: Implement Selected ECMAScript 6 Features in Nashorn<br>294: Linux/s390x Port<br>295: Ahead-of-Time (AOT)编译<br>297: Unified arm32/arm64 Port<br>298: 移除Demos和Samples代码<br>299: Reorganize Documentation</p>
</blockquote>
<h2 id="JDK10"><a href="#JDK10" class="headerlink" title="JDK10"></a>JDK10</h2><p><a href="https://openjdk.java.net/projects/jdk/10/" target="_blank" rel="noopener">OpenJDK10文档</a><br><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk10-downloads-4416644.html" target="_blank" rel="noopener">OracleJDK下载</a></p>
<h3 id="新特性-2"><a href="#新特性-2" class="headerlink" title="新特性"></a>新特性</h3><blockquote>
<p>286: Local-Variable Type Inference:<br>296: 合并JDK到一个仓库<br>304: Garbage-Collector Interface<br>307: G1支持并行Full GC<br>310: 程序类数据共享<br>312: Thread-Local Handshakes: 握手操作是一个回调操作，当线程处于一个安全状态时被调用，目前支持x64平台，可以使用<code>-XX:ThreadLocalHandshakes</code>选项，默认为true<br>313: 移除javah生成工具<br>314: Additional Unicode Language-Tag Extensions<br>316: 堆分配在可以选择内存设备：有些系统提供non-DRAM内存，例如：NTFS DAX模式、ext4 DAX模式，这种模式提供了一种映射到物理内存的虚拟内存直接映射。可使用<code>-XX:AllocateHeapAt=&lt;path&gt;</code>选项配置，<code>-Xmx, -Xms</code>等其他参数正常工作，注意：1.确保该文件的权限，2.当应用终止时移除该文件<br>317: 基于Java的JIT编译器(实验阶段)<br>319: 根证书<br>322: Time-Based Release Versioning</p>
</blockquote>
<h2 id="JDK11-LTS"><a href="#JDK11-LTS" class="headerlink" title="JDK11 LTS"></a>JDK11 LTS</h2><p>继jdk8后的大版本LTS<br><a href="https://jdk.java.net/java-se-ri/11" target="_blank" rel="noopener">OpenJDK11下载</a><br><a href="https://openjdk.java.net/projects/jdk/11/" target="_blank" rel="noopener">OpenJDK11文档</a><br><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html" target="_blank" rel="noopener">OracleJDK下载</a><br><a href="https://docs.oracle.com/en/java/javase/11/" target="_blank" rel="noopener">Oracle文档</a></p>
<h3 id="新特性-3"><a href="#新特性-3" class="headerlink" title="新特性"></a>新特性</h3><blockquote>
<p>181: Nest-Based Access Control<br>309: Dynamic Class-File Constants: 动态的类文件常量<br>315: Improve Aarch64 Intrinsics<br>318: Epsilon: 一个空操作收集器<br>320: 移除了JavaEE和CORBA模块<br>321: HTTP Client (标准)<br>323: Local-Variable Syntax for Lambda Parameters<br>324: 支持Curve25519和Curve448的key协议<br>327: 支持Unicode 10<br>328: 飞行记录器JFR<br>329: ChaCha20 and Poly1305 xx20和Poly1305加密算法<br>330: Launch Single-File Source-Code Programs<br>331: Low-Overhead Heap Profiling: 低开销的堆分配采样<br>332: TLS升级为1.3<br>333: ZGC(实验阶段): 可扩展低延时的垃圾收集器<br>335: 废除了JS解析器Nashorn<br>336: 弃用Pack200工具类和API</p>
</blockquote>
<h2 id="JDK12"><a href="#JDK12" class="headerlink" title="JDK12"></a>JDK12</h2><p>jdk12发布了，jdk20还会远吗?</p>
<p><a href="https://jdk.java.net/12/" target="_blank" rel="noopener">OpenJDK下载</a><br><a href="https://openjdk.java.net/projects/jdk/12/" target="_blank" rel="noopener">OpenJDK12文档</a><br><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk12-downloads-5295953.html" target="_blank" rel="noopener">OracleJDK12下载</a><br><a href="https://docs.oracle.com/en/java/javase/12/" target="_blank" rel="noopener">OracleJDK12文档</a></p>
<h3 id="新特性-4"><a href="#新特性-4" class="headerlink" title="新特性"></a>新特性</h3><blockquote>
<p>189:    Shenandoah(实验阶段): 低停顿的垃圾收集器<br>230:    Microbenchmark Suite<br>325:    Switch语法<br>334:    JVM Constants API<br>340:    One AArch64 Port, Not Two<br>341:    Default CDS Archives<br>344:    G1实现可中止的Mixed GC：如果G1发现collection set重复尝试选择的region数量错误，就会选择一种增量的方式：把collection set分成两部分(强制的、可选择的)。G1回收强制性部分后，如果还有时间就开始以一种更细粒度回收可选择性部分，粒度3取决于时间，更多是一次一个region。当预测足够准确后，可选择部分就会越来越小，直到collection set全部变成强制性。当预测不精确后，下次会重新分成两部分<br>346:    Promptly Return Unused Committed Memory from G1</p>
</blockquote>
<h2 id="JDK13"><a href="#JDK13" class="headerlink" title="JDK13"></a>JDK13</h2><h3 id="新特性-5"><a href="#新特性-5" class="headerlink" title="新特性"></a>新特性</h3><blockquote>
<p>350:    Dynamic CDS Archives<br>351:    ZGC: Uncommit Unused Memory<br>353:    重新实现了Socket API<br>354:    Switch语法(预览)<br>355:    文本块(预览)</p>
</blockquote>
<h2 id="JDK14-LTS"><a href="#JDK14-LTS" class="headerlink" title="JDK14 LTS"></a>JDK14 LTS</h2><p><a href="https://jdk.java.net/java-se-ri/14" target="_blank" rel="noopener">OpenJDK14源码</a></p>
<blockquote>
<p>305:    Pattern Matching for instanceof (预览)<br>343:    Packaging Tool (孵化阶段)<br>345:    NUMA-Aware Memory Allocation for G1<br>349:    JFR Event Streaming<br>352:    Non-Volatile Mapped Byte Buffers<br>358:    更有用的NullPointerExceptions<br>359:    Records (Preview)<br>361:    Switch语法(预览)<br>362:    废除了对Solaris和SPARC的支持<br>363:    移除了Concurrent Mark Sweep (CMS)垃圾回收器<br>364:    ZGC在macOS平台的实现<br>365:    ZGC在Windows平台的实现<br>366:    弃用ParallelScavenge + SerialOld GC组合模式<br>367:    移除Pack200工具类和API<br>368:    Text Blocks (二次预览)<br>370:    Foreign-Memory Access API (孵化阶段)</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java,jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>第十七天 + 第十八天</title>
    <url>/2020/12/08/os-17/</url>
    <content><![CDATA[<p>这一卡停歇主要在多任务切换时鼠标focus的切换上出问题了，在Deepin上尝试了很多种方法，其中包括QEMU的多种版本，百思不得其解。最后想着在其它系统上试一下，最后在Ubuntu20.04上竟然很完美的运行没有任何问题。当时就懵逼了。有时候真的是，遇到问题，多试试其它的，也许是系统的问题呢。</p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>think-in-career</title>
    <url>/2020/12/07/think-in-career/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>资本主义的胜利</title>
    <url>/2020/11/05/think-in-lism/</url>
    <content><![CDATA[<p>前几年无意中看到一句话，”无论中国文化到哪里，都是对文明的一种毁灭。”，我对这句话的第一次认同是关于国内搜索引擎的的深恶痛绝，网络上到处充斥着复制、粘贴的东西，原创性的缺乏导致泛滥的垃圾，可想而知的结局就是检索成本的增加。如果说背后是利益的驱使，可细想之后，何尝不是文化的问题？<br><a id="more"></a><br>国内经济的快速发展使中国处于全球第二经济体的地位。但是经济的快速发展背后仍然是文明的一片荒芜。建国伊始，我们就面临一次姓社还是姓资的问题，这也那次革命的本质。在很多人的认知里，资本主义是惨无人道的资本家剥削的代表。最终，在稻家人的背叛中，我们走向一种”特色社会主义”，什么”白猫黑猫论”、”造不如买，买不如租”，直接导致中国的科技落后资本主义几十年。<br>“特色社会主义”，既然是特色，就表明既不是资本主义，也不是完全的社会主义。在这种主义里，我们每个人仍然活在”舍小家为大家”、”集体主义”、”先富带动后富”的家国情怀里，而被舍弃的这一部分人已经很难摆脱命运的安排。走到今天，我们已经不得不思考这种制度到底是不是一种优越的制度。”996福报”、”35岁淘汰论”，既然资产阶级已经存在这么多的剥削，我们为什么还要坚持呢？底层劳动人民该有的权益得不到保障，我们还要心肝情愿的付出？<br>在我的学生时代，接触过几家国外的餐饮企业，他们对规章制度的严格要求在国内很多五星级的酒店都无法达到，这就是文化的问题。其中一家是肯德基，一家是希尔顿酒店。肯德基对食物的要求是不留隔夜菜，过期食材必须废弃，油榨食用油每隔多长时间需要更换一次。希尔顿对员工的穿着、食材也是必须遵守规章制度。而这一切到国内很大一部分已经走样了，不再被遵守。我们可能都会说老外太死板，可不知国人的那种”圆滑”已经到了让人深恶痛绝的地步。<br>我对国内的厌倦来源于对北京的失望，甚至绝望。北方文明和南方文明有着巨大的差异，一个是公共服务，一个是服务行业。北京，作为政治中心，可以说是北方唯一一个最文明的城市，昌平图书馆作为一个公共服务场所，那里的服务简直让人对北京这个帝都产生怀疑，网上完全是的服务的控诉，和深圳的图书馆相比完全是两个世界。老外的很多产品卖的都是服务，如果你尝试买一次国内便宜的服务，看似省了不少，而售后服务的恶劣简直让你发狂。比如苹果、微软、肯德基，相信很多狂街的人都经历过满世界找厕所的痛苦，满满的大街上竟然没有一个公共厕所，最后只期待一个肯德基、麦当劳，也许这就是所谓的文明的吧！而如今，就连肯德基也出现了没有厕所、厕所无法使用、不提供充电接口的情况，而且越来越多，如果这样，我为什么要去一个溢价极高的餐厅？这是一种文明的倒退，而这个是否在本土化过程中的一些问题呢？<br>文化，或者说文明，无论是三千年，还是五千年，如果对人类的文明是一种伤害的话，所谓的文化自信，我是不在乎的，一切逆历史潮流的东西，我们也是没有必要去发扬光大的。人是本体，一切都是为人类服务，如果一种文化只追求最大利益化，而舍弃了人类最基本的利益，我希望她早日湮灭在历史潮流中。</p>
]]></content>
  </entry>
  <entry>
    <title>第十五天 + 第十六天</title>
    <url>/2020/10/26/os-15/</url>
    <content><![CDATA[<p>好久没写了，落了太多，主要中间被鼠标的移动卡住了，解决后一直没心思写。今天的主要任务是<code>多任务</code>。<br>多任务的原理，CPU执行任务切换时，将当前寄存器中的值写入内存(也叫保存现场)，调用任务执行完成后，从内存中将值读取到寄存器，继续执行之前的任务。</p>
<a id="more"></a>
<p>EIP: 扩展指令指针寄存器，是一个32位寄存器，对应16位的IP寄存器。CPU使用EIP来存储下一条执行指令内存地址的寄存器。理论上每执行一条指令，EIP寄存器的值会自动累加，指向下一条指令的内存地址。</p>
<p>JMP: JMP指令本质上还是通过将跳转的内存地址赋值到EIP，同时将EIP状态保存在TSS中，</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">struct TSS32 &#123;</span><br><span class="line">	<span class="keyword">int</span> backlink, esp0, ss0, esp1, ss1, esp2, ss2, <span class="built_in">cr3</span><span class="comment">;</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">eip</span>, eflags, <span class="built_in">eax</span>, <span class="built_in">ecx</span>, <span class="built_in">edx</span>, <span class="built_in">ebx</span>, <span class="built_in">esp</span>, <span class="built_in">ebp</span>, <span class="built_in">esi</span>, <span class="built_in">edi</span><span class="comment">;</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">es</span>, <span class="built_in">cs</span>, <span class="built_in">ss</span>, <span class="built_in">ds</span>, <span class="built_in">fs</span>, <span class="built_in">gs</span><span class="comment">;</span></span><br><span class="line">	<span class="keyword">int</span> ldtr, iomap<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>JMP指令分为两种模式：<br>near模式：只改写EIP寄存器<br><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">JMP</span>		keystatus</span><br></pre></td></tr></table></figure></p>
<p>far模式：同时改写EIP和CS寄存器，格式中带冒号’:’<br><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">JMP</span>		<span class="built_in">DWORD</span> <span class="number">2</span>*<span class="number">8</span>:<span class="number">0x0000001b</span>   // [<span class="built_in">EIP</span>]=<span class="number">0x1b</span><span class="comment">; [CS]=2*8</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>如果JMP的目标地址不是可执行代码，而是TSS，则CPU不执行对EIP、CS的改写，而是执行任务切换。TSS的判断通过读取GDT的设置来确定。<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">set_segmdesc(<span class="name">gdt</span> + <span class="number">3</span>, <span class="number">103</span>, (<span class="name">int</span>) <span class="symbol">&amp;tss_a</span>, AR_TSS32)<span class="comment">;  // 将任务tss_a定义在gdt的3号位置</span></span><br></pre></td></tr></table></figure></p>
<p>TR寄存器：任务寄存器。记录CPU当前正在运行的任务，存储GDT的编号乘以8的数值(约定规则)。例如：<code>gdt + 3</code>会在TR中存入<code>3*8</code>，</p>
<p><code>LTR</code>：改变TR寄存器的值，并不会进行任务切换。</p>
<p><code>JMP FAR</code>: 从指定的内存地址读取4字节数据存入EIP寄存器，继续读取2字节存入CS寄存器。例如：<br><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">JMP		FAR	<span class="string">[ESP+4]</span>    ; <span class="string">[EIP]</span>=<span class="string">[ESP+4]</span>  <span class="string">[CS]</span>=<span class="string">[ESP+8]</span></span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>第五天 + 第六天</title>
    <url>/2020/10/05/os-05/</url>
    <content><![CDATA[<p>难度越来越大了。今天的内容设计的中断表，全局分段表，核心就是GDT和IDT。第五天、第六天内容偏理论性比较多，结合放在一篇博客内。</p>
<a id="more"></a>
<h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>系统中存在多个程序同时运行，如果加载到相同的内存地址，则会导致内存冲突而无法运行。为了解决这个问题就需要用到分段的思想。</p>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>分段就是把整个内存分成很多块(block)，每一块的起始位置都看作0x0000，然后对应到实际的物理地址。段寄存器DS终于派上用场了。<br>如何表示一个段？</p>
<ol>
<li>段的大小是多少</li>
<li>段对应的物理起始位置</li>
<li>段的权限(禁止写入，禁止执行，系统专用等)</li>
</ol>
<p>原理：<br>CPU表示一个段需要8字节，DS为16位，实际上为了兼容，能用的只有13位，所以能表示的段有$ 2^13 = 8192 $个段，表示这些段需要$ 8192 * 8 = 64KB $，显然CPU不具备存储这么多数据的条件，而是放在内存中，这就是GDT(全局段号记录表)，这块内存的起始地址放在CPU的特殊寄存器GDTR内。</p>
<p>段上限：表示一个段有多少个字节，用low(2)+mid(1)+mid(1)共4个字节表示。最大表示4GB需要4B，加上基地址4B，总共需要8B，段上限只保留20位，2^20 = 1MB，通过将段属性一个位设置为1，段上限的单位解释为页，1页是4KB，这样 1MB * 4KB = 4GB。这20位用low 2个字节和high的高4位表示。</p>
<p>段的访问属性：使用剩余的12位表示，<code>xxxx0000 xxxxxxxxx</code>，高4位0给段上限使用，低4位使用<code>GD00</code>表示，D-段上限的Gbit，D-段的模式，1是32位模式，0是16位模式。<br>| bit位 | 用途 | 权限 |<br>|:-|:-:|:-:|<br>| 0x00 | 未使用的记录表| - |<br>| 0x92 | 系统专用 | 可读，可写，不可执行 |<br>| 0x9a | 系统专用 | 可读，不可写，可执行 |<br>| 0xf2 | 应用程序用 | 可读，可写，不可执行 |<br>| 0xfa | 应用程序用 | 可读，不可写，可执行 |</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>IDR: 中断记录表。记录中断号和处理函数的对应关系。</p>
<h3 id="PIC"><a href="#PIC" class="headerlink" title="PIC"></a>PIC</h3><p>IRQ: interrupt request。<br>PIC: 可中断编程控制器。CPU单独只能处理一个中断，主板通过增加几个辅助芯片组成芯片组。PIC是将8个中断信号集合成一个中断信号的装置。主PIC和CPU直连，从PIC连接在主PIC的IRQ2上。<br>PIC内部有很多寄存器，通过端口号进行区分写入哪一个寄存器。即便端口相同，也可以通过规则区分：先写入ICW1，接着写入ICW2。<br>IMR: interrupt mask register 中断屏蔽寄存器。8位分别对应8路IRQ，如果某一位的值置为1，则该位对应的IRQ信号被屏蔽，PIC就忽视该信号。<br>ICW: initial control word 初始化控制数据。总共有4个，编号为1~4。</p>
<blockquote>
<p>ICW1和ICW4<br>ICW3<br>ICW2: 决定IRQ以哪一号中断通知CPU。不同的操作系统可以单独设定。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>第四天</title>
    <url>/2020/10/04/os-04/</url>
    <content><![CDATA[<p>第四天了，今天的功能就是在画面上显示点东西。本质上，画面的展示还是对VGA显卡的操作。</p>
<a id="more"></a>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>这一部分主要是C语言的编程，对BIOS的操作通过在<code>bootpack.c</code>调用<code>naskfun.asm</code>汇编来实现。</p>
<ol>
<li>显示白色<br>bootpack.c调用write_mem8()方法来实现对VRAM内存的操作。<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> io_hlt(<span class="built_in">void</span>);</span><br><span class="line"><span class="built_in">void</span> write_mem8(<span class="built_in">int</span> addr, <span class="built_in">int</span> data);</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> HariMain(<span class="built_in">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> i;</span><br><span class="line">	<span class="comment">// 白色</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0xa0000</span>; i &lt;= <span class="number">0xaffff</span>; i++) &#123;</span><br><span class="line">		write_mem8(i, <span class="number">15</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		io_hlt();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>naskfunc.asm<br><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; naskfunc</span></span><br><span class="line"><span class="comment">; TAB=4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">section</span> .data</span><br><span class="line"><span class="meta">section</span> .text</span><br><span class="line"><span class="meta">global</span>	io_hlt,write_mem8</span><br><span class="line"></span><br><span class="line"><span class="symbol">io_hlt:</span>	<span class="comment">; void io_hlt(void);</span></span><br><span class="line">	<span class="keyword">HLT</span></span><br><span class="line">	<span class="keyword">RET</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">write_mem8:</span>	<span class="comment">; void write_mem8(int addr, int data);</span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">ECX</span>,[<span class="built_in">ESP</span>+<span class="number">4</span>]		<span class="comment">;</span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">AL</span>,[<span class="built_in">ESP</span>+<span class="number">8</span>]		<span class="comment">;</span></span><br><span class="line">	<span class="keyword">MOV</span>		[<span class="built_in">ECX</span>],<span class="built_in">AL</span></span><br><span class="line">	<span class="keyword">RET</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>section伪指令的位置一定要注意，因为对section的语法陌生，导致出现黑屏；其次要注意asm文件中<code>io_hlt</code>函数名的语法，有的编译器需要加前缀<code>_io_hlt</code></p>
<ol start="2">
<li>通过设定调色板显示彩条<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> HariMain(<span class="built_in">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	char *vram;</span><br><span class="line">	<span class="built_in">int</span> xsize, ysize;</span><br><span class="line"></span><br><span class="line">	init_palette();</span><br><span class="line">	vram = (char *) <span class="number">0xa0000</span>;</span><br><span class="line">	xsize = <span class="number">320</span>;</span><br><span class="line">	ysize = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩形1</span></span><br><span class="line">	boxfill8(vram, xsize, COL8_008484,  <span class="number">0</span>,         <span class="number">0</span>,          xsize -  <span class="number">1</span>, ysize - <span class="number">29</span>);</span><br><span class="line">	boxfill8(vram, xsize, COL8_C6C6C6,  <span class="number">0</span>,         ysize - <span class="number">28</span>, xsize -  <span class="number">1</span>, ysize - <span class="number">28</span>);</span><br><span class="line">	boxfill8(vram, xsize, COL8_FFFFFF,  <span class="number">0</span>,         ysize - <span class="number">27</span>, xsize -  <span class="number">1</span>, ysize - <span class="number">27</span>);</span><br><span class="line">	boxfill8(vram, xsize, COL8_C6C6C6,  <span class="number">0</span>,         ysize - <span class="number">26</span>, xsize -  <span class="number">1</span>, ysize -  <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩形2</span></span><br><span class="line">	boxfill8(vram, xsize, COL8_FFFFFF,  <span class="number">3</span>,         ysize - <span class="number">24</span>, <span class="number">59</span>,         ysize - <span class="number">24</span>);</span><br><span class="line">	boxfill8(vram, xsize, COL8_FFFFFF,  <span class="number">2</span>,         ysize - <span class="number">24</span>,  <span class="number">2</span>,         ysize -  <span class="number">4</span>);</span><br><span class="line">	boxfill8(vram, xsize, COL8_848484,  <span class="number">3</span>,         ysize -  <span class="number">4</span>, <span class="number">59</span>,         ysize -  <span class="number">4</span>);</span><br><span class="line">	boxfill8(vram, xsize, COL8_848484, <span class="number">59</span>,         ysize - <span class="number">23</span>, <span class="number">59</span>,         ysize -  <span class="number">5</span>);</span><br><span class="line">	boxfill8(vram, xsize, COL8_000000,  <span class="number">2</span>,         ysize -  <span class="number">3</span>, <span class="number">59</span>,         ysize -  <span class="number">3</span>);</span><br><span class="line">	boxfill8(vram, xsize, COL8_000000, <span class="number">60</span>,         ysize - <span class="number">24</span>, <span class="number">60</span>,         ysize -  <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩形3</span></span><br><span class="line">	boxfill8(vram, xsize, COL8_848484, xsize - <span class="number">47</span>, ysize - <span class="number">24</span>, xsize -  <span class="number">4</span>, ysize - <span class="number">24</span>);</span><br><span class="line">	boxfill8(vram, xsize, COL8_848484, xsize - <span class="number">47</span>, ysize - <span class="number">23</span>, xsize - <span class="number">47</span>, ysize -  <span class="number">4</span>);</span><br><span class="line">	boxfill8(vram, xsize, COL8_FFFFFF, xsize - <span class="number">47</span>, ysize -  <span class="number">3</span>, xsize -  <span class="number">4</span>, ysize -  <span class="number">3</span>);</span><br><span class="line">	boxfill8(vram, xsize, COL8_FFFFFF, xsize -  <span class="number">3</span>, ysize - <span class="number">24</span>, xsize -  <span class="number">3</span>, ysize -  <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		io_hlt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><p>i386</p>
<p>i486</p>
<p>i586</p>
<p>ASM装配程序分为3个部分：</p>
<ol>
<li>data部分：声明数据</li>
<li>bss部分：声明变量</li>
<li>text部分：用于保存实际代码，必须声明<code>global</code>全局函数，并对函数进行实现。</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">section</span> .data</span><br><span class="line"><span class="selector-tag">section</span> .bss</span><br><span class="line"><span class="selector-tag">section</span> .text</span><br><span class="line">    global io_hlt</span><br><span class="line">io_hlt:</span><br><span class="line">    HLT</span><br></pre></td></tr></table></figure>
<h3 id="本节指令"><a href="#本节指令" class="headerlink" title="本节指令"></a>本节指令</h3><p>‘OUT’: CPU向设备发送电信号。每个设备定义了设备号码，即端口(Port)。<br>‘IN’: CPU从设备获取电信号指令。<br>‘CLI’: 将中断标志位置为0。<br>‘STI’: 将中断标志位置为1。<br>‘PUSHFD’: 将标志位的值按照双字长压入栈。实际操作就是<code>PUSH EFLAGS</code>。<br>‘POPFD’: 按照双字长将标志位的值弹出栈。实际操作就是<code>POP EFLAGS</code>。</p>
]]></content>
  </entry>
  <entry>
    <title>第三天</title>
    <url>/2020/10/03/os-03/</url>
    <content><![CDATA[<p>开始运行一些画面了，这个地方卡了很长时间，由于原作者是在Windows下开发，我打算在Deepin下来做，中间没有思路爽性就放下了。最开始写盘采用的是<code>dd</code>命令，网上很多人也是采用dd，但是运行一直报错’load error’，更换了好几个版本的qemu都没有效果，使用<code>gdb</code>进行debug，使用<code>objdump</code>反编译，最后偶然之间发现了一位日本网友在Ubuntu系统实现的<code>Makefile</code>，得以成功。<br>编写系统还是需要很深厚的基础功底。祝各位踩坑的，不抛弃，不放弃吧。</p>
<a id="more"></a>
<p><a href="https://qiita.com/pollenjp/items/8fcb9573cdf2dc6e2668" target="_blank" rel="noopener">日本网友基于Ubuntu的实现</a></p>
<p><a href="https://github.com/wangwanchao/os_30day/tree/main" target="_blank" rel="noopener">我的github</a></p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>第三天的主要功能是对磁盘的操作。从单个扇区到多个扇区、多个柱面</p>
<ol>
<li><p>读取1个扇区：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">entry:</span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">AX</span>,<span class="number">0</span>			<span class="comment">; 初始化寄存器</span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">SS</span>,<span class="built_in">AX</span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">SP</span>,<span class="number">0x7c00</span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">DS</span>,<span class="built_in">AX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 读取磁盘1个扇区＝512字节</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">AX</span>,<span class="number">0x0820</span>		</span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">ES</span>,<span class="built_in">AX</span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="number">CH</span>,<span class="number">0</span>			<span class="comment">; 柱面</span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="number">DH</span>,<span class="number">0</span>			<span class="comment">; 磁头</span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">CL</span>,<span class="number">2</span>			<span class="comment">; 扇区</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="number">AH</span>,<span class="number">0x02</span>			<span class="comment">; AH=0x02:读盘 0x03:写盘 0x04:校验 0x0c:寻道</span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">AL</span>,<span class="number">1</span>			<span class="comment">; 1个扇区</span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">BX</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">DL</span>,<span class="number">0x00</span>			<span class="comment">; A驱动器</span></span><br><span class="line">	<span class="keyword">INT</span>		<span class="number">0x13</span>			<span class="comment">; 调用磁盘BIOS</span></span><br><span class="line">	<span class="keyword">JC</span>		error			<span class="comment">; 如果读盘失败，跳转显示错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 读盘成功进入休眠</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">fin:</span></span><br><span class="line">	<span class="keyword">HLT</span>						  <span class="comment">;</span></span><br><span class="line">	<span class="keyword">JMP</span>		fin				<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">error:</span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">SI</span>,msg</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取18个扇区：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; 读盘</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">AX</span>,<span class="number">0x0820</span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">ES</span>,<span class="built_in">AX</span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="number">CH</span>,<span class="number">0</span>			<span class="comment">; </span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="number">DH</span>,<span class="number">0</span>			<span class="comment">; </span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">CL</span>,<span class="number">2</span>			<span class="comment">; </span></span><br><span class="line"><span class="symbol">readloop:</span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">SI</span>,<span class="number">0</span>			<span class="comment">; 记录读盘失败次数的寄存器</span></span><br><span class="line"><span class="symbol">retry:</span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="number">AH</span>,<span class="number">0x02</span>			<span class="comment">; </span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">AL</span>,<span class="number">1</span>			<span class="comment">; </span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">BX</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">DL</span>,<span class="number">0x00</span>			<span class="comment">; </span></span><br><span class="line">	<span class="keyword">INT</span>		<span class="number">0x13</span>			<span class="comment">; </span></span><br><span class="line">	<span class="keyword">JNC</span>		next			<span class="comment">; 读盘成功则继续</span></span><br><span class="line">	<span class="keyword">ADD</span>		<span class="built_in">SI</span>,<span class="number">1</span>			<span class="comment">; 读盘失败则重试5次</span></span><br><span class="line">	<span class="keyword">CMP</span>		<span class="built_in">SI</span>,<span class="number">5</span>			<span class="comment">; </span></span><br><span class="line">	<span class="keyword">JAE</span>		error			<span class="comment">; 重试5次后仍然失败则跳转到'load error'</span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="number">AH</span>,<span class="number">0x00</span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">DL</span>,<span class="number">0x00</span>			<span class="comment">; </span></span><br><span class="line">	<span class="keyword">INT</span>		<span class="number">0x13</span>			<span class="comment">; 重试未满5次则重置驱动器后继续重试</span></span><br><span class="line">	<span class="keyword">JMP</span>		retry</span><br><span class="line"><span class="symbol">next:</span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">AX</span>,<span class="built_in">ES</span>			<span class="comment">; 内存地址后移0x200</span></span><br><span class="line">	<span class="keyword">ADD</span>		<span class="built_in">AX</span>,<span class="number">0x0020</span></span><br><span class="line">	<span class="keyword">MOV</span>		<span class="built_in">ES</span>,<span class="built_in">AX</span>			<span class="comment">;</span></span><br><span class="line">	<span class="keyword">ADD</span>		<span class="built_in">CL</span>,<span class="number">1</span>			<span class="comment">;</span></span><br><span class="line">	<span class="keyword">CMP</span>		<span class="built_in">CL</span>,<span class="number">18</span>			<span class="comment">;</span></span><br><span class="line">	<span class="keyword">JBE</span>		readloop		<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">JMP</span>     success         <span class="comment">; 成功</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这里设置AL=1通过循环的方式实现，跟设置AL=17的效果是一致的，没有直接使用AL=17的原因在于BIOS的规则：</p>
<blockquote>
<p>指定处理的扇区数，范围在0x01 ~ 0xff(指定0x02以上的数值时，要特别注意<strong>连续处理多个扇区</strong>的条件。)</p>
</blockquote>
<ol start="3">
<li><p>读取10个柱面：</p>
</li>
<li><p>启动区后增加执行程序</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; haribote-os</span></span><br><span class="line"><span class="comment">; TAB=4</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">ORG	</span>	<span class="number">0xc200</span>			<span class="comment">; </span></span><br><span class="line"></span><br><span class="line"><span class="symbol">fin:</span></span><br><span class="line">	HLT</span><br><span class="line">	<span class="keyword">JMP	</span>	fin</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这段代码中可以看到org=0x2c00，为什么呢？因为对空软盘写操作时，文件内容一般是在地址<code>0x004200</code>之后，先写入ipl.bin后，再写入haribote.o，基于0x8000的内存位置，0x8000 + 0x4200 = 0xc200。</p>
<h2 id="32位模式"><a href="#32位模式" class="headerlink" title="32位模式"></a>32位模式</h2><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>‘EQU’: 用来声明常量值。例如：<code>CYLS EQU&amp; 10</code>表示CYLS=10。<br>‘JC’: jump if carry 如果进位标志(FLAGS.CF)是1，则跳转。<br>‘JNC’: jump if not carry 如果进位标志(FLAGS.CF)是0，则跳转。正好相反。<br>‘JAE’: jump if above or equal 如果大于或等于则跳转。<br>‘JE’: jump if below 如果小于则跳转。<br>‘JBE’: jump if below or equal 如果小于等于则跳转。<br>‘INT 0x13’: 操作磁盘<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">操作磁盘</span><br><span class="line">AH</span><br><span class="line">AL</span><br><span class="line"><span class="attribute">CH</span>=柱面号</span><br><span class="line"><span class="attribute">CL</span>=扇区号</span><br><span class="line"><span class="attribute">DH</span>=磁头号</span><br><span class="line"><span class="attribute">DL</span>=驱动器号</span><br><span class="line">ES:<span class="attribute">BX</span>=缓冲地址</span><br><span class="line">返回值：</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>可以看出很多指令都是有规律的。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>汇编编译<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">nasm</span> <span class="selector-tag">-f</span> <span class="selector-tag">elf</span> <span class="selector-tag">ipl</span><span class="selector-class">.asm</span> <span class="selector-tag">-o</span> <span class="selector-tag">ipl</span><span class="selector-class">.bin</span></span><br></pre></td></tr></table></figure></p>
<p>链接编译<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">gcc</span> <span class="selector-tag">-nostdlib</span> <span class="selector-tag">-T</span> <span class="selector-tag">har</span><span class="selector-class">.ld</span></span><br></pre></td></tr></table></figure></p>
<p>‘-T’：指定链接脚本</p>
<h3 id="ld脚本"><a href="#ld脚本" class="headerlink" title="ld脚本"></a>ld脚本</h3><p>Linker scripts使用一种特殊的脚本语言实现。用来指定最终可执行二进制文件的格式、布局。一些可执行二进制文件为了能够被BootLoader识别，通常需要指定文件布局。<br>语法：<br>ENTRY: 指定应用的入口点，这个点通常是最终输出文件的第一个可执行指令。<br>OUTPUT_FORMAT：指定可执行文件的输出格式。使用<code>objdump -i</code>可以查看系统支持的格式。<br>STARTUP：用来指定将哪个文件放在可执行文件的起始位置。<br>INPUT：用来替代命令行中指定多个obj文件。<br>OUTPUT：指定生成的可执行文件的名称。<br>MEMORY：用来声明多个内存区域的读写权限。<br>SECTIONS：用来指定内存位置、<code>.text/.data/.bss</code>的信息</p>
<h3 id="DOS指令"><a href="#DOS指令" class="headerlink" title="DOS指令"></a>DOS指令</h3><ol>
<li>copy指令<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">COPY [<span class="string">/D</span>] [<span class="string">/V</span>] [<span class="string">/N</span>] [<span class="string">/Y</span> | <span class="string">/-Y</span>] [<span class="string">/Z</span>] [<span class="string">/L</span>] [<span class="string">/A</span> | <span class="string">/B</span> ] source [<span class="string">/A</span> | <span class="string">/B</span>] [+ source [<span class="string">/A</span> | <span class="string">/B</span>] [+ <span class="string">...</span>]] [destination [<span class="string">/A</span> | <span class="string">/B</span>]]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>‘source’: 指定要复制的文件。<br>‘/A’: 表示一个 ASCII 文本文件。<br>‘/B’: 表示一个二进位文件。<br>‘/D’: 允许解密要创建的目标文件，destination 为新文件指定目录和/或文件名。<br>‘/V 验证新文件写入是否正确。<br>‘/N 复制带有非 8dot3 名称的文件时，尽可能使用短文件名。<br>‘/Y 不使用确认是否要覆盖现有目标文件的提示。<br>‘/-Y’: 使用确认是否要覆盖现有目标文件的提示。<br>‘/Z’: 用可重新启动模式复制已联网的文件。<br>‘/L’: 如果源是符号链接，请将链接复制到目标而不是源链接指向的实际文件。</p>
<ol start="2">
<li><p>mcopy指令</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mcopy</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>format指令</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line"><span class="built_in">format</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>mformat指令<br>将一个最小化的<code>MS-DOS</code>文件系统添加到已经被Unix系统格式化的磁盘/软盘中，该文件系统包含启动区(boot sector)、FAT、根目录(root directory)。<br>现在的电脑，基本都只有1个软盘，以前一般都是2个。</p>
</li>
</ol>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">mformat <span class="string">[-t cylinders|-T tot_sectors]</span> <span class="string">[-h heads]</span> <span class="string">[-s sectors]</span></span><br><span class="line">  <span class="string">[-f size]</span> <span class="string">[-1]</span> <span class="string">[-4]</span> <span class="string">[-8]</span></span><br><span class="line">  <span class="string">[-v volume_label]</span></span><br><span class="line">  <span class="string">[-F]</span> <span class="string">[-S sizecode]</span></span><br><span class="line">  <span class="string">[-M software_sector_size]</span></span><br><span class="line">  <span class="string">[-N serial_number]</span> <span class="string">[-a]</span></span><br><span class="line">  <span class="string">[-C]</span> <span class="string">[-H hidden_sectors]</span> <span class="string">[-I fsVersion]</span></span><br><span class="line">  <span class="string">[-r root_sectors]</span> <span class="string">[-L fat_len]</span> </span><br><span class="line">  <span class="string">[-B boot_sector]</span> <span class="string">[-k]</span></span><br><span class="line">  <span class="string">[-m media_descriptor]</span></span><br><span class="line">  <span class="string">[-K backup_boot]</span></span><br><span class="line">  <span class="string">[-R nb_reserved_sectors]</span></span><br><span class="line">  <span class="string">[-c clusters_per_sector]</span></span><br><span class="line">  <span class="string">[-d fat_copies]</span></span><br><span class="line">  <span class="string">[-X]</span> <span class="string">[-2 sectors_on_track_0]</span> <span class="string">[-3]</span></span><br><span class="line">  <span class="string">[-0 rate_on_track_0]</span> <span class="string">[-A rate_on_other_tracks]</span></span><br><span class="line">  drive:</span><br></pre></td></tr></table></figure>
<p>‘-f’: 指定将要格式化软盘的DOS文件系统的size，仅支持个别参数(160K、180K、320K、360K、720K、1200K、1440K、2880K)，如果需要支持其他参数，可以结合’-h/-t/-s’使用。一张软盘2个面，每个柱面18个扇区，80个柱面，每个扇区512B：$ 2<em>18</em>80*512 = 1440KB $<br>‘-C’: 创建磁盘镜像，并将<code>MS-DOS</code>安装在磁盘上，很明显这个参数在物理设备上是不起作用的，例如：软盘、硬盘。<br>‘-B’: 代替默认的，使用boot sector来存储给定的文件、设备。</p>
]]></content>
  </entry>
  <entry>
    <title>第二天</title>
    <url>/2020/10/02/os-02/</url>
    <content><![CDATA[<p>从学习汇编开始，我就一直觉得寄存器是一个很抽象的东西，尤其是通过地址去操作。这次学习重新打开《汇编语言》，巩固一下。</p>
<a id="more"></a>
<p>第一天主要使用的是字节码来编程，今天改为汇编</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p><code>helloos.asm</code>也切换到<code>ipl.asm</code>，让它看起来像个系统。这里改变的主要是显示部分。<br>优化前：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">;　程序主体</span><br><span class="line"></span><br><span class="line">	DB		<span class="number">0xb8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x8e</span>, <span class="number">0xd0</span>, <span class="number">0xbc</span>, <span class="number">0x00</span>, <span class="number">0x7c</span></span><br><span class="line">	DB		<span class="number">0x8e</span>, <span class="number">0xd8</span>, <span class="number">0x8e</span>, <span class="number">0xc0</span>, <span class="number">0xbe</span>, <span class="number">0x74</span>, <span class="number">0x7c</span>, <span class="number">0x8a</span></span><br><span class="line">	DB		<span class="number">0x04</span>, <span class="number">0x83</span>, <span class="number">0xc6</span>, <span class="number">0x01</span>, <span class="number">0x3c</span>, <span class="number">0x00</span>, <span class="number">0x74</span>, <span class="number">0x09</span></span><br><span class="line">	DB		<span class="number">0xb4</span>, <span class="number">0x0e</span>, <span class="number">0xbb</span>, <span class="number">0x0f</span>, <span class="number">0x00</span>, <span class="number">0xcd</span>, <span class="number">0x10</span>, <span class="number">0xeb</span></span><br><span class="line">	DB		<span class="number">0xee</span>, <span class="number">0xf4</span>, <span class="number">0xeb</span>, <span class="number">0xfd</span></span><br><span class="line"></span><br><span class="line">;　信息显示部分</span><br><span class="line"></span><br><span class="line">	DB		<span class="number">0x0a</span>, <span class="number">0x0a</span>		;　换行</span><br><span class="line">	DB		<span class="string">"hello, world"</span></span><br><span class="line">	DB		<span class="number">0x0a</span>			;</span><br><span class="line">	DB		<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>优化后：<br><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; 程序核心</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">entry:</span></span><br><span class="line">    <span class="keyword">MOV</span>		<span class="built_in">AX</span>,<span class="number">0</span>			<span class="comment">; 初始化寄存器</span></span><br><span class="line">    <span class="keyword">MOV</span>		<span class="built_in">SS</span>,<span class="built_in">AX</span></span><br><span class="line">    <span class="keyword">MOV</span>		<span class="built_in">SP</span>,<span class="number">0x7c00</span></span><br><span class="line">    <span class="keyword">MOV</span>		<span class="built_in">DS</span>,<span class="built_in">AX</span></span><br><span class="line">    <span class="keyword">MOV</span>		<span class="built_in">ES</span>,<span class="built_in">AX</span></span><br><span class="line">    <span class="keyword">MOV</span>		<span class="built_in">SI</span>,msg</span><br><span class="line"></span><br><span class="line"><span class="symbol">putloop:</span></span><br><span class="line">    <span class="keyword">MOV</span>		<span class="built_in">AL</span>,[<span class="built_in">SI</span>]         <span class="comment">; 指向msg字符串</span></span><br><span class="line">    <span class="keyword">ADD</span>		<span class="built_in">SI</span>,<span class="number">1</span>			<span class="comment">; 遍历指针 </span></span><br><span class="line">    <span class="keyword">CMP</span>		<span class="built_in">AL</span>,<span class="number">0</span>			<span class="comment">; 比较是否到字符串末尾</span></span><br><span class="line">    <span class="keyword">JE</span>		fin</span><br><span class="line">    <span class="keyword">MOV</span>		<span class="number">AH</span>,<span class="number">0x0e</span>			<span class="comment">; </span></span><br><span class="line">    <span class="keyword">MOV</span>		<span class="built_in">BX</span>,<span class="number">15</span>			<span class="comment">; </span></span><br><span class="line">    <span class="keyword">INT</span>		<span class="number">0x10</span>			<span class="comment">; 中断显示字符</span></span><br><span class="line">    <span class="keyword">JMP</span>		putloop</span><br><span class="line"></span><br><span class="line"><span class="symbol">fin:</span></span><br><span class="line">	<span class="keyword">HLT</span>						<span class="comment">; </span></span><br><span class="line">	<span class="keyword">JMP</span>		fin				<span class="comment">; </span></span><br><span class="line"></span><br><span class="line"><span class="symbol">msg:</span></span><br><span class="line">	<span class="built_in">DB</span>		<span class="number">0x0a</span>, <span class="number">0x0a</span>		<span class="comment">; </span></span><br><span class="line">	<span class="built_in">DB</span>		<span class="string">"hello, world"</span></span><br><span class="line">	<span class="built_in">DB</span>		<span class="number">0x0a</span>			<span class="comment">; </span></span><br><span class="line">	<span class="built_in">DB</span>		<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>看起来变化很大， 其实只是从机器码转换为汇编，贴出一部分操作码：<br>| 汇编 | 字节码 |<br>|:-|:-:|<br>| MOV AX | 0xb8 |<br>| MOV SS | 0x8e |<br>| MOV SP | 0xbc |<br>| MOV DS,AX | 0x8e 0xd8|<br>| MOV ES,AX | 0x8e 0xc0|</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h4 id="8位寄存器"><a href="#8位寄存器" class="headerlink" title="8位寄存器"></a>8位寄存器</h4><table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AL</td>
<td style="text-align:center">累加寄存器低位</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">CL</td>
<td style="text-align:center">计数寄存器低位</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">DL</td>
<td style="text-align:center">数据寄存器低位</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">BL</td>
<td style="text-align:center">基址寄存器低位</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">AH</td>
<td style="text-align:center">累加寄存器高位</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">CH</td>
<td style="text-align:center">计数寄存器高位</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">DH</td>
<td style="text-align:center">数据寄存器高位</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">BH</td>
<td style="text-align:center">基址寄存器高位</td>
</tr>
</tbody>
</table>
<p>SP、BP、SI、DI不分高位和低位。</p>
<h4 id="16位寄存器"><a href="#16位寄存器" class="headerlink" title="16位寄存器"></a>16位寄存器</h4><table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AX</td>
<td style="text-align:center">累加寄存器</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">CX</td>
<td style="text-align:center">计数寄存器</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">DX</td>
<td style="text-align:center">数据寄存器</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">BX</td>
<td style="text-align:center">基址寄存器</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">SP</td>
<td style="text-align:center">栈指针寄存器</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">BP</td>
<td style="text-align:center">基址指针寄存器</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">SI</td>
<td style="text-align:center">源变址寄存器</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">DI</td>
<td style="text-align:center">目的变址寄存器</td>
</tr>
</tbody>
</table>
<h4 id="32位寄存器"><a href="#32位寄存器" class="headerlink" title="32位寄存器"></a>32位寄存器</h4><p>EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI都是32位寄存器，但是低16位和对应的16位寄存器共用。如果使用高16位，则需要通过移位实现。</p>
<h4 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h4><table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ES</td>
<td style="text-align:center">附加段寄存器</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">CS</td>
<td style="text-align:center">代码段寄存器</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">SS</td>
<td style="text-align:center">栈段寄存器</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">DS</td>
<td style="text-align:center">数据段寄存器</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">FS</td>
<td style="text-align:center">-</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">GS</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong>在和C语言联合使用中，只有EAX、ECX、EDX这3个寄存器能自由使用，其他寄存器，只能使用其值，而不能修改值。</p>
<h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>‘ORG’: 指定文件装载到内存的地址，默认情况下从<code>0x</code>开始装载。内存<code>0x0000</code>用来存放BIOS不同功能程序，<code>0xf0000</code>用来存放BIOS程序本身。所以一般使用<code>0x7c00</code>-<code>0x7dff</code>用来存放启动区程序，这个位置起源于IBM。附近’$’的含义变为将要读入的内存地址。<br>‘JMP’: 跳转到指定的内存地址。<br>‘MOV’: 移动，类似于复制拷贝。<br>‘ADD’:<br>‘CMP’: 比较指令。<br>‘JE’: 条件跳转指令，根据CMP比较结果决定跳转或不跳转。<br>‘INT’: 软件中断指令。电脑主板ROM中通常写入一些经常用到的控制硬件的函数，INT就是用来调用其中函数的指令，通过不同的参数调用相应的函数来控制硬件的反应。例如：<code>INT 0x10</code>用来控制显卡显示字符。这块儿涉及到BIOS对寄存器的一些默认操作<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">显示1个字符：</span><br><span class="line">AH=0x0e</span><br><span class="line">AL=字符编码</span><br><span class="line">BH=0</span><br><span class="line">BL=字符颜色</span><br><span class="line">返回值：无</span><br><span class="line">注：</span><br><span class="line"></span><br><span class="line">设置显卡模式：</span><br><span class="line">AH=0x00</span><br><span class="line">AL=模式 0x03 0x12 0x13 0x6a</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure></p>
<p>‘HLT’: 停止CPU动作的指令，类似于待机/休眠状态，按下键盘、移动鼠标都会唤醒CPU。</p>
<h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h2><p>对BIOS有没有兴趣？哈哈，这块儿的资料实在太少了<br><a href="https://www.freebsd.org/doc/en_US.ISO8859-1/books/arch-handbook/boot-bios.html" target="_blank" rel="noopener">FreeBSD BIOS</a></p>
]]></content>
  </entry>
  <entry>
    <title>第一天</title>
    <url>/2020/10/01/os-01/</url>
    <content><![CDATA[<p>我真的是太喜欢操作系统了，尤其是从退出<code>vim</code>的那一刻起，可能越是得不到的越有味道吧。最开始接触手写操作系统是从《x86汇编语言:从实模式到保护模式》开始的，实操能力还是不太行，后来接触到《30天自制操作系统》，这本书主要是在win系统下实现，我现在想在Deepin上实践，就需要很多的魔改，也会对整个过程理解的更深刻。<br>大家都知道电脑上的系统从根本上还是基于一系列软件，安装在硬盘上。启动过程也是基于硬盘加载启动程序。而这个核心的存储区域就是”引导区”。有grub引导，UFEI引导。</p>
<p>学习系统的开始阶段的核心就是这个引导区。</p>
<a id="more"></a>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>第一天先打印一串’Hello World!’</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">; hello-os</span><br><span class="line">; TAB=<span class="number">4</span></span><br><span class="line"></span><br><span class="line">; 标准的FAT12格式软盘的专用代码</span><br><span class="line"></span><br><span class="line">    DB		<span class="number">0xeb</span>, <span class="number">0x4e</span>, <span class="number">0x90</span></span><br><span class="line">    DB		<span class="string">"HELLOIPL"</span>		; 启动区的名字，无实质作用，(必须是８字节)</span><br><span class="line">    DW		<span class="number">512</span>				; 指定每个扇区的大小(必须为<span class="number">512</span>字节)</span><br><span class="line">    DB		<span class="number">1</span>				; 簇的大小，必须为１个扇区</span><br><span class="line">    DW		<span class="number">1</span>				; FAT的起始位置</span><br><span class="line">    DB		<span class="number">2</span>				; FAT的个数[<span class="number">1</span>]</span><br><span class="line">    DW		<span class="number">224</span>				; 根目录大小[<span class="number">2</span>]</span><br><span class="line">    DW		<span class="number">2880</span>			; 磁盘的大小[<span class="number">3</span>]</span><br><span class="line">    DB		<span class="number">0xf0</span>			; 磁盘的种类[<span class="number">4</span>]</span><br><span class="line">    DW		<span class="number">9</span>				; FAT的长度[<span class="number">5</span>]</span><br><span class="line">    DW		<span class="number">18</span>				; 一个磁道有几个扇区</span><br><span class="line">    DW		<span class="number">2</span>				; 磁头数</span><br><span class="line">    DD		<span class="number">0</span>				; FAT12和FAT16为<span class="number">0</span>，FAT32时为扇区总数</span><br><span class="line">    DD		<span class="number">2880</span>			; 重写一次磁盘大小</span><br><span class="line">    DB		<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x29</span>		; 意义不明确[<span class="number">6</span>] Boot signature</span><br><span class="line">    DD		<span class="number">0xffffffff</span>		; 卷标号码[<span class="number">7</span>] Volume id</span><br><span class="line">    DB		<span class="string">"HELLO-OS   "</span>	; 磁盘的名称，必须是<span class="number">11</span>字节</span><br><span class="line">    DB		<span class="string">"FAT12   "</span>		; 磁盘格式名称，必须是<span class="number">8</span>字节[<span class="number">8</span>]</span><br><span class="line">    TIMES	<span class="number">18</span>    DB   <span class="number">0</span>	; 备用</span><br><span class="line"></span><br><span class="line">;　程序主体</span><br><span class="line"></span><br><span class="line">    DB		<span class="number">0xb8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x8e</span>, <span class="number">0xd0</span>, <span class="number">0xbc</span>, <span class="number">0x00</span>, <span class="number">0x7c</span></span><br><span class="line">    DB		<span class="number">0x8e</span>, <span class="number">0xd8</span>, <span class="number">0x8e</span>, <span class="number">0xc0</span>, <span class="number">0xbe</span>, <span class="number">0x74</span>, <span class="number">0x7c</span>, <span class="number">0x8a</span></span><br><span class="line">    DB		<span class="number">0x04</span>, <span class="number">0x83</span>, <span class="number">0xc6</span>, <span class="number">0x01</span>, <span class="number">0x3c</span>, <span class="number">0x00</span>, <span class="number">0x74</span>, <span class="number">0x09</span></span><br><span class="line">    DB		<span class="number">0xb4</span>, <span class="number">0x0e</span>, <span class="number">0xbb</span>, <span class="number">0x0f</span>, <span class="number">0x00</span>, <span class="number">0xcd</span>, <span class="number">0x10</span>, <span class="number">0xeb</span></span><br><span class="line">    DB		<span class="number">0xee</span>, <span class="number">0xf4</span>, <span class="number">0xeb</span>, <span class="number">0xfd</span></span><br><span class="line"></span><br><span class="line">;　信息显示部分</span><br><span class="line"></span><br><span class="line">    DB		<span class="number">0x0a</span>, <span class="number">0x0a</span>		;</span><br><span class="line">    DB		<span class="string">"hello, world"</span></span><br><span class="line">    DB		<span class="number">0x0a</span>			;</span><br><span class="line">    DB		<span class="number">0</span></span><br><span class="line">    TIMES	<span class="number">0x1fe</span>-($-$$) DB   <span class="number">0</span>			; 不到<span class="number">0x001fe</span>＝<span class="number">510</span>填充为<span class="number">0</span></span><br><span class="line">    DB		<span class="number">0x55</span>, <span class="number">0xaa</span>					；</span><br><span class="line"></span><br><span class="line">;　启动区之外的代码</span><br><span class="line"></span><br><span class="line">    DB		<span class="number">0xf0</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line">    TIMES	<span class="number">4600</span>   DB  <span class="number">0</span></span><br><span class="line">    DB		<span class="number">0xf0</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line">    TIMES	<span class="number">1469432</span>  DB  <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>看完这段代码，作为菜鸟的我有很多的问号，为什么有这些规定？</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="FAT12"><a href="#FAT12" class="headerlink" title="FAT12"></a>FAT12</h3><p>FAT(File Allocation Table): 软盘格式。FAT其实是一张存储在硬盘/软盘上的固定格式表。这张表可以认为是磁盘的’内容表’，如果这张表被损坏了，或者丢失了，那么磁盘就会变成不可读，这也就是有些时候需要进行格式化的原因。<br>FAT12：FAT2文件系统是软盘上的一个文件系统，这个数字12起源于FAT的entry是由12bit组成的。Windows和MS-DOS格式化软盘就是按照这种格式进行的。软盘由扇区构成，更大的存储设备中，许多扇区组成’簇’。而在软盘中每个簇只有一扇区。<br>一个完整的软盘格式主要由4部分组成，如下：<br><img src="https://impwang.oss-cn-beijing.aliyuncs.com/os/fat12.PNG" alt="FAT12"></p>
<h4 id="启动区-引导区"><a href="#启动区-引导区" class="headerlink" title="启动区/引导区"></a>启动区/引导区</h4><p>boot sector：软盘的的第一个扇区(sector)作为启动区。系统启动过程从第一个扇区开始读数据，检查第一个扇区最后的2个字节<code>55 AA</code>，如果正确则认为该扇区是<code>启动区</code>，如果不是<code>55 AA</code>就会报错无法启动，所以必须保证最后2个字节为正确的。<br>扇区：计算机以512 byte为单位读取，而不是以单字节为单位。512 byte就是一个扇区。<br><strong>注意：</strong></p>
<ol>
<li>目录名也可以有扩展符</li>
<li>“FILE1”和”FILE1.TXT”是一样的，扩展名不起作用</li>
<li>文件名和目录名不可以重复</li>
</ol>
<h4 id="FAT表"><a href="#FAT表" class="headerlink" title="FAT表"></a>FAT表</h4><p>FAT tables：FAT表包含了指向所有簇的指针、指向下一个簇的数量、链表簇的尾节点、一个簇是否为空、是否出错。而且是查找文件、目录位置的唯一方法。可以看到有2个FAT表，这是为了安全性、恢复磁盘而增加一个副本作为冗余。在软盘上，由于一个簇只有一个扇区，所以FAT entry指针指向磁盘中的每一个扇区。<br>以下是根据文件名转换为11字节的名称的例子：<br><figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">filename provided [<span class="number">01234567012</span>]</span><br><span class="line">• <span class="string">"foo.bar"</span>  -&gt; <span class="string">"FOO     BAR"</span></span><br><span class="line">• <span class="string">"FOO.BAR"</span>  -&gt; <span class="string">"FOO     BAR"</span></span><br><span class="line">• <span class="string">"Foo.Bar"</span>  -&gt; <span class="string">"FOO     BAR"</span></span><br><span class="line">• <span class="string">"foo"</span>      -&gt; <span class="string">"FOO        "</span></span><br><span class="line">• <span class="string">"foo."</span>     -&gt; <span class="string">"FOO        "</span></span><br><span class="line">• <span class="string">"PICKLE.A"</span> -&gt; <span class="string">"PICKLE A  "</span></span><br><span class="line">• <span class="string">"prettybg.big"</span> -&gt; <span class="string">"PRETTYBGBIG"</span></span><br><span class="line">• <span class="string">".big"</span> -&gt; illegal! file/directory names cannot <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">with</span> a <span class="string">"."</span></span><br></pre></td></tr></table></figure></p>
<p>逻辑扇区和物理扇区的换算公式：<br>$$<br>物理扇区数值 = 33 + FAT entry数值 - 2<br>$$</p>
<h4 id="根目录"><a href="#根目录" class="headerlink" title="根目录"></a>根目录</h4><p>根目录是磁盘的主要目录，不像磁盘的’Data area’可以无限扩展，根目录支持的大小有限，例如：FAT12格式，支持14*16=224个entry。<br>每个目录entry都包括了文件、子目录的信息：</p>
<p>存储结构：<br><img src="https://impwang.oss-cn-beijing.aliyuncs.com/os/fat-dir.PNG" alt="entry结构"><br>假如一个目录中存在’File1.txt’文件和’MyDir’目录，’File1.txt’的<code>Start Cluster</code>指向<code>FAT index</code>的扇区2，<code>FAT index</code>的扇区2指向<code>Data Area</code>的4。’File1.txt’的最后一个index为扇区7(EOC)。</p>
<h4 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a>数据区</h4><h4 id="启动程序加载器"><a href="#启动程序加载器" class="headerlink" title="启动程序加载器"></a>启动程序加载器</h4><p>IPL。启动区只有512字节，实际的操作系统，像Windows、Linux都远远超过了这个数量。所以完整的系统加载程序放在别的扇区，只把最开始的加载程序放在第一个扇区。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ol>
<li><p>为什么我们需要采用FAT12的格式？<br>目录的entry有一个叫<code>First Logical Cluster</code>的属性，它指定了文件、子目录的起始位置，一个目录可能是垮扇区存储在多个扇区的。这些扇区可能并不是存放在连续的内存中，FAT用来跟踪哪个扇区属于哪个文件。</p>
</li>
<li><p>有没有其它的替代格式？哪一种更好？</p>
</li>
</ol>
<h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>TIMES: 填充指定字节的’0’。<br>‘DB’: 填充1个字节。例如：<code>DB 0</code>会填充1个字节的’0’。<br>‘DW’: 填充1个字，等于2个字节。<br>‘DD’: 填充2个字，等于4个字节。<br>‘$’: 当前位置的字节地址。<br>‘$$’: 文件开始的字节地址。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.eit.lth.se/fileadmin/eit/courses/eitn50/Literature/fat12_description.pdf" target="_blank" rel="noopener">FAT12论文</a></p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解计算机系统--概览</title>
    <url>/2020/10/01/csapp-base/</url>
    <content><![CDATA[<p>2014年就接触CSAPP，一直拖一直拖，直到今天才决定完完整整深耕，并产生输出。无论什么原因吧，种一棵树的最好时机就是十年前，还有就是今天。</p>
<a id="more"></a>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="操作系统-1"><a href="#操作系统-1" class="headerlink" title="操作系统"></a>操作系统</h3><p>操作系统：处于应用程序和底层硬件之间，对应用程序提供API接口。例如Windows、Linux、MacOS等。</p>
<p>本质上，操作系统提供了两个主要的作用：</p>
<blockquote>
<p>防止硬件被应用程序随意调用<br>提供统一的接口。因为底层硬件商不同，内部实现也不一样，操作系统对所有的硬件提供一个统一的实现标准</p>
</blockquote>
<p>标准：<br>    Unix：贝尔实验室开发的一套系统<br>    Posix标准：IEEE为了规范Unix的开发，制定了一些标准。系统调用的C语言接口、shell程序、工具、线程、网络编程<br>    标准Unix规范：”标准Unix规范”工作组和Posix一起创建的Unix系统标准</p>
<p>而这两个功能其实是通过高级的抽象实现的:</p>
<blockquote>
<p>文件：对I/O设备的抽象<br>虚拟内存：对主存设备、I/O设备的抽象<br>进程：对处理器、主存设备、I/O设备的抽象</p>
</blockquote>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件：对I/O设备的抽象</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存：对主存、磁盘等I/O设备的抽象，和文件的描述存在交集，很难说谁包含谁</p>
<p>虚拟内存分为<br>内核虚拟内存：存储操作系统的代码和数据，对所有进程不可见<br>进程虚拟内存：存放所有进程信息</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程：对处理器、主存、磁盘I/O的抽象</p>
<p>进程是对操作系统中正在运行的程序的一种抽象。<br>计算机CPU分单核、多核，即使一个CPU，看起来好像并发执行多个进程，实际上内部是通过进程间切换实现的，即’上下文切换’</p>
<p>上下文：进程在运行状态下，操作系统会维护进程所有的信息(主存内容、寄存器文件的当前值)。进程各自的这些信息就是上下文。</p>
<p>上下文切换：每个CPU每个时刻只能有一个进程运行，把CPU的控制权交给别的进行，换取CPU的进程可以继续上次的执行，进程间运行的切换就是上下文切换</p>
<p>线程：一个进程可以由多个线程组成，每个线程运行在进程的上下文中，共享同样的代码和全局变量。</p>
<h4 id="并发、并行"><a href="#并发、并行" class="headerlink" title="并发、并行"></a>并发、并行</h4><p>并发运行：</p>
<p>并行运行：</p>
]]></content>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云机器翻译踩坑</title>
    <url>/2020/09/30/bug-alimt/</url>
    <content><![CDATA[<p>首先，必须吐槽一下阿里翻译文档写的太烂了。而且现在阿里云做的乱七八糟，什么东西都有，使用起来像狗屎一样难用。我觉得一切好用的都应该是’傻瓜式’的，不让用户去猜测你的意思。</p>
<a id="more"></a>
<p>使用阿里翻译基本上可以归纳为3个步骤：</p>
<ol>
<li>创建HttpClient</li>
<li>构建Request请求</li>
<li>请求后解析结果Response</li>
</ol>
<p>翻译分为普通版、专业版。给我的踩坑经历做一个总结：</p>
<h2 id="普通版"><a href="#普通版" class="headerlink" title="普通版"></a>普通版</h2><h3 id="CommonRequest"><a href="#CommonRequest" class="headerlink" title="CommonRequest"></a>CommonRequest</h3><p>使用CommonRequest请求。<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;AliCloudProperties.<span class="keyword">class</span>, AcmProperties.<span class="keyword">class</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliyunConfiguration</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> IAcsClient clientBean(AliCloudProperties aliyunProperties, AcmProperties acmProperties) &#123;</span><br><span class="line"></span><br><span class="line">    DefaultProfile profile = DefaultProfile.getProfile(</span><br><span class="line">        acmProperties.getEndpoint(),   <span class="comment">// 这里其实应该是RegionId</span></span><br><span class="line">        aliyunProperties.getAccessKey(),</span><br><span class="line">        aliyunProperties.getSecretKey());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultAcsClient(profile);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造request<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造请求</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public static CommonRequest build<span class="constructor">Request(String <span class="params">str</span>)</span> &#123;</span><br><span class="line">  CommonRequest request = <span class="keyword">new</span> <span class="constructor">CommonRequest()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">StringUtils</span>.</span></span>is<span class="constructor">Blank(<span class="params">str</span>)</span>) &#123;</span><br><span class="line">    return request;</span><br><span class="line">  &#125;</span><br><span class="line">  request.set<span class="constructor">SysMethod(MethodType.POST)</span>;</span><br><span class="line">  request.set<span class="constructor">SysDomain(<span class="string">"mt.cn-hangzhou.aliyuncs.com"</span>)</span>;</span><br><span class="line">  request.set<span class="constructor">SysVersion(<span class="string">"2020-09-29"</span>)</span>;</span><br><span class="line">  request.set<span class="constructor">SysAction(<span class="string">"TranslateGeneral"</span>)</span>;</span><br><span class="line"></span><br><span class="line">  request.put<span class="constructor">QueryParameter(<span class="string">"FormatType"</span>, <span class="string">"text"</span>)</span>;</span><br><span class="line">  request.put<span class="constructor">QueryParameter(<span class="string">"Scene"</span>, <span class="string">"general"</span>)</span>;</span><br><span class="line">  request.put<span class="constructor">QueryParameter(<span class="string">"SourceLanguage"</span>, <span class="string">"zh"</span>)</span>;</span><br><span class="line">  request.put<span class="constructor">QueryParameter(<span class="string">"SourceText"</span>, <span class="params">str</span>)</span>;</span><br><span class="line">  request.put<span class="constructor">QueryParameter(<span class="string">"TargetLanguage"</span>, <span class="string">"en"</span>)</span>;</span><br><span class="line"></span><br><span class="line">  return request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用请求，这种方式返回String字符串，是需要手动去解析的。<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public String translate<span class="constructor">WithAuto(String <span class="params">str</span>)</span> &#123;</span><br><span class="line">  CommonRequest request = <span class="module-access"><span class="module"><span class="identifier">AliyunUtils</span>.</span></span>build<span class="constructor">Request(<span class="params">str</span>)</span>;</span><br><span class="line">  String res = str;</span><br><span class="line">  Gson gson = <span class="keyword">new</span> <span class="constructor">Gson()</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    log.info(<span class="string">"aliyun trans request: &#123;&#125;"</span>, gson.<span class="keyword">to</span><span class="constructor">Json(<span class="params">request</span>)</span>);</span><br><span class="line"></span><br><span class="line">    CommonResponse response = client.get<span class="constructor">CommonResponse(<span class="params">request</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (null != response &amp;&amp;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">TRANS_SUCCESS</span>.</span></span>equals(response.get<span class="constructor">HttpStatus()</span>)) &#123;</span><br><span class="line">      String responseStr = response.get<span class="constructor">Data()</span>;</span><br><span class="line">      TranslateRes translateRes = gson.from<span class="constructor">Json(<span class="params">responseStr</span>, TranslateRes.<span class="params">class</span>)</span>;</span><br><span class="line">      res = translateRes.get<span class="constructor">Data()</span>.get<span class="constructor">Translated()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">"aliyun trans response: &#123;&#125;"</span>, gson.<span class="keyword">to</span><span class="constructor">Json(<span class="params">response</span>)</span>);</span><br><span class="line">  &#125; catch (ClientException e) &#123;</span><br><span class="line">    e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="TranslateGeneralRequest"><a href="#TranslateGeneralRequest" class="headerlink" title="TranslateGeneralRequest"></a>TranslateGeneralRequest</h3><p>遇到2个错误：</p>
<ol>
<li><p>解析错误</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">com.aliyuncs.exceptions.ClientException: SDK.EndpointResolvingError<span class="keyword"> :</span> No such region 'acm.aliyun.com'. Please<span class="built_in"> check </span>your region ID.</span><br></pre></td></tr></table></figure>
<p>找了一堆文档，还是不行，换成<code>cn-hangzhou</code>继续报错参数错误。</p>
</li>
<li><p>10004 参数错误</p>
</li>
</ol>
<p><strong>阿里云机器翻译组，我操你妈！一群傻逼！</strong>怒转专业版。</p>
<h2 id="专业版"><a href="#专业版" class="headerlink" title="专业版"></a>专业版</h2><p>构造client客户端<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;AliCloudProperties.<span class="keyword">class</span>, AcmProperties.<span class="keyword">class</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliyunConfiguration</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> IAcsClient clientBean(AliCloudProperties aliyunProperties, AcmProperties acmProperties) &#123;</span><br><span class="line"></span><br><span class="line">    DefaultProfile profile = DefaultProfile.getProfile(</span><br><span class="line">        <span class="string">"cn-hangzhou"</span>,</span><br><span class="line">        aliyunProperties.getAccessKey(),</span><br><span class="line">        aliyunProperties.getSecretKey());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultAcsClient(profile);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造请求体<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static TranslateECommerceRequest      build<span class="constructor">ECommerceRequest(String <span class="params">str</span>, String <span class="params">scene</span>)</span> &#123;</span><br><span class="line">  TranslateECommerceRequest eCommerceRequest = <span class="keyword">new</span> <span class="constructor">TranslateECommerceRequest()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">StringUtils</span>.</span></span>is<span class="constructor">Blank(<span class="params">str</span>)</span></span><br><span class="line"><span class="operator">    || </span><span class="module-access"><span class="module"><span class="identifier">StringUtils</span>.</span></span>is<span class="constructor">Blank(<span class="params">scene</span>)</span>) &#123;</span><br><span class="line">    return eCommerceRequest;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  eCommerceRequest.set<span class="constructor">Scene(<span class="params">scene</span>)</span>;</span><br><span class="line">  eCommerceRequest.set<span class="constructor">FormatType(<span class="string">"text"</span>)</span>;</span><br><span class="line">  eCommerceRequest.set<span class="constructor">SourceLanguage(SOURCE_LANGUAGE)</span>;</span><br><span class="line">  eCommerceRequest.set<span class="constructor">SourceText(<span class="params">str</span>.<span class="params">trim</span>()</span>);</span><br><span class="line">  eCommerceRequest.set<span class="constructor">TargetLanguage(TARGET_LANGUAGE)</span>;</span><br><span class="line"></span><br><span class="line">  return eCommerceRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用请求<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public String translate<span class="constructor">WithAuto(String <span class="params">str</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">StringUtils</span>.</span></span>is<span class="constructor">Blank(<span class="params">str</span>)</span>) &#123;</span><br><span class="line">    return str;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String res = str;</span><br><span class="line">  Gson gson = <span class="keyword">new</span> <span class="constructor">Gson()</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    TranslateECommerceRequest request = AliyunUtils</span><br><span class="line">        .build<span class="constructor">ECommerceRequest(<span class="params">str</span>, TranslateEnum.TITLE.<span class="params">getCode</span>()</span>);</span><br><span class="line">    log.info(<span class="string">"aliyun trans request: &#123;&#125;"</span>, gson.<span class="keyword">to</span><span class="constructor">Json(<span class="params">request</span>)</span>);</span><br><span class="line"></span><br><span class="line">    TranslateECommerceResponse response = client.get<span class="constructor">AcsResponse(<span class="params">request</span>)</span>;</span><br><span class="line">    log.info(<span class="string">"aliyun trans response: &#123;&#125;"</span>, gson.<span class="keyword">to</span><span class="constructor">Json(<span class="params">response</span>)</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">TRANS_SUCCESS</span>.</span></span>equals(response.get<span class="constructor">Code()</span>)) &#123;</span><br><span class="line">      Data data = response.get<span class="constructor">Data()</span>;</span><br><span class="line">      res = data.get<span class="constructor">Translated()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; catch (ClientException e) &#123;</span><br><span class="line">    e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>终于成功了，我操你妈！</p>
]]></content>
  </entry>
  <entry>
    <title>Hash算法求固定值</title>
    <url>/2020/09/19/math-hash/</url>
    <content><![CDATA[<p>昨天在工作中遇到一个问题，大致场景是这样的：</p>
<ol>
<li>对象包括id(固定)、total、count(递增)</li>
<li>不同的对象根据count求出指定范围内的固定随机值mock</li>
<li>该值需要满足一下条件：<blockquote>
<p>每个对象在第一次随机后每次该随机值mock不变<br>不同的对象计算第一次随机值后，如果count、total不变，mock值不变<br>不同对象的mock值在total的0.1～0.5内浮动</p>
</blockquote>
</li>
</ol>
<p>当时只能想到怎么用Random来做，毫无思路。组长10分钟内连测试用例都验证过了。这算是真实感受到智商的暴击和数学的用处。直接上代码</p>
<a id="more"></a>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> static <span class="built_in">int</span> mock(String id, <span class="built_in">int</span> <span class="built_in">count</span>, <span class="built_in">int</span> total) &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">min</span> = <span class="keyword">Integer</span>.<span class="built_in">max</span>(total / <span class="number">9</span> - <span class="built_in">count</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">max</span> = <span class="keyword">Integer</span>.<span class="built_in">max</span>(total - <span class="built_in">count</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">max</span> &lt;= <span class="built_in">min</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">count</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> mock = Math.<span class="built_in">abs</span>(id.hashCode()) % <span class="number">100</span> * (<span class="built_in">max</span> - <span class="built_in">min</span>) / <span class="number">100</span> + <span class="built_in">min</span>;</span><br><span class="line">    <span class="keyword">return</span> mock + <span class="built_in">count</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>思路：<br>$$</p>
<p>$$</p>
]]></content>
  </entry>
  <entry>
    <title>Elasticsearch环境(一)</title>
    <url>/2020/09/10/elastic-base/</url>
    <content><![CDATA[<p>2017年接触过一些ELK环境的搭建，用来处理日志信息，涉及到的东西很多，最近重新使用，对一些存储、索引更有兴趣。</p>
<a id="more"></a>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>依赖于JDK，对jdk版本、内存有要求，否则会启动失败</p>
<h3 id="tar-gz安装"><a href="#tar-gz安装" class="headerlink" title="tar.gz安装"></a>tar.gz安装</h3><p>需要创建用户组、用户、非root用户启动</p>
<h3 id="rpm安装"><a href="#rpm安装" class="headerlink" title="rpm安装"></a>rpm安装</h3><ol>
<li>直接安装，默认创建用户组<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">rpm</span> <span class="selector-tag">-ivh</span> <span class="selector-tag">elasticsearch-6</span><span class="selector-class">.4</span><span class="selector-class">.0</span><span class="selector-class">.rpm</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>提示<br><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">正在升级/安装...</span><br><span class="line">	<span class="number">1</span>:elasticsearch<span class="number">-0</span>:<span class="number">6.4</span><span class="number">.0</span><span class="number">-1</span>          ################################# [<span class="number">100</span>%]</span><br><span class="line">### NOT starting on installation, please execute the following statements to configure elasticsearch service to start automatically using systemd</span><br><span class="line">	sudo systemctl daemon-reload</span><br><span class="line">	sudo systemctl enable elasticsearch.service</span><br><span class="line">### You can start elasticsearch service by executing</span><br><span class="line">	sudo systemctl start elasticsearch.service</span><br><span class="line">Created elasticsearch keystore <span class="keyword">in</span> /etc/elasticsearch</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li><p>修改配置文件，配置文件一般存放在/etc/elasticsearch目录下</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">vi</span> <span class="selector-tag">elasticsearch</span><span class="selector-class">.yml</span></span><br><span class="line"># 开启远程访问</span><br><span class="line"><span class="selector-tag">network</span><span class="selector-class">.host</span> 0<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.0</span></span><br><span class="line"># 修改端口</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务，设置开机自启动</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">sudo</span> <span class="string">systemctl daemon-reload</span></span><br><span class="line"><span class="attr">sudo</span> <span class="string">systemctl enable elasticsearch.service</span></span><br><span class="line"><span class="attr">sudo</span> <span class="string">systemctl start elasticsearch.service</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试启动状态</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">netstat -lntp <span class="string">| grep -E "</span><span class="number">9200</span><span class="string">|9300"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看版本，检验是否安装成功</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">curl -XGET localhost:<span class="number">9200</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>命令格式<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">curl -X&lt;REST Verb&gt; &lt;Node&gt;<span class="symbol">:&lt;Port&gt;/&lt;Index&gt;/&lt;Type&gt;/&lt;ID&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>参数：<br>REST Verb：REST风格的语法谓词<br>Node:节点ip<br>Port:节点端口号，默认9200<br>Index:索引名<br>Type:索引类型<br>ID:操作对象的ID号</p>
<p>查看健康状态<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">curl <span class="string">'localhost:9200/_cat/health?v'</span></span><br><span class="line">epoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent</span><br><span class="line"><span class="number">1535546872</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">52</span>  elasticsearch yellow          <span class="number">1</span>         <span class="number">1</span>      <span class="number">5</span>   <span class="number">5</span>    <span class="number">0</span>    <span class="number">0</span>        <span class="number">5</span>             <span class="number">0</span>                  -                 <span class="number">50.0</span>%</span><br></pre></td></tr></table></figure></p>
<p>查看节点列表<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">curl <span class="string">'localhost:9200/_cat/nodes?v'</span></span><br><span class="line">ip              heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name</span><br><span class="line"><span class="number">192.168</span><span class="number">.117</span><span class="number">.133</span>           <span class="number">22</span>          <span class="number">32</span>   <span class="number">2</span>    <span class="number">0.00</span>    <span class="number">0.02</span>     <span class="number">0.05</span> mdi       *      M48aNzY</span><br></pre></td></tr></table></figure></p>
<p>查看索引列表<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">curl <span class="string">'localhost:9200/_cat/indices?v'</span></span><br><span class="line">health status index    uuid                   pri rep docs<span class="selector-class">.count</span> docs<span class="selector-class">.deleted</span> store<span class="selector-class">.size</span> pri<span class="selector-class">.store</span><span class="selector-class">.size</span></span><br><span class="line">yellow open   customer FWs0PsZ0QAOJZ0W6l-HhLA   <span class="number">5</span>   <span class="number">1</span>          <span class="number">0</span>            <span class="number">0</span>      <span class="number">1.2</span>kb          <span class="number">1.2</span>kb</span><br></pre></td></tr></table></figure></p>
<p>创建索引<br><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">curl -XPUT <span class="symbol">'localhost</span>:<span class="number">9200</span>/customer?pretty'</span><br><span class="line"></span><br><span class="line">curl -XPUT <span class="symbol">'localhost</span>:<span class="number">9200</span>/customer/external/<span class="number">1</span>?pretty' -d '&#123;<span class="string">"name"</span>: <span class="string">"John Doe"</span>&#125;' </span><br><span class="line"></span><br><span class="line">curl -H <span class="string">"Content-Type: application/json"</span> -XPOST http://localhost:<span class="number">9200</span>/kiwi/ksay/ -d '&#123; <span class="string">"author"</span>: <span class="string">"rococojie"</span>, <span class="string">"message"</span>: <span class="string">"I am beautiful"</span>&#125;'</span><br><span class="line"></span><br><span class="line">curl -H <span class="string">"Content-Type: application/json"</span> -XPOST http://localhost:<span class="number">9200</span>/kiwi/ksay/<span class="number">1</span> -d '&#123;<span class="string">"author"</span>: <span class="string">"jerry"</span>, <span class="string">"message"</span>: <span class="string">"I hate Tom"</span>&#125;'</span><br></pre></td></tr></table></figure></p>
<p>删除索引<br><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">curl -XDELETE 'localhost:<span class="number">9200</span>/customer?pretty'</span><br></pre></td></tr></table></figure></p>
<p>修改索引<br><figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line">curl -XPUT <span class="string">'localhost:9200/customer/external/1?pretty'</span> -d <span class="string">'&#123;"</span>name<span class="string">": "</span>John Doe<span class="string">"&#125;'</span></span><br><span class="line"></span><br><span class="line">curl -XPOST <span class="string">'localhost:9200/customer/external/1/_update?pretty'</span> -d <span class="string">'&#123;"</span>doc<span class="string">": &#123; "</span>name<span class="string">": "</span>Jane Doe<span class="string">" &#125;&#125;'</span></span><br></pre></td></tr></table></figure></p>
<p>获取指定索引<br><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">curl -XGET 'localhost:<span class="number">9200</span>/customer/external/1?pretty'</span><br></pre></td></tr></table></figure></p>
<p>如果想通过远程浏览器访问，需要修改<code>elasticsearch.yml</code>文件。rpm安装的elasticsearch.yml存放在<code>/etc/elasticsearch/</code>文件夹下。如果找不到，可以通过<code>rpm -ql elasticsearch</code>查找。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">network</span><span class="selector-class">.host</span> 0<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.0</span></span><br></pre></td></tr></table></figure></p>
<p>web界面化管理可以使用GitHub上开源的elasticsearch-head。</p>
<h3 id="结合Kibana使用"><a href="#结合Kibana使用" class="headerlink" title="结合Kibana使用"></a>结合Kibana使用</h3><p>kibana的安装非常简单，下载启动即可</p>
<ol>
<li><p>下载</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget https:<span class="regexp">//</span>artifacts.elastic.co<span class="regexp">/downloads/</span>kibana<span class="regexp">/kibana-6.4.0-linux-x86_64.tar.gz</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">vi <span class="built_in">config</span>/kibana.yml</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问’localhost:5601’使用kibana</p>
</li>
</ol>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我个人的理解ES和MySQL的大致原理类似，无非都是对数据的存储，无非是基于内存模式，索引分析更快，更适用于全文搜索。</p>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>_index<br>_type<br>_id<br>_uid<br>索引的核心就是<code>类型映射</code>和<code>分析器</code>，在POST插入数据时es会默认创建索引，如果禁用默认，可以通过配置<code>elasticsearch.yml</code>。如果需要自定义分析器、字段属性的类型映射则需要手动创建索引。<br><strong>注意:<code>DELETE /_all</code>和<code>DELETE /*</code>会删除所有数据，可以通过<code>elasticsearch.yml</code>禁用</strong></p>
<p>索引格式：<br><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">PUT /index_test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">        <span class="string">"number_of_shards"</span>:   <span class="number">1</span>,    <span class="meta"># 每个索引的主分片数，默认是5</span></span><br><span class="line">        <span class="string">"number_of_replicas"</span>: <span class="number">0</span>		<span class="meta"># 每个主分片的副本数，默认是1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="静态索引"><a href="#静态索引" class="headerlink" title="静态索引"></a>静态索引</h4><h4 id="动态索引"><a href="#动态索引" class="headerlink" title="动态索引"></a>动态索引</h4><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>分析器主要包括3种类型的函数：</p>
<ol>
<li>字符过滤器：</li>
<li>分词器：。例如：关键词分词器、空格分词器、正则分词器</li>
<li>词汇单元过滤器：例如：词干过滤器、<br>一个分析器可以有0个或者多个字符过滤器，但必须有一个唯一的分词器，</li>
</ol>
<h4 id="内置分析器"><a href="#内置分析器" class="headerlink" title="内置分析器"></a>内置分析器</h4><p>standard分析器</p>
<ol>
<li>standard分词器。</li>
<li>standard语义单元过滤器。</li>
<li>lowercase语汇单元过滤器。</li>
<li>stop语汇单元过滤器。</li>
</ol>
<h4 id="自定义分析器"><a href="#自定义分析器" class="headerlink" title="自定义分析器"></a>自定义分析器</h4><p>例如：对index_test索引自定义一个名为analyzer_custom的分析器<br><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUT</span> /analyzer_test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">        <span class="string">"analysis"</span>: &#123;</span><br><span class="line">            <span class="string">"char_filter"</span>: &#123;</span><br><span class="line">                <span class="string">"&amp;_to_and"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>: <span class="string">"mapping"</span>,</span><br><span class="line">                    <span class="string">"mappings"</span>: [</span><br><span class="line">                        <span class="string">"&amp;=&gt; and "</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"filter"</span>: &#123;</span><br><span class="line">                <span class="string">"my_stopwords"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>: <span class="string">"stop"</span>,</span><br><span class="line">                    <span class="string">"stopwords"</span>: [</span><br><span class="line">                        <span class="string">"the"</span>,</span><br><span class="line">                        <span class="string">"a"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="string">"analyzer_custom"</span>: &#123;</span><br><span class="line">                    <span class="string">"type"</span>: <span class="string">"custom"</span>,</span><br><span class="line">                    <span class="string">"char_filter"</span>: [</span><br><span class="line">                        <span class="string">"html_strip"</span>,</span><br><span class="line">                        <span class="string">"&amp;_to_and"</span></span><br><span class="line">                    ],</span><br><span class="line">                    <span class="string">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">                    <span class="string">"filter"</span>: [</span><br><span class="line">                        <span class="string">"lowercase"</span>,</span><br><span class="line">                        <span class="string">"my_stopwords"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">测试</span><br></pre></td></tr></table></figure></p>
<p>可以在索引上使用分析器<br><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="type">PUT</span> /my_index/_mapping/my_<span class="keyword">type</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"properties"</span>: &#123;</span><br><span class="line">        <span class="string">"title"</span>: &#123;</span><br><span class="line">            <span class="string">"type"</span>:      <span class="string">"string"</span>,</span><br><span class="line">            <span class="string">"analyzer"</span>:  <span class="string">"analyzer_custom"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="类型和映射"><a href="#类型和映射" class="headerlink" title="类型和映射"></a>类型和映射</h3><p>默认情况下，一个索引中的所有类型共享相同的字段和设置。例如：<code>/index_test/blog</code>和<code>/index_test/user</code>可以共享。<br>例如：索引data创建people类型的映射<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PUT</span> /</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"data"</span>: &#123;</span><br><span class="line">      <span class="string">"mappings"</span>: &#123;</span><br><span class="line">         <span class="string">"people"</span>: &#123;</span><br><span class="line">            <span class="string">"properties"</span>: &#123;</span><br><span class="line">               <span class="string">"name"</span>: &#123;</span><br><span class="line">                  <span class="string">"type"</span>: <span class="string">"string"</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="string">"address"</span>: &#123;</span><br><span class="line">                  <span class="string">"type"</span>: <span class="string">"string"</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="根对象"><a href="#根对象" class="headerlink" title="根对象"></a>根对象</h4><p>映射是一种层级结构，最高一层称为<code>根对象</code>，<br>属性<br><code>properties</code>包含所有的字段，每个字段设置包括：</p>
<ol>
<li>type</li>
<li>index</li>
<li>analyzer</li>
</ol>
<p>元数据<br><code>_source</code>用来存储数据记录。查询请求时可以通过<code>_source</code>指定特定字段只返回需要的字段。否则返回全部字段。也可以通过在设置映射时<strong>禁用_source</strong></p>
<h3 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h3><p>在索引文档中添加属性时，索引遇到不认识的字段<strong>默认</strong>会自动创建映射。可以通过设置动态映射<code>&quot;dynamic&quot;: &quot;strict&quot;</code>修改级别。<br>true: 新字段添加映射<br>false: 忽略新字段，但是在<code>_source</code>存储。<br>strict: 对新字段抛出异常。<br>动态模板<br>新增加的字段会使用默认的映射规则，也可以通过设置<code>dynamic_templates</code>自定义动态映射。</p>
<h4 id="嵌套映射"><a href="#嵌套映射" class="headerlink" title="嵌套映射"></a>嵌套映射</h4><h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><h4 id="全字段搜索"><a href="#全字段搜索" class="headerlink" title="全字段搜索"></a>全字段搜索</h4><p><code>_all</code>代表匹配全部字段。如果不需要，也可以通过在映射中设置<strong>禁用</strong>。也可以在单独的字段上设置<code>&quot;include_in_all&quot;: true</code>只针对个别字段全局过滤。</p>
<h4 id="得分"><a href="#得分" class="headerlink" title="得分"></a>得分</h4><p><code>_score</code>表示相关性评分，用来表示匹配的相关性。<br>fuzzy查询<br>term查询<br>terms查询</p>
<h4 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h4><p>ES也有类似于MySQL执行计划的explain命令，可以对查询路径进行分析。<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /_search?<span class="attribute">explain</span>=<span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"query"</span>   : &#123; </span><br><span class="line">     <span class="string">"match"</span> : &#123; </span><br><span class="line">       <span class="string">"title"</span> : <span class="string">"wangsir blog"</span> </span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-base</title>
    <url>/2020/09/09/rust-base/</url>
    <content><![CDATA[<h3 id="修改镜像源"><a href="#修改镜像源" class="headerlink" title="修改镜像源"></a>修改镜像源</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vi <span class="variable">$HOME</span><span class="regexp">/.cargo/</span>config</span><br></pre></td></tr></table></figure>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[source.crates-io]</span></span><br><span class="line"><span class="attr">registry</span> = <span class="string">"https://github.com/rust-lang/crates.io-index"</span></span><br><span class="line"><span class="attr">replace-with</span> = <span class="string">'ustc'</span></span><br><span class="line"><span class="section">[source.ustc]</span></span><br><span class="line"><span class="attr">registry</span> = <span class="string">"git://mirrors.ustc.edu.cn/crates.io-index"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">cargo <span class="keyword">build</span> --examples</span><br><span class="line">error: failed <span class="keyword">to</span> <span class="keyword">parse</span> manifest at <span class="symbol">`E:\workspace\OpenSource\quiche\Cargo.toml`</span></span><br><span class="line"></span><br><span class="line">Caused <span class="keyword">by</span>:</span><br><span class="line">  editions are unstable</span><br><span class="line"></span><br><span class="line">Caused <span class="keyword">by</span>:</span><br><span class="line">  feature <span class="symbol">`edition`</span> <span class="keyword">is</span> required</span><br><span class="line"></span><br><span class="line">this Cargo does <span class="keyword">not</span> support nightly features, but <span class="keyword">if</span> you</span><br><span class="line">switch <span class="keyword">to</span> nightly channel you can add</span><br><span class="line"><span class="symbol">`cargo-features = ["edition"]`</span> <span class="keyword">to</span> enable this feature</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>QUIC协议在Uber的实践(译)</title>
    <url>/2020/09/06/net-quic-uber/</url>
    <content><![CDATA[<p><a href="https://eng.uber.com/employing-quic-protocol/" target="_blank" rel="noopener">原文</a></p>
<p>Uber对全球600多个城市的4500名手机用户做了调查，这些手机全部通过无线连接。为了实现实时的性能，App要求低延迟、高可用的网络通信。在动态的、损失率高的网络环境下，HTTP/2表现较差，最后我们追踪到性能差的主要原因还是基于系统实现的TCP比较差。<br>为了定位痛点，我们开始尝试使用QUIC协议，QUIC是一种基于UDP实现的流通信协议，我们可以更好的控制传输协议性能，现在已经被IETF采纳为HTTP/3协议标准。<br>在测试QUIC后，我们发现在App中整合QUIC相比原来的TCP可以降低末端延迟。可以确定在基于HTTPS的rider/driver apps中可以带来10-30%的延迟。除了在低延迟上的性能表现，QUIC提供了<code>packets流</code>端到端(end-to-end)的控制，这是基于用户空间层面的<br><a id="more"></a></p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>在今天的网络中，TCP仍然是HTTPS通信中最广泛使用的通信协议。TCP提供了一种可信的字节流，解决了网络拥塞的复杂性、链路层丢失的问题。HTTPS广泛使用TCP主要还是因为TCP几乎存在于每一个保护TCP协议的系统中，例如负载均衡、HTTPS代理、CDNs，而且TCP在大多数平台、网络中都是开箱即用的。<br>我们的用户在使用Uber过程中位置是动态的，基于TCP的末端延迟很难满足HTTPS的实时特性。</p>
<h3 id="基于无线网络的TCP"><a href="#基于无线网络的TCP" class="headerlink" title="基于无线网络的TCP"></a>基于无线网络的TCP</h3><p>TCP最开始是为有线网络设计的，有高可预见的连接。然而无线网络有独特的特性和挑战。</p>
<ol>
<li>首先，由于干扰、信号衰减，无线网很容易丢失信号。这些都会导致RTTs更高或者变化、丢包。例如：WiFi很容易被微波、蓝牙、其他类型的信号波干扰。蜂窝网因为周围环境建筑物、干扰、附近基站的影响，很容易丢失信号</li>
<li>为了在宽带和丢包中解决间歇的网络抖动问题，蜂窝网使用了更大的缓冲来接收突发流量。更大的buffer导致排队，结果是更长的延迟。由于超时，TCP通常把队列这种情况认为丢失，接着需要重传直到buffer继续被填满，这种问题称为缓存溢出<code>bufferbloat</code>。</li>
<li>蜂窝网性能不同的用户、不同区域、不同时间也不一样。<br><strong>这个地方图片就不展示了，大家都体验过</strong><br>以上这些问题都归结于TCP的低效性，在深入理解TCP之前，我们先思考以下3个问题：</li>
<li>TCP是手机端用户末端延迟的主要原因吗？</li>
<li>目前网络RTT、丢包是否变化很大？</li>
<li>什么因素对TCP中RTT变化、丢包影响较大？</li>
</ol>
<h3 id="TCP性能分析"><a href="#TCP性能分析" class="headerlink" title="TCP性能分析"></a>TCP性能分析</h3><p>为了更好地理解我们是怎么分析TCP性能的，首先简单介绍以下TCP通信过程：</p>
<ol>
<li>首先，发送端建立三次握手</li>
<li>建立TLS连接：2-3个的round trips</li>
</ol>
<p><img src="https://impwang.oss-cn-beijing.aliyuncs.com/net/tcp-1.png" alt="tcp"><br>在这种情况下，packet丢失、或者ACK丢失，重传机制超时(RTO)后，发送端发起重传，RTO是根据不同的因素动态计算的：发送端和接收端的RTT估值。<br>为了分析TCP性能，我们使用tcpdump收集了印度市场一周内的网络连接情况，然后使用tcptrace进行了分析。除此之外，我们使用app发送请求到测试环境模拟了真实的情况，同时打印上传日志到服务器，然后部署到印度的应用市场。<br>无论是tapdump分析，还是日志分析，这两种分析结果都是一致的。RTT值、末端延迟几乎是中值的6倍，中值比平均值多1s。除此之外，包丢失严重，导致3.5%的重传率。在用户多的地方，丢失率甚至达到7%，例如火车站、机场。<br>相比数据包，对重传SYN、SYN-ACK包，TCP使用了非常保守的RTO值。大多数TCP都使用RTO=1s的初始值，随着包丢失的问题RTO以指数级增长。<br>数据包传输时，在无线网络下，更高的RTO导致网络可用时间更少。我们发现平均重传时间大约是1s，末端时间甚至可以达到30s，这种高延迟导致HTTPS超时、重试，从而导致更大的延迟，恶性循环。</p>
<h2 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h2><p>基于QUIC的HTTP/2被定义为HTTP/3，她取代了HTTPS和TCP协议栈中的一些层，而且QUIC只支持安全数据传输，TLS协议被完全嵌套在QUIC协议中。<br><img src="https://impwang.oss-cn-beijing.aliyuncs.com/net/quic-1.png" alt="QUIC"></p>
<p>以下就是为什么我们非常强烈的想要在TCP之外引入QUIC的特性：</p>
<ol>
<li>0-RTT建立连接。QUIC允许复用建立在之前连接上的安全认证，在第一个round trip过程就可以发送数据，减少了安全连接握手过程。未来，TLS1.3也会支持0-RTT，但是仍然需要TCP的三次握手。</li>
<li>解决头阻塞问题。HTTP/2针对每个origin使用单个TCP连接来提升性能。但是会导致头阻塞(head-of-line blocking)问题。例如：object A被object B阻塞，A已经丢失，B需要等待A被恢复后进行传输。然而，QUIC每个请求的传输是独立的。</li>
<li>拥塞控制。QUIC是应用层协议，可以更方便的更新核心算法，大多数TCP都使用CUBIC算法，这种算法不适用对延迟敏感的流量。最近开发的BBR算法，更精确，也优化了延迟。QUIC可以让我们随时启用BBR、更新核心算法。</li>
<li>丢失恢复。在RTO被触发之前，即使很明显的丢失，QUIC仍然会发起2次丢失探针(TLP tail loss probes)，这种方式不同于TCP的实现。TLP重传丢失前最后的packet触发快速恢复机制。</li>
<li>优化ACK机制。QUIC中每个packet都携带唯一的序列号，这就解决了区分重传包和延迟包的问题。ACK packet也包括了处理这个packet的时间、在客户端生成该packet的时间。这些因素可以确保QUIC更精确的估算RTT时间。QUIC ACK支持存储256个NACK，帮助发送端更好的执行packet重排序。TCP中的SACK(Selective ACK)没有解决这个问题。</li>
<li>连接转移。QUIC连接是通过<code>connection ID</code>来标识的。不同于原来的四元组(源IP, 源Port, 目标IP, 目标Port)。这样，当客户端改变了IP地址后，请求不会中断，新的IP地址仍然可以使用旧的<code>connection ID</code>。对于移动端用户来说这是一种很常见的行为。</li>
</ol>
<h3 id="QUIC选型的思考"><a href="#QUIC选型的思考" class="headerlink" title="QUIC选型的思考"></a>QUIC选型的思考</h3><p>在确定QUIC之前，我们调研了很多方案来提升TCP性能：</p>
<ol>
<li>首先，我们尝试了TCP PoPs(Points of Presence)。发现没有明显的性能提升。</li>
<li>然后，我们尝试调整TCP参数。在异构服务系统中调整TCP协议栈参数是非常有挑战性的，而且TCP在跨系统 版本中有不同的实现。也很难应用、检验不同的配置。在用户端调整TCP配置更是几乎不可能。尤其像0-RTT这种协议设计的核心几乎不可能通过简单的调参实现提升。</li>
<li>最后我们评估了一些基于UDP的协议查看是否对我们的应用有用。但是她们缺少工业级的安全特性。而QUIC兼顾了安全、性能。</li>
</ol>
<h3 id="QUIC在Uber平台的整合"><a href="#QUIC在Uber平台的整合" class="headerlink" title="QUIC在Uber平台的整合"></a>QUIC在Uber平台的整合</h3><h3 id="QUIC在Google-Cloud-Load-Balancers的开关"><a href="#QUIC在Google-Cloud-Load-Balancers的开关" class="headerlink" title="QUIC在Google Cloud Load Balancers的开关"></a>QUIC在Google Cloud Load Balancers的开关</h3><p>谷歌云负载均衡在response中添加了<code>alt-svc</code>头来支持QUIC。在每个HTTP response中，负载均衡组件都添加了<code>alt-svc</code>头验证是否支持QUIC，客户端收到携带<code>alt-svc</code>头的response后，接下来所有的HTTP请求使用QUIC。一旦负载均衡组件关闭了QUIC，则切换到HTTP2/TCP协议。</p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>性能是我们探索更好协议的首要因素，首先我们在不同的网络环境下进行了网络模拟来研究QUIC如何工作。为了验证QUIC在真实环境的性能收益，我们在公路上进行了仿真测试。</p>
<h4 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h4><h4 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h4><p>在第二阶段，我们遇到一些有趣的思考：</p>
<h4 id="生产阶段"><a href="#生产阶段" class="headerlink" title="生产阶段"></a>生产阶段</h4><p>受前面测试结果的鼓舞我们开始在Android和iOS中支持QUIC，我们在QUIC和TCP之间使用A/B测试来量化QUIC的性能。从不同的维度，我们看到了末端延迟显著的减少。</p>
<h2 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h2><p>在部署QUIC的过程中，无论是强网络还是弱网络，我们已经找到了几种方法来提升APP性能。</p>
<h3 id="增加QUIC覆盖率"><a href="#增加QUIC覆盖率" class="headerlink" title="增加QUIC覆盖率"></a>增加QUIC覆盖率</h3><p>我们通过对真实场景的分析，大约80%的会话请求完全使用QUIC协议，大约15%的请求使用混合的TCP和QUIC。对于这种混合请求的场景，我们目前的猜想是：出现超时现象时，由于无法区分是UDP失败，还是弱网络环境，代码会自动切换到TCP协议。我们目前正在解决这个问题。</p>
<h3 id="QUIC优化"><a href="#QUIC优化" class="headerlink" title="QUIC优化"></a>QUIC优化</h3><p>与占用带宽的应用相比，Uber应用对延迟比较敏感。而且我们的应用起初也是使用蜂窝网接入。以我们的经验来看，尽管使用QUIC替换TCP协议，末端延迟仍然非常高。我们团队仍然在探索新的方法来控制拥塞、提升丢失恢复算法来优化QUIC的延迟问题。</p>
<p><strong>翻译不好，有问题的地方多多反馈(邮箱：<a href="mailto:wwangwanchao@126.com" target="_blank" rel="noopener">wwangwanchao@126.com</a>)</strong></p>
]]></content>
  </entry>
  <entry>
    <title>QUIC协议</title>
    <url>/2020/09/05/net-quic/</url>
    <content><![CDATA[<p>最近在阿里云看到一篇介绍QUIC协议的文章，又勾起了我对她的兴趣。无论网络的如何发展，好像仍然无法解决地铁上网速卡到打不开网页的问题。而QUIC多多少少和这个沾点边</p>
<ol>
<li>QUIC是什么？what</li>
<li>QUIC用来做什么？for</li>
<li>QUIC解决了什么问题？solve</li>
<li>QUIC的设计原理是什么？design</li>
<li>你自己如何实现QUIC？practice</li>
</ol>
<p>1) QUIC是一种基于UDP的通信协议，现在已经被IETF采纳为标准协议HTTP/3</p>
<a id="more"></a>
<p>一次无法理解的东西，我可能会分很长时间补充(待续…)</p>
<h2 id="Cloudflare基于Rust实现的quiche"><a href="#Cloudflare基于Rust实现的quiche" class="headerlink" title="Cloudflare基于Rust实现的quiche"></a>Cloudflare基于Rust实现的quiche</h2><p>###<br>Windows<br>Exit any running-instance of Chrome.<br>Right click on your “Chrome” shortcut.<br>Choose properties.<br>At the end of your “Target:” line add the command line flags. For example:<br>–disable-gpu-vsync<br>With that example flag, it should look like below (replacing “–disable-gpu-vsync” with any other command line flags you want to use):<br>chrome.exe –disable-gpu-vsync<br>Launch Chrome like normal with the shortcut.<br>macOS<br>Quit any running instance of Chrome.<br>Run your favorite Terminal application.<br>In the terminal, run commands like below (replacing “–remote-debugging-port=9222” with any other command line flags you want to use):<br>/Applications/Chromium.app/Contents/MacOS/Chromium –remote-debugging-port=9222</p>
<h1 id="For-Google-Chrome-you’ll-need-to-escape-spaces-like-so"><a href="#For-Google-Chrome-you’ll-need-to-escape-spaces-like-so" class="headerlink" title="For Google Chrome you’ll need to escape spaces like so:"></a>For Google Chrome you’ll need to escape spaces like so:</h1><p>/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome –remote-debugging-port=9222<br>Linux<br>Quit any running instance of Chrome.<br>Run your favorite terminal emulator.<br>In the terminal, run commands like below (replacing “–remote-debugging-port=9222” with any other command line flags you want to use):<br>chromium-browser –remote-debugging-port=9222<br>google-chrome –foo –bar=2</p>
]]></content>
  </entry>
  <entry>
    <title>Protobuf Buffers</title>
    <url>/2020/09/02/protobuf-base/</url>
    <content><![CDATA[<p>17年在异构系统通信中尝试使用pb作为序列化中间价，最后因为嵌入式系统问题，最后采用了jsonrpc。<br>首先来一波：</p>
<ol>
<li>pb是什么？what</li>
<li>pb用来做什么？for</li>
<li>pb解决了什么问题？solve</li>
<li>pb的设计原理是什么？design</li>
<li>你自己如何实现pb？practice</li>
</ol>
<p>1) pb是一个灵活的、高效的、自动化的序列化框架。更小、更快、更简单。(蜜汁自信？可能我还没体会到)<br>2) 基本上可以说解决了异构的序列化问题<br>3) 序列化/反序列化文件有几种方式：</p>
<ol>
<li>使用jdk自带框架序列化。但是它有太多的问题，《Effective Java》中第213条明确指出。而且无法在异构系统之间实现共享数据，例如和C++或Python</li>
<li>你也可以自定义一种方式对数据进行编码成一个字符串，这种方式可能在运行时有一定的性能损耗，但比较适合简单的数据序列化。</li>
<li>序列化为XML。由于XML的可读性，这种方式也很多，在大多数语言中都有相应的开源库，但是XML占用空间，编码/解码需要耗费极大的性能。除此之外，遍历XML DOM树比遍历简单的类属性更复杂。<br>4)<br>5) <a id="more"></a>
</li>
</ol>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>流程：</p>
<ol>
<li>定义<code>.proto</code>文件，文件按照proto的语法编写</li>
<li>使用protoc编译器编译<code>.proto</code>文件，生成包含setters/getters的文件</li>
<li>Java调用pb框架API</li>
</ol>
<h3 id="安装protoc编译器"><a href="#安装protoc编译器" class="headerlink" title="安装protoc编译器"></a>安装protoc编译器</h3><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>protobuf</span><br></pre></td></tr></table></figure>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>Linux系统下直接下载解压，解压后自动生成一个bin文件夹<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">wget protoc<span class="number">-3.13</span><span class="number">.0</span>-linux-x86_64.zip</span><br><span class="line">unzip  protoc<span class="number">-3.13</span><span class="number">.0</span>-linux-x86_64.zip</span><br><span class="line">bin/protoc --version</span><br></pre></td></tr></table></figure></p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>win系统和linux一样生成一个包含执行程序的bin文件夹</p>
<h3 id="编译文件"><a href="#编译文件" class="headerlink" title="编译文件"></a>编译文件</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">protoc <span class="attribute">-I</span>=<span class="variable">$SRC_DIR</span> <span class="attribute">--java_out</span>=<span class="variable">$DST_DIR</span> <span class="variable">$SRC_DIR</span>/addressbook.proto</span><br></pre></td></tr></table></figure>
<p>java_out：指定生成文件的根路径，</p>
<h2 id="proto语法"><a href="#proto语法" class="headerlink" title="proto语法"></a>proto语法</h2><p>proto2和proto3语法不一致，但是在不同的语言中语法一致，例如C++和Java中，最后通过protoc编译器编译为相应的类。</p>
<p><strong>注意：</strong> pb不支持继承<br><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;    <span class="comment">// 指定语法版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> tutorial;     <span class="comment">// 指定包路径，防止命名冲突，</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">"com.example.tutorial"</span>;   <span class="comment">// 指定生成Java类路径，如果为定义，则使用package值作为生成路径</span></span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">"AddressBookProtos"</span>;    <span class="comment">// 指定包含以下所有类定义的文件，在这里生成的AddressBookProtos会包含以下Person、AddressBook内部类。如果未指定，则使用该文件名的驼峰命名法取代。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;    <span class="comment">// 等于一个类，最后会生成Class类</span></span><br><span class="line">  <span class="keyword">required</span> <span class="built_in">string</span> name = <span class="number">1</span>;     <span class="comment">// required表明该字段必须有值，否则认为实例未初始化，创建未实例化的对象会抛出RuntimeException。反序列化一个未初始化对象则抛出IOException</span></span><br><span class="line">  <span class="keyword">required</span> <span class="built_in">int32</span> id = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> email = <span class="number">3</span>;    <span class="comment">// 该字段可以不设值，如果不设值，则使用默认值。number-0, strings-"", bool-false, 嵌套的message-默认实例/message的原型。</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">PhoneType</span> </span>&#123;    <span class="comment">// 等于枚举类</span></span><br><span class="line">    MOBILE = <span class="number">0</span>;</span><br><span class="line">    HOME = <span class="number">1</span>;</span><br><span class="line">    WORK = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">PhoneNumber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">string</span> number = <span class="number">1</span>;   </span><br><span class="line">    <span class="keyword">optional</span> PhoneType type = <span class="number">2</span> [default = HOME];  <span class="comment">// 使用default定义默认值，</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">repeated</span> PhoneNumber phones = <span class="number">4</span>;    <span class="comment">// 表明该字段可以重复任意次数，可以看作一个动态数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">AddressBook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> Person people = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>每个message生成相应类的同时会伴随生成一个Builder类，该类用来创建类实例，其实就是<code>建造者模式</code>。message对应类只有getters方法，相应的Builder类则包含setters/getters。生成所有的方法遵守‘驼峰命名法’。<br>clear(): 每个属性都会有一个clear方法用来对属性清空。<br>count(): repated字段还有count方法用来计数，setter/getter对指定索引index操作，add()添加单个元素，add()添加集合。其实就是一个List。</p>
<h3 id="枚举类-嵌套类"><a href="#枚举类-嵌套类" class="headerlink" title="枚举类/嵌套类"></a>枚举类/嵌套类</h3><h3 id="Message-Builder公共方法"><a href="#Message-Builder公共方法" class="headerlink" title="Message/Builder公共方法"></a>Message/Builder公共方法</h3><p>isInitialized(): checks if all the required fields have been set.<br>toString(): returns a human-readable representation of the message, particularly useful for debugging.<br>mergeFrom(Message other): (builder only) merges the contents of other into this message, overwriting singular scalar fields, merging composite fields, and concatenating repeated fields.<br>clear(): (builder only) clears all the fields back to the empty state.</p>
<h3 id="序列化-反序列化"><a href="#序列化-反序列化" class="headerlink" title="序列化/反序列化"></a>序列化/反序列化</h3><p>byte[] toByteArray();: serializes the message and returns a byte array containing its raw bytes.<br>static Person parseFrom(byte[] data);: parses a message from the given byte array.<br>void writeTo(OutputStream output);: serializes the message and writes it to an OutputStream.<br>static Person parseFrom(InputStream input);: reads and parses a message from an InputStream.</p>
<h3 id="扩展pb"><a href="#扩展pb" class="headerlink" title="扩展pb"></a>扩展pb</h3><p>在开发过程中，毫无疑问需要扩展<code></code>proto`文件，如果新文件需要向后兼容，旧文件需要向前兼容，则在更新的proto文件中需要遵守一些规则：</p>
<ol>
<li>不能改变任何属性的tag值</li>
<li>不能添加/删除任何required标志字段</li>
<li>可以删除optional/repeated字段</li>
<li>在添加optional/repeated字段时，必须使用新的tag数值，该数值应该是从未出现过的，即使使用该数值的字段已经被删除</li>
</ol>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>理解pb的编码/序列化原理之前，首先需要理解变长数值<code>varints</code>，<code>varints</code>使用一个或者多个字节对一个整数序列化，越小的数字使用的字节数越少。<br>在<code>varints</code>中，除了最后一个字节外，每一个字节都有msb set。msb set表明接下来还有多少字节，每一个字节的低7位用来存储’二位补码’。pb默认采用<code>least significant group first</code>，其实就是LSB的一个变种(杂种)。</p>
<p>序列化/反序列化的核心规则还是下面这些：</p>
<table>
<thead>
<tr>
<th style="text-align:center">序列化后类型</th>
<th style="text-align:left">占位</th>
<th style="text-align:left">实际类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:left">变长</td>
<td style="text-align:left">int32, int64, uint32, uint64, sint32, sint64, bool, enum</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left">64位/8字节</td>
<td style="text-align:left">fixed64, sfixed64, double</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:left">长度界定(需要指定后续字节长度)</td>
<td style="text-align:left">string, bytes, embedded messages, packed repeated fields</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:left">Start group</td>
<td style="text-align:left">groups (deprecated)</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:left">End group</td>
<td style="text-align:left">groups (deprecated)</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:left">32位/4字节</td>
<td style="text-align:left">fixed32, sfixed32, float</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<ol>
<li>单字节<br>0000 0001 // 数值1，单字节，所以不需要设置msb</li>
<li>多字节<br>1010 1100 0000 0010 // 数值300？小朋友，你脑子里是否有很多问号？<br>计算步骤：<br>1) 首先去除每一个字节的msb位，即第一位。得到：010 1100 000 0010，这时候其实是两个组(010 1100) (000 0010)<br>2) 根据<code>least significant group first</code>规则，得到：000 0010 010 1100，十进制为300</li>
</ol>
<h3 id="message"><a href="#message" class="headerlink" title="message"></a>message</h3><p>众所众知，message其实就是key-value的键值对，每个key都对应一个数值number。序列化后的二进制对每个key的存储以tag为键，而在<code>.proto</code>文件定义的类型、key作为反序列化使用。(一切协议皆是约定，只不过对扩展性、通用性做了封装，才有了好坏之分)。<br>序列化把所以key-value编码为字节流，反序列化是解析器所以对于增加新的属性后，解析器仍然可以解析旧的编码格式。二进制存储中每个key实际上是<code>(field_number &lt;&lt; 3) | wire_type</code>，type用来指定value占用的字节数。大多数语言实现中都将这个key称为tag。<br>例如：<br>000 1000  //<br>96 01  // 150</p>
<h3 id="有符号整数"><a href="#有符号整数" class="headerlink" title="有符号整数"></a>有符号整数</h3><h3 id="非变长数值"><a href="#非变长数值" class="headerlink" title="非变长数值"></a>非变长数值</h3><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>定义proto，设置对象name=”testing”<br><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>writeTo(OutputStream output)方法生成的二进制<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span> <span class="number">07</span> <span class="number">74</span> <span class="number">65</span> <span class="number">73</span> <span class="number">74</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">67</span>  <span class="comment">// ..testing</span></span><br></pre></td></tr></table></figure></p>
<p>writeDelimitedTo(OutputStream output)方法生成的二进制<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">09</span> <span class="number">12</span> <span class="number">07</span> <span class="number">74</span> <span class="number">65</span> <span class="number">73</span> <span class="number">74</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">67</span>  <span class="comment">// ...testing</span></span><br></pre></td></tr></table></figure></p>
<h3 id="嵌套message"><a href="#嵌套message" class="headerlink" title="嵌套message"></a>嵌套message</h3><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">Desc</span> </span>&#123;</span><br><span class="line">    <span class="built_in">int32</span> a = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Desc desc = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只对Person.Desc二进制序列化<br><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">08 </span><span class="number">96</span> <span class="number">01</span></span><br></pre></td></tr></table></figure></p>
<p>在Person中填充属性对Person序列化<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span> <span class="number">07</span> <span class="number">74</span> <span class="number">65</span> <span class="number">73</span> <span class="number">74</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">1</span>a <span class="number">03</span> <span class="number">08</span> <span class="number">96</span> <span class="number">01</span></span><br></pre></td></tr></table></figure></p>
<h3 id="optional-repeated元素"><a href="#optional-repeated元素" class="headerlink" title="optional/repeated元素"></a>optional/repeated元素</h3><p>增加repeated属性，girl属性添加’test’值<br><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">Desc</span> </span>&#123;</span><br><span class="line">    <span class="built_in">int32</span> a = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Desc desc = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">repeated</span> <span class="built_in">string</span> girl = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>序列化后的二进制<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span> <span class="number">07</span> <span class="number">74</span> <span class="number">65</span> <span class="number">73</span> <span class="number">74</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">1</span>a <span class="number">03</span> <span class="number">08</span> <span class="number">96</span> <span class="number">01</span> <span class="number">22</span> <span class="number">04</span></span><br><span class="line"><span class="number">74</span> <span class="number">65</span> <span class="number">73</span> <span class="number">74</span></span><br></pre></td></tr></table></figure></p>
<h3 id="字段顺序"><a href="#字段顺序" class="headerlink" title="字段顺序"></a>字段顺序</h3><p>id=1，序列化<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">08</span> <span class="number">12</span> <span class="number">12</span> <span class="number">07</span> <span class="number">74</span> <span class="number">65</span> <span class="number">73</span> <span class="number">74</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">1</span>a <span class="number">03</span> <span class="number">08</span> <span class="number">96</span> <span class="number">01</span> </span><br><span class="line"><span class="number">22</span> <span class="number">04</span> <span class="number">74</span> <span class="number">65</span> <span class="number">73</span> <span class="number">74</span></span><br></pre></td></tr></table></figure></p>
<p>修改id=5，序列化<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span> <span class="number">07</span> <span class="number">74</span> <span class="number">65</span> <span class="number">73</span> <span class="number">74</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">1</span>a <span class="number">03</span> <span class="number">08</span> <span class="number">96</span> <span class="number">01</span> <span class="number">22</span> <span class="number">04</span></span><br><span class="line"><span class="number">74</span> <span class="number">65</span> <span class="number">73</span> <span class="number">74</span> <span class="number">28</span> <span class="number">12</span></span><br></pre></td></tr></table></figure></p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>MSB(most significant bit)和LSB(least significant bit)的区别是位传输顺序的不同，在二进制表示中，MSB指的是最左端的最高位，LSB指的是左右端的最低位。在并行接口传输中，传输端-接收端没有问题，但是在串行接口中，数据的传输需要保持有序，就需要确定传输的顺序。<code>MSB first</code>从最高位开始传输<br>在SRAM架构中，21根地址线(A0-A20)，8根数据线(D0-D7)</p>
<h3 id="LSB"><a href="#LSB" class="headerlink" title="LSB"></a>LSB</h3><p>在电脑运算中，LSB比特位用来标记一个数值是奇数还是偶数。按照’按位计数法’的规定，处于右端，有时候也叫低端位/最右端位。<br>在数字密码学中，图片、声音等敏感信息，可以通过使用这种LSB的方式计算、存储来达到加密的效果。</p>
<p>应用场景：伪随机数生成、密码工具、哈希函数、校验和</p>
<h3 id="MSB"><a href="#MSB" class="headerlink" title="MSB"></a>MSB</h3><p>在电脑运算中，MSB比特位用来标记一个数值是奇数还是偶数。按照’按位计数法’的规定，处于左端，有时候也叫高端位/最左端位。<br>在有符号二进制数中，MSB相当于符号位，在1位、二位补码表示法中，1代表负数，0代表正数。<br>MSB也支持字节，简写<code>MSbit</code>和<code>MSbyte</code></p>
<p>Protocol buffers需要安装protoc编译器，重要的是pb支持扩展，即便格式被改变后，仍然可以反序列化旧的格式。</p>
<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><p>pb已经超越了简单的访问、序列化。一个最关键的特性就是反射，可以遍历message的所有字段、操作value。反射一个非常有用的就是应用可以实现pb message和XML/JSON的相互转换。<br>发挥你的想象力，pb可以有更广泛的应用场景。</p>
<p>别说了，看了你的文档，我就是犹大！</p>
]]></content>
  </entry>
  <entry>
    <title>不同系统搭建多版本的jdk</title>
    <url>/2020/08/30/jdk-multi/</url>
    <content><![CDATA[<p>dmg按照步骤安装jdk，我目前感兴趣的主要是jdk8、jdk11，所以这里只有两个版本，jdk在Windows、Mac、Linux支持多版本安装，这个可是太爽了，一个命令切换。</p>
<a id="more"></a>
<h2 id="Mac系统"><a href="#Mac系统" class="headerlink" title="Mac系统"></a>Mac系统</h2><p>查看jdk版本、安装目录<br><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">java</span> <span class="string">-version</span></span><br><span class="line"><span class="attr">which</span> <span class="string">java</span></span><br><span class="line"><span class="attr">ll</span> <span class="string">/usr/bin/java</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">/System/Library/Frameworks/JavaVM.framework/Versions</span></span><br></pre></td></tr></table></figure></p>
<p>查看可用的jdk版本<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ls</span></span><br><span class="line"><span class="keyword">ll</span></span><br></pre></td></tr></table></figure></p>
<p>查看已经安装的jdk<br><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">/usr/libexec/jav<span class="built_in">a_home</span> -V</span><br></pre></td></tr></table></figure></p>
<p>配置环境变量</p>
<pre><code>vi ~/.bash_profile
</code></pre><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置自带的 jdk1.6</span></span><br><span class="line"><span class="comment">#export JAVA_6_HOME=`/usr/libexec/java_home -v 1.6`</span></span><br><span class="line"><span class="comment"># 设置 jdk1.7</span></span><br><span class="line"><span class="comment">#export JAVA_7_HOME=`/usr/libexec/java_home -v 1.7`</span></span><br><span class="line"><span class="comment"># 设置 jdk1.8</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">JAVA_8_HOME</span>=`/usr/libexec/java_home -v 1.8`</span><br><span class="line"><span class="comment"># 设置 jdk11</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">JAVA_11_HOME</span>=`/usr/libexec/java_home -v 11`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认 jdk 使用1.6版本</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">JAVA_HOME</span>=<span class="variable">$JAVA_8_HOME</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># alias 命令动态切换 jdk 版本</span></span><br><span class="line"><span class="comment"># alias jdk6="export JAVA_HOME=$JAVA_6_HOME"</span></span><br><span class="line"><span class="comment"># alias jdk7="export JAVA_HOME=$JAVA_7_HOME"</span></span><br><span class="line">alias <span class="attribute">jdk8</span>=<span class="string">"export JAVA_HOME=<span class="variable">$JAVA_8_HOME</span>"</span></span><br><span class="line">alias <span class="attribute">jdk11</span>=<span class="string">"export JAVA_HOME=<span class="variable">$JAVA_11_HOME</span>"</span></span><br></pre></td></tr></table></figure>
<p>命令切换jdk版本<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">jdk8</span></span><br><span class="line"><span class="keyword">java </span>-version</span><br></pre></td></tr></table></figure></p>
<p>遇到的问题：</p>
<ol>
<li>在Versions目录查看jdk版本时没有列出所有的可用版本</li>
</ol>
<h2 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h2><h3 id="Ubuntu-Deepin安装"><a href="#Ubuntu-Deepin安装" class="headerlink" title="Ubuntu/Deepin安装"></a>Ubuntu/Deepin安装</h3><p>安装<br><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/java java /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">jvm</span>/<span class="title">jdk</span>-11/<span class="title">bin</span>/<span class="title">java</span> 300  </span></span><br><span class="line"></span><br><span class="line">sudo update-alternatives --install /usr/bin/java java /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">jvm</span>/<span class="title">jdk</span>-11/<span class="title">bin</span>/<span class="title">java</span> 300 -<span class="title">slave</span> /<span class="title">usr</span>/<span class="title">bin</span>/<span class="title">javac</span> /<span class="title">usr</span>/<span class="title">lib</span>/<span class="title">jvm</span>/<span class="title">jdk</span>-11/<span class="title">bin</span>/<span class="title">javac</span></span></span><br></pre></td></tr></table></figure></p>
<p>切换版本<br><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">sudo <span class="keyword">update</span>-alternatives <span class="comment">--config java</span></span><br></pre></td></tr></table></figure></p>
<p>卸载指定版本<br><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --remove java /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">jvm</span>/<span class="title">jdk</span>-11/<span class="title">bin</span>/<span class="title">java</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p>update-alternatives命令<br>命令：<br>  –install &lt;链接&gt; &lt;名称&gt; &lt;路径&gt; &lt;优先级&gt;<br>    [–slave &lt;链接&gt; &lt;名称&gt; &lt;路径&gt;] …<br>                           在系统中加入一组候选项。<br>  –remove &lt;名称&gt; &lt;路径&gt;   从 &lt;名称&gt; 替换组中去除 &lt;路径&gt; 项。<br>  –remove-all &lt;名称&gt;      从替换系统中删除 &lt;名称&gt; 替换组。<br>  –auto &lt;名称&gt;            将 &lt;名称&gt; 的主链接切换到自动模式。<br>  –display &lt;名称&gt;         显示关于 &lt;名称&gt; 替换组的信息。<br>  –query &lt;名称&gt;           机器可读版的 –display &lt;名称&gt;.<br>  –list &lt;名称&gt;            列出 &lt;名称&gt; 替换组中所有的可用候选项。<br>  –get-selections         列出主要候选项名称以及它们的状态。<br>  –set-selections         从标准输入中读入候选项的状态。<br>  –config &lt;名称&gt;          列出 &lt;名称&gt; 替换组中的可选项，并就使用其中<br>                           哪一个，征询用户的意见。<br>  –set &lt;名称&gt; &lt;路径&gt;      将 &lt;路径&gt; 设置为 &lt;名称&gt; 的候选项。<br>  –all                    对所有可选项一一调用 –config 命令。</p>
<p>&lt;链接&gt; 是指向 /etc/alternatives/&lt;名称&gt; 的符号链接。<br>    (如 /usr/bin/pager)<br>&lt;名称&gt; 是该链接替换组的主控名。<br>    (如 pager)<br>&lt;路径&gt; 是候选项目标文件的位置。<br>    (如 /usr/bin/less)<br>&lt;优先级&gt; 是一个整数，在自动模式下，这个数字越高的选项，其优先级也就越高。</p>
]]></content>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务--断路器(四)</title>
    <url>/2020/08/28/sc-hystrix/</url>
    <content><![CDATA[<p>今天某图的面试官又问了我这个问题，我把bucket给忘了，心塞，所以我觉得该把整个Hystrix的文档“抄”一遍了。对一个中间件完全、深入的学习，我始终没有找到一个很好的方向，经某图研发主管指点，我悟了！以后每个中间件的学习我都会引入以下5个问题，这些问题要能涵盖所有核心的东西，粒度要合适，太小容易限于细节而失去大局观，太大则容易失去对核心的把握：</p>
<ol>
<li>中间件是什么？what</li>
<li>中间件用来做什么？for</li>
<li>中间件解决了什么问题？solve</li>
<li>中间件的设计原理是什么？design</li>
<li>你自己如何实现中间件？practice</li>
</ol>
<p>如果能够在几分钟内把以上几个问题复述清楚，那么对整体的理解算是入门了，之后就是更深入的源码级别的问题了。<br>答：<br>1) 在分布式系统中，服务之间的依赖不可避免的会失败，hystrix主要用来处理两个问题：请求超时、请求错误。服务之间是通过请求隔离实现的，避免跨服务之间的级联失败。同时提供了降级来保证系统的健壮性。在Netflix，hystrix每天可以支撑100亿线程隔离、1000亿信号量隔离的调用</p>
<p>2) 主要用来做以下的事情:</p>
<blockquote>
<p>处理服务调用超时、失败问题<br>在复杂的分布式系统中阻止级联失败<br>快速失败、快速恢复<br>回退、优雅的降级<br>实时的监控、告警</p>
</blockquote>
<p>3) 问题3可能和问题2有混淆的地方。复杂系统中，应用可能依赖很多服务，任何服务都可能失败，如果当前主机应用没有和其他失败的服务隔离，该服务也会变成不可用。例如：单个服务满足可用性99.99%，30个依赖服务就会导致可用性降为99.99。最终即使0.01%的服务宕机都可能导致一个月内几个小时的不可用。</p>
<p>4) 设计原理：</p>
<blockquote>
<p>阻止单个依赖耗尽容器(Tomcat)的用户线程。将所有对依赖服务的请求包装在的<code>HystrixCommand or HystrixObservableCommand</code>对象中，这两个对象运行在一个隔离的线程中。每一个依赖服务都会维护一个小型线程池/信号量，如果满了以后，请求会被直接拒绝而不是排队等待。<br>快速失败避免阻塞。请求错误率达到一个阈值后，要么手动的/自动的触发一个断路器来阻止对某个服务的请求<br>在可行的地方提供回退机制避免直接失败。当一个请求失败、超时、被拒绝、断路后悔进入fallback回退逻辑。<br>使用隔离技术(bulkhead舱壁隔离、swimlane泳道、circuit breaker断路器)限制依赖的影响<br>实时的统计、监控、告警实现及时发现问题。统计的具体包括：成功、失败、超时、线程拒绝<br>低延时的反馈回路允许修改配置，支持动态的修改属性<br>对client整个执行过程中依赖调用进行保护，而不仅仅是网络过程</p>
</blockquote>
<p>5) 如果是你，你如何实现？</p>
<a id="more"></a>
<h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p>注意服务熔断和服务降级是两个不同的概念。<br>服务熔断：一般是指软件系统中，由于某些原因使得服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施，所以很多地方把熔断亦称为过载保护。很多时候刚开始可能只是系统出现了局部的、小规模的故障，然而由于种种原因，故障影响的范围越来越大，最终导致了全局性的后果。<br>服务降级：当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>熔断器:Circuit Breaker<br>每个请求都会先经过熔断器，判断是否打开状态，每个熔断器维护10个bucket，每个bucket记录(成功、失败、超时、拒绝)的次数，每秒创建一个bucket，旧的bucket会被抛弃</p>
<h4 id="熔断机制"><a href="#熔断机制" class="headerlink" title="熔断机制"></a>熔断机制</h4><p>默认是5s内20次调用失败，就会触发熔断机制。也可以通过以下参数调整。<br>配置属性：<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">hystrix.command.default.metrics.rollingStats.timeInMilliseconds</span> 	</span><br><span class="line"><span class="attr">circuitBreaker:</span></span><br><span class="line">    <span class="string">forceClosed：</span> <span class="literal">true</span>      <span class="comment"># 是否强制关闭熔断</span></span><br><span class="line">	<span class="attr">requestVolumeThreshold:</span> <span class="number">20</span>   	<span class="comment"># 滑动窗口大小，默认20次/10s</span></span><br><span class="line">	<span class="attr">sleepWindowInMilliseconds:</span> <span class="number">5000</span>  <span class="comment"># 过多久断路器再次检测是否开启</span></span><br><span class="line">	<span class="attr">errorThresholdPercentage:</span> <span class="number">50</span>  	<span class="comment"># 错误率</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>快照时间窗口：timeInMilliseconds 默认为10s</li>
<li>请求总数阀值: requestVolumeThreshold 在快照时间窗内，必须满足请求总数阀值才有资格熔断。例如：默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足20次，即使所有的请求都超时或其他原因失败，断路器都不会打开</li>
<li>错误百分比阀值：errorThresholdPercentage 默认50，主要根据依赖(强依赖、弱依赖)重要性进行调整，当请求总数在快照时间窗内请求失败率超过了该阀值，则打开断路器<br><strong>注意</strong><br><strong>默认</strong>超过50%的请求失败，将打开断路器()，不再调用后端服务而直接失败，调用降级服务<code>fallback</code>，过一段时间后尝试一部分请求到后端()，如果成功则关闭断路器()，否则重新打开</li>
</ol>
<h4 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h4><p>可以手动设置，当调用后端服务超过超时时间时，直接返回/执行fallback逻辑<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">execution</span><span class="selector-class">.isolation</span><span class="selector-class">.thread</span><span class="selector-class">.timeoutInMilliseconds</span> # 超时时间	</span><br><span class="line">默认值：1000</span><br><span class="line">在<span class="selector-tag">THREAD</span>模式下，达到超时时间，可以中断</span><br><span class="line">在<span class="selector-tag">SEMAPHORE</span>模式下，会等待执行完成后，再去判断是否超时</span><br></pre></td></tr></table></figure></p>
<p>级别：</p>
<ol>
<li>全局级别</li>
<li>接口级别</li>
<li>服务级别</li>
</ol>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>默认情况下，使用线程池模式<br>每个请求对于一个线程池，接收请求后提交到线程池，下游服务在各自的单独线程中执行，达到资源隔离的作用。<br>微服务之间的调用包裹在HystrixCommand类中，这样每次都会启动一个新的线程执行</p>
<h4 id="配置属性"><a href="#配置属性" class="headerlink" title="配置属性"></a>配置属性</h4><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">coreSize</span><br><span class="line">execution.isolation.thread.interruptOnTimeout=<span class="literal">true</span>  <span class="comment">#是否打开超时线程中断</span></span><br><span class="line">execution.<span class="keyword">timeout</span>.enabled: <span class="literal">true</span>  <span class="comment"># 是否打开超时	</span></span><br><span class="line">maxQueueSize: <span class="number">-1</span>   <span class="comment"># 请求等待队列	默认值：-1 如果使用正数，队列将从SynchronizeQueue改为LinkedBlockingQueue</span></span><br></pre></td></tr></table></figure>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>本服务接收请求和下游服务的执行都在一个线程内执行，内部通过一个计数器(信号量)实现线程计数，当线程的并发数大于信号量阈值时将进入fallback。</p>
<h4 id="配置属性：调整为信号量模式"><a href="#配置属性：调整为信号量模式" class="headerlink" title="配置属性：调整为信号量模式"></a>配置属性：调整为信号量模式</h4><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">execution.isolation.strategy</span> = ExecutionIsolationStrategy.SEMAPHORE</span><br><span class="line"><span class="attr">execution.isolation.semaphore.maxConcurrentRequests</span>=<span class="number">1000</span>  <span class="comment"># 限制下游服务调用，当并发请求数达到阈值时，请求线程可以快速失败，执行降级</span></span><br></pre></td></tr></table></figure>
<h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><ol>
<li>隔离（线程隔离、信号量隔离）：主要是限制调用分布式服务的资源，避免个别服务出现问题时对其他服务产生影响</li>
<li>熔断（容错）：当失败率达到一定阈值时，熔断器触发快速失败</li>
<li>降级（超时降级、熔断降级）：触发降级时可以使用回调方法返回托底数据</li>
<li>缓存：请求缓存、请求合并</li>
<li>实时监控、报警</li>
</ol>
<h3 id="线程池和信号量的区别"><a href="#线程池和信号量的区别" class="headerlink" title="线程池和信号量的区别"></a>线程池和信号量的区别</h3><p>线程池：</p>
<p>信号量：</p>
<h3 id="统计监控"><a href="#统计监控" class="headerlink" title="统计监控"></a>统计监控</h3><p>在<code>HystrixCommands and HystrixObservableCommands</code>命令执行的时候，会对执行结果/执行频率生成统计向量，这对开发者来说是非常有用的，可以更深入地看到系统运行行为，Hystrix对每个执行命令都提供了细粒度的统计(甚至是秒级别的)。</p>
<h4 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h4><p><code>HystrixCommand</code> 单个返回值，SUCCESS事件返回值，同时表示请求完成。<br><code>HystrixObservableCommand</code> 可能返回多个值，EMIT事件返回值，其它事件表示请求终止，<br>事件又分为：执行事件、回退事件、命令事件、线程池事件、崩溃事件</p>
<h4 id="向量存储"><a href="#向量存储" class="headerlink" title="向量存储"></a>向量存储</h4><p>统计向量生成后，在被转移之前需要被存储一段时间，Hystrix选择将这些统计向量存储在内存中，以便后续的查询。这些向量存储结构在1.5.0版本被重构。<br>1.4.x版本：<br>HystrixRollingNumber用来统计所有事件，HystrixRollingPercentile只统计定制事件，例如：执行频率、崩溃次数。这些向量在执行过程中同步写入，支持滚动模式只保持最新的统计。</p>
<h4 id="向量读取"><a href="#向量读取" class="headerlink" title="向量读取"></a>向量读取</h4><p>读取只返回聚合结果，例如：对一个请求失败率50%的监控，但是我们可能需要知道该接口在不同国家的失败率，可能在墨西哥、巴西失败率为0%，但是在美国失败率为98%，如果只是简单的聚合会丢失精度。<br>为了解决以上的问题，引入了<code>HystrixRequestLog</code>，使用日志进行更深度的分析，这可能不是最佳的方案，请求结束后，可以结合上下文环境对HTTP请求做一些分析，从而根据HTTP请求路径对请求结果/请求频率做一个划分。<br>1.5.x版本：<br>在1.5版本对向量统计进行了重新设计，可以允许更灵活的消费。每一个向量都会生成stream流，每一个<code>HystrixCommandKey</code>和<code>HystrixThreadPoolKey</code>都有一个开始事件-结束事件流，每一个<code>HystrixCollapserKey</code>都有一个专门处理崩溃事件的流。</p>
<h2 id="Sentinel-阿里"><a href="#Sentinel-阿里" class="headerlink" title="Sentinel(阿里)"></a>Sentinel(阿里)</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>特性：</p>
<ol>
<li>轻量级、高性能： sentinel-core不到200KB，单机超过25W QPS才会有影响</li>
<li>流量控制：以不同的运行指标为基准，<blockquote>
<p>直接拒绝模式<br>慢启动预热模式<br>匀速度模式</p>
</blockquote>
</li>
<li>系统负载保护</li>
</ol>
<h3 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h3><ol>
<li>和Dubbo整合，通过限流实现服务的高可用</li>
<li>和RocketMQ整合，通过匀速请求和冷启动保障服务的稳定性</li>
</ol>
<h3 id="Hystrix和Sentinel的对比"><a href="#Hystrix和Sentinel的对比" class="headerlink" title="Hystrix和Sentinel的对比"></a>Hystrix和Sentinel的对比</h3>]]></content>
      <tags>
        <tag>断路器</tag>
      </tags>
  </entry>
  <entry>
    <title>加缪和鼠疫</title>
    <url>/2020/08/28/think-in-lapeste/</url>
    <content><![CDATA[<p>我最近真的太想读书了，和技术无关的一切图书：社科的、艺术的、数学的。知道加缪，来源于一句话–如果你一直在找人生的意义，你永远不会生活。恍然大悟，也许，人生的真正的意义在于这个过程，何必去追寻最终的高级意义？</p>
<a id="more"></a>
<p>“这不是一个人的生死抗争，而是一群人的休戚与共，你所需要的，不是逃离，而是直面它的勇气。”，这句话就好像罗曼罗兰说过的一句话–“世界上只有一种英雄主义，就是看清生活之后依然热爱生活”，两个人出生于同一个国家，多多少少有着31年的交集，对人生，或者生活的感受大抵如此。<br>“La Peste”，在法语中是鼠疫的意思，恰好今年赶上了新冠肺炎，就拿出这本书来读一读。<br>感想随心所欲的更新。。。</p>
]]></content>
  </entry>
  <entry>
    <title>Redis环境搭建</title>
    <url>/2020/08/27/redis-base/</url>
    <content><![CDATA[<p>Redis升级到了6.x版本，也增加了多线程的功能，再也不用被问为啥使用单线程快了。</p>
<a id="more"></a>
<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">tar -xzvf </span><br><span class="line"></span><br><span class="line">cd redis<span class="number">-6.0</span><span class="number">.6</span></span><br><span class="line"><span class="built_in">make</span></span><br><span class="line"><span class="built_in">make</span> install PREFIX=/usr/<span class="keyword">local</span>/redis6</span><br></pre></td></tr></table></figure>
<h3 id="编译错误"><a href="#编译错误" class="headerlink" title="编译错误"></a>编译错误</h3><ol>
<li>make编译报错，gcc版本问题<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">In</span> file included <span class="keyword">from</span> <span class="keyword">server</span>.c:<span class="number">30</span>:<span class="number">0</span>:</span><br><span class="line"><span class="keyword">server</span>.h:<span class="number">1051</span>:<span class="number">5</span>: 错误：expected specifier-qualifier-list <span class="keyword">before</span> ‘_Atomic’</span><br><span class="line">     _Atomic unsigned <span class="type">int</span> lruclock; <span class="comment">/* Clock for LRU eviction */</span></span><br><span class="line">     ^</span><br><span class="line"><span class="keyword">server</span>.c: 在函数‘serverLogRaw’中:</span><br><span class="line"><span class="keyword">server</span>.c:<span class="number">1032</span>:<span class="number">31</span>: 错误：‘struct redisServer’没有名为‘logfile’的成员</span><br><span class="line">     <span class="type">int</span> log_to_stdout = <span class="keyword">server</span>.logfile[<span class="number">0</span>] == <span class="string">'\0'</span>;</span><br><span class="line">                               ^</span><br><span class="line"><span class="keyword">server</span>.c:<span class="number">1035</span>:<span class="number">23</span>: 错误：‘struct redisServer’没有名为‘verbosity’的成员</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">level</span> &lt; <span class="keyword">server</span>.verbosity) <span class="keyword">return</span>;</span><br><span class="line">                       ^</span><br><span class="line"><span class="keyword">server</span>.c:<span class="number">1037</span>:<span class="number">47</span>: 错误：‘struct redisServer’没有名为‘logfile’的成员</span><br><span class="line">     fp = log_to_stdout ? stdout : fopen(<span class="keyword">server</span>.logfile,"a");</span><br><span class="line">                                               ^</span><br><span class="line"><span class="keyword">server</span>.c:<span class="number">1050</span>:<span class="number">47</span>: 错误：‘struct redisServer’没有名为‘timezone’的成员</span><br><span class="line">         nolocks_localtime(&amp;tm,tv.tv_sec,<span class="keyword">server</span>.timezone,<span class="keyword">server</span>.daylight_active);</span><br><span class="line">                                               ^</span><br><span class="line"><span class="keyword">server</span>.c:<span class="number">1050</span>:<span class="number">63</span>: 错误：‘struct redisServer’没有名为‘daylight_active’的成员</span><br><span class="line">         nolocks_localtime(&amp;tm,tv.tv_sec,<span class="keyword">server</span>.timezone,<span class="keyword">server</span>.daylight_active);</span><br><span class="line">                                                               ^</span><br><span class="line"><span class="keyword">server</span>.c:<span class="number">1053</span>:<span class="number">19</span>: 错误：‘struct redisServer’没有名为‘sentinel_mode’的成员</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">server</span>.sentinel_mode) &#123;</span><br><span class="line">                   ^</span><br><span class="line"><span class="keyword">server</span>.c:<span class="number">1058</span>:<span class="number">32</span>: 错误：‘struct redisServer’没有名为‘masterhost’的成员</span><br><span class="line">             role_char = (<span class="keyword">server</span>.masterhost ? <span class="string">'S'</span>:<span class="string">'M'</span>); <span class="comment">/* Slave or Master. */</span></span><br><span class="line">                                ^</span><br><span class="line"><span class="keyword">server</span>.c:<span class="number">1066</span>:<span class="number">15</span>: 错误：‘struct redisServer’没有名为‘syslog_enabled’的成员</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">server</span>.syslog_enabled) syslog(syslogLevelMap[<span class="keyword">level</span>], "%s", msg);</span><br><span class="line">               ^</span><br><span class="line"><span class="keyword">server</span>.c: 在函数‘serverLog’中:</span><br><span class="line"><span class="keyword">server</span>.c:<span class="number">1076</span>:<span class="number">30</span>: 错误：‘struct redisServer’没有名为‘verbosity’的成员</span><br><span class="line">     <span class="keyword">if</span> ((<span class="keyword">level</span>&amp;<span class="number">0xff</span>) &lt; <span class="keyword">server</span>.verbosity) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">server</span>.c: 在函数‘writeCommandsDeniedByDiskError’中:</span><br><span class="line"><span class="keyword">server</span>.c:<span class="number">3826</span>:<span class="number">1</span>: 警告：在有返回值的函数中，控制流程到达函数尾 [-Wreturn-<span class="keyword">type</span>]</span><br><span class="line"> &#125;</span><br><span class="line"> ^</span><br><span class="line"><span class="keyword">server</span>.c: 在函数‘iAmMaster’中:</span><br><span class="line"><span class="keyword">server</span>.c:<span class="number">5000</span>:<span class="number">1</span>: 警告：在有返回值的函数中，控制流程到达函数尾 [-Wreturn-<span class="keyword">type</span>]</span><br><span class="line"> &#125;</span><br><span class="line"> ^</span><br><span class="line">make[<span class="number">1</span>]: *** [<span class="keyword">server</span>.o] 错误 <span class="number">1</span></span><br><span class="line">make[<span class="number">1</span>]: 离开目录“/usr/<span class="keyword">local</span>/redis<span class="number">-6.0</span><span class="number">.6</span>/src”</span><br><span class="line">make: *** [<span class="keyword">all</span>] 错误 <span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>解决方法：启用临时gcc9.3.1，打开新的shell后gcc版本重新复原<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">yum -y <span class="keyword">install </span>centos-release-<span class="keyword">scl</span></span><br><span class="line"><span class="keyword">yum </span>-y <span class="keyword">install </span>devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-<span class="keyword">binutils</span></span><br><span class="line"><span class="keyword">scl </span>enable devtoolset-9 <span class="keyword">bash</span></span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>linux-epoll</title>
    <url>/2020/08/23/linux-epoll/</url>
    <content><![CDATA[<p>基于epoll实现一个通信的demo</p>
<a id="more"></a>
]]></content>
  </entry>
  <entry>
    <title>MySQL事务</title>
    <url>/2020/08/21/mysql-transaction/</url>
    <content><![CDATA[<p>MySQL通过MVCC实现事务机制，分布式事务通过XA协议实现</p>
<a id="more"></a>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>commit在写日志之前还是之后？</p>
<h2 id="XA协议"><a href="#XA协议" class="headerlink" title="XA协议"></a>XA协议</h2>]]></content>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket协议</title>
    <url>/2020/08/18/net-websocket/</url>
    <content><![CDATA[<p>之前接触过WebSocket，当时只是当做一个工具去使用，应用场景：</p>
<ol>
<li>浏览器中实现二维码登录，server主动向client发起通信</li>
<li>小程序中实现IM聊天系统</li>
</ol>
<a id="more"></a>
<p>来点刺激的，[官方文档](<a href="https://tools.ietf.org/html/rfc6455#section-1.9" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6455#section-1.9</a><br>阅读加理解需要耗费大量的精力</p>
<h2 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h2><p>历史上，client和server的双向通信导致对HTTP协议的滥用，为了应对不同的HTTP调用，需要不断地轮询server。这就导致一些问题：</p>
<ol>
<li>每个client在server端都需要建立许多不同的TCP连接。一个TCP用于发送消息到client，另一个新的TCP用于接收信息</li>
<li>无线协议时，每个client到server的信息都需要携带header，开销很大</li>
<li>client需要维护两个TCP连接的映射关系</li>
</ol>
<p>简单的解决方案就是使用一个TCP连接实现双向通信，这就是<code>WebSocket</code>的由来。WebSocket API提供了一种选择：可以切换到HTTP轮询模式实现双向通信</p>
<p><code>WebSocket</code>技术被设计的目的就是取代基于HTTP协议实现的双向通信技术。因为HTTP刚开始的设计就不是为了解决双向通信问题，而是在性能和可靠性之间的一种取舍。<br>WebSocket虽然工作在HTTP的80/443端口，同时支持HTTP代理、中间人，但并不意味着局限于HTTP，为了会使用专用的端口而不需要重新设计整个协议</p>
<h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><ol>
<li>游戏</li>
<li>股票</li>
<li>多用户同步协作(现在流行的协作工具)</li>
<li>实时暴露server端服务()</li>
</ol>
<h2 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h2><p>协议分为两个阶段：</p>
<ol>
<li>握手</li>
<li>数据传输</li>
</ol>
<p>## </p>
]]></content>
  </entry>
  <entry>
    <title>java-list</title>
    <url>/2020/08/18/java-list/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>java中Fork/Join</title>
    <url>/2020/08/18/java-fork-join/</url>
    <content><![CDATA[<p>工作中，一个处理数据远程数据逻辑耗时很长，尝试使用fork/join来改进，远程基本可以从60min+优化到20min+。干！</p>
<a id="more"></a>
<p>Fork/Join采用了分而治之的思想，具体实现使用工作窃取算法</p>
<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>fork/join主要分为2个步骤：</p>
<ol>
<li>分割任务</li>
<li>执行任务并合并结果<h3 id="分割任务"><a href="#分割任务" class="headerlink" title="分割任务"></a>分割任务</h3>使用fork类将大任务分割为子任务，子任务可以继续分割</li>
</ol>
<h3 id="执行任务并合并结果"><a href="#执行任务并合并结果" class="headerlink" title="执行任务并合并结果"></a>执行任务并合并结果</h3><p>分割的任务放到双端队列，然后启动线程，这些线程分别从队列的两端获取任务，执行的结果放到另一个队列中，最后由一个线程合并执行的结果</p>
<h2 id="Fork-Join实现原理"><a href="#Fork-Join实现原理" class="headerlink" title="Fork/Join实现原理"></a>Fork/Join实现原理</h2><p>fork/join实现了</p>
<ol>
<li>ForkJoinTask提供了fork()、join()，fork()方法将分割的任务添加到任务队列，join()合并任务执行结果。有两个子类<br>RecursiveAction: 用于返回没有结果的任务<br>RecursiveTask：用于返回有结果的任务 </li>
<li>ForkJoinPool ForkJoinTask需要通过ForkJoinPool来执行。分割的子任务会被添加到当前工作线程所维护的双端队列中，当一个工作线程的队列中暂时没有任务时，会从其他工作线程的队列尾部窃取任务来执行。这就是’工作窃取算法’</li>
</ol>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>取消异常<br>运行异常</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>forkjoin</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-IO模型</title>
    <url>/2020/08/17/linux-io/</url>
    <content><![CDATA[<p>系统中数据传输通常包含两个阶段：</p>
<ol>
<li>等待数据准备好，将数据复制到内核缓冲区</li>
<li>将数据从内核缓冲区复制到进程缓冲区</li>
</ol>
<a id="more"></a>
<h2 id="阻塞式I-O"><a href="#阻塞式I-O" class="headerlink" title="阻塞式I/O"></a>阻塞式I/O</h2><ol>
<li>进程发起系统调用recvfrom，进程阻塞</li>
<li>recvfrom等待直到数据被复制到进程缓冲区才返回</li>
<li>内核返回成功，进程处理返回的数据</li>
</ol>
<p>UDP:<br>TCP:</p>
<h2 id="非阻塞式I-O"><a href="#非阻塞式I-O" class="headerlink" title="非阻塞式I/O"></a>非阻塞式I/O</h2><ol>
<li>进程发起系统调用recvfrom，如果内核缓冲区无数据，则返回WOULDBLOCK错误</li>
<li>进程不断轮询，直到数据被复制到进程缓冲区</li>
<li>内核返回成功，进程处理返回的数据</li>
</ol>
<h2 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I/O复用"></a>I/O复用</h2><ol>
<li>进程发起系统调用select，无数据则进入阻塞状态。</li>
<li>直到数据可读，内核返回可读状态</li>
<li>进程重新发起recvfrom系统调用，数据从内核缓冲区复制到进程缓冲区</li>
<li>内核返回成功，进程处理返回的数据</li>
</ol>
<p>IO多路复用有多种实现：</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>运行模型：</p>
<ol>
<li>调用select</li>
</ol>
<p>缺点：</p>
<blockquote>
<p>单个进程监听的文件描述符数量存在最大限制<br>数据就绪后，对socket进程扫描是线性扫描，效率低<br>用户空间和内核空间在传递时开销大</p>
</blockquote>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>运行模型：</p>
<ol>
<li>调用</li>
</ol>
<p>缺点：</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll是select和poll的增强版<br>epoll的核心概念是<code>epoll instance</code>，从用户空间来看，实质上是两个列表的容器</p>
<ol>
<li><code>interest list</code></li>
<li><code>ready list</code></li>
</ol>
<p>运行模型：</p>
<ol>
<li><h4 id="LT模式-Level-triggered"><a href="#LT模式-Level-triggered" class="headerlink" title="LT模式 Level-triggered"></a>LT模式 Level-triggered</h4><p>水平触发模式</p>
</li>
</ol>
<h4 id="ET模式-edge-triggered"><a href="#ET模式-edge-triggered" class="headerlink" title="ET模式 edge-triggered"></a>ET模式 edge-triggered</h4><p>边缘触发模式</p>
<h2 id="信号驱动式I-O"><a href="#信号驱动式I-O" class="headerlink" title="信号驱动式I/O"></a>信号驱动式I/O</h2><ol>
<li>进程发起系统调用sigaction，安一个信号处理函数，内核立即返回，进程继续工作</li>
<li>直到数据可读，内核向进程发起SIGIO信号</li>
<li>进程重新发起recvfrom系统调用，数据从内核缓冲区复制到进程缓冲区</li>
<li>内核返回成功，进程处理返回的数据</li>
</ol>
<h2 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h2>]]></content>
  </entry>
  <entry>
    <title>Gradle</title>
    <url>/2020/08/15/gradle-base/</url>
    <content><![CDATA[<p>从maven到gradle，我变强了，也变秃了</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="仓库镜像"><a href="#仓库镜像" class="headerlink" title="仓库镜像"></a>仓库镜像</h3><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h3><p>在gradle中，任何组件都基于两个概念<code>Project</code>和<code>Task</code>。每一个build都是由一个或者多个project组成。一个project是什么，取决于你用它来做什么，典型的project可以表示一个JAR包或者Web应用。一个project不一定要用来构建什么，只代表用来做什么。每一个project由一个或者几个task组成。<br><code>gradle build</code>命令会在当前目录下寻找<code>build.gradle</code>文件，gradle的task和Ant工具的target类似，但是更强大，在task中可以使用Groovy和Kotlin。Groovy、Kotlin的好处不仅可以用来定义task，还可以动态添加任务。</p>
<h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p><code>Ant task</code>在gradle中是一类公民。gradle通过简单的依赖Groovy实现对Ant task的整合。在gradle中使用Ant task比在build.xml中更方便、更强大。<br>多项目中，gradle父目录下build.gradle脚本buildscript()方法声明的dependencies依赖在所有的子项目中都可以使用。每个project都有一个默认的<code>buildEnvironment</code>任务。<br>gradle提供了<code>enhanced tasks</code>，这些任务要么是自定义的，要么是内置的。</p>
<h3 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h3><p>二进制插件、DSL插件</p>
<h4 id="插件使用限制"><a href="#插件使用限制" class="headerlink" title="插件使用限制"></a>插件使用限制</h4><h4 id="插件版本管理"><a href="#插件版本管理" class="headerlink" title="插件版本管理"></a>插件版本管理</h4><h4 id="插件解析规则"><a href="#插件解析规则" class="headerlink" title="插件解析规则"></a>插件解析规则</h4><h4 id="结合buildScript"><a href="#结合buildScript" class="headerlink" title="结合buildScript"></a>结合buildScript</h4><h4 id="脚本插件"><a href="#脚本插件" class="headerlink" title="脚本插件"></a>脚本插件</h4><h4 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h4><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2>]]></content>
  </entry>
  <entry>
    <title>gRPC协议</title>
    <url>/2020/08/15/net-grpc/</url>
    <content><![CDATA[<p>gRPC是一个可以应用在任何场景的开源框架，提供跨数据中心之间的高效通信。可以说解决了分布式计算的“最后一公里”问题。可插拔特性支持负载均衡、可跟踪、健康检查、认证</p>
<a id="more"></a>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>主要应用场景</p>
<ol>
<li>跨语言微服务系统之间的高效连接</li>
<li>手机端、浏览器到服务端的通信</li>
<li>生成高效的skd lib</li>
</ol>
<h2 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h2><ol>
<li>sdk lib支持10种语言</li>
<li>无线环境更高效，服务开发简单</li>
<li>基于http/2支持双向通信</li>
<li>可插拔特性</li>
</ol>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="https://impwang.oss-cn-beijing.aliyuncs.com/gRPC-1.svg" alt="通信模型"><br>server端：实现接口，处理客户端请求<br>client端：stub提供和server相同的方法</p>
<h3 id="通信类型、生命周期"><a href="#通信类型、生命周期" class="headerlink" title="通信类型、生命周期"></a>通信类型、生命周期</h3><h4 id="单向通信-unary-rpc"><a href="#单向通信-unary-rpc" class="headerlink" title="单向通信(unary rpc)"></a>单向通信(unary rpc)</h4><p>client发起请求，server返回结果</p>
<ol>
<li>client调用stub方法，sever收到通知(metadata、方法名、指定的deadline)–client发起调用</li>
<li>server要么直接返回自身初始化的metadata(需要在所有response之前返回)；或者等待client请求信息</li>
<li>server收到client request信息后，创建response并填充属性，返回response、状态信息、trailing metadata(可选的)</li>
<li>rpc完成<h4 id="Server流RPC"><a href="#Server流RPC" class="headerlink" title="Server流RPC"></a>Server流RPC</h4>client一次请求，sever返回流消息，client进行解析直到结束，在一次rpc请求中，gRPC保证流消息的顺序性<h4 id="Server流RPC-1"><a href="#Server流RPC-1" class="headerlink" title="Server流RPC"></a>Server流RPC</h4>client写入流消息请求，sever解析流消息返回消息，client结束，同样在一次rpc请求中，gRPC保证流消息的顺序性<h4 id="双向流消息通信"><a href="#双向流消息通信" class="headerlink" title="双向流消息通信"></a>双向流消息通信</h4></li>
</ol>
<h4 id="Deadlines-Timeouts"><a href="#Deadlines-Timeouts" class="headerlink" title="Deadlines/Timeouts"></a>Deadlines/Timeouts</h4><p>client: 可以指定RPC超时时间，如果超时后未收到响应，则被终止，同时抛出<code>DEADLINE_EXCEEDED</code>错误<br>server: 可以查询某个特定的RPC请求是否已经超时、完成某个RPC请求还需要多长时间</p>
<p><strong>注意</strong> </p>
<ol>
<li>client和server端是相互独立的，可能client端成功了，但是server仍然失败。</li>
<li>client/server都可以取消RPC，取消会快速终止RPC请求，但是终止之前的任何动作不会回滚</li>
</ol>
<h4 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h4><p>Metadata是一个RPC请求的所有信息，是一些key(String)-value(String/二进制数据)的键值对</p>
<h4 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h4><p>channel在创建client hub的时候被创建，以指定的ip:port提供到server的连接。client可以修改channel参数，例如是否开启对传输数据的压缩。一个channel包括两种状态：connected和idle</p>
<p><strong>注意</strong> gRPC支持同步阻塞、异步非阻塞模式通信</p>
<h3 id="gRPC和protocol-buffers的关系"><a href="#gRPC和protocol-buffers的关系" class="headerlink" title="gRPC和protocol buffers的关系"></a>gRPC和protocol buffers的关系</h3><p>默认情况下，gRPC使用protocol buffers作为接口定义语言(IDL)、底层通信数据格式。protocol buffers已经是一种成熟的序列化机制。<br>工作机制：</p>
<ol>
<li><p>首先在<code>proto</code>中定义序列化对象的结构</p>
 <figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">hello.proto</span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloRequest</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> greeting = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloResponse</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> reply = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用编译器<code>protoc</code>指定语言编译<code>.proto</code>文件生成class文件，该class类被用在应用程序中</p>
</li>
</ol>
<p><a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">protocol buffers的详细介绍</a></p>
<h2 id="java实现的Demo"><a href="#java实现的Demo" class="headerlink" title="java实现的Demo"></a>java实现的Demo</h2><h2 id="Nginx对gRPC的支持"><a href="#Nginx对gRPC的支持" class="headerlink" title="Nginx对gRPC的支持"></a>Nginx对gRPC的支持</h2>]]></content>
      <tags>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis新特性概览</title>
    <url>/2020/08/13/a-overview-redis/</url>
    <content><![CDATA[<p>“在我的后园，可以看见墙外有两株树，一株是枣树，还有一株也是枣树。” –鲁迅《秋夜》<br>好了，现在看看Redis为什么使用单线程。Redis6.0已经改成多线程了！</p>
<a id="more"></a>
<p>“纸上得来终觉浅，绝知此事要躬行”。所有的新特性都要亲身体验一下才会更深刻</p>
<h2 id="Redis3"><a href="#Redis3" class="headerlink" title="Redis3"></a>Redis3</h2><h2 id="Redis4"><a href="#Redis4" class="headerlink" title="Redis4"></a>Redis4</h2><p>新特性变更历史：</p>
<blockquote>
<p>增加内存碎片整理</p>
</blockquote>
<h2 id="Redis5"><a href="#Redis5" class="headerlink" title="Redis5"></a>Redis5</h2><h2 id="Redis6"><a href="#Redis6" class="headerlink" title="Redis6"></a>Redis6</h2><p>Redis6对很多关键的地方做了修改，是历史上最大的更新版本<br><a href="https://raw.githubusercontent.com/redis/redis/6.0/00-RELEASENOTES" target="_blank" rel="noopener">官方</a></p>
<p>新特性变更历史：</p>
<blockquote>
<p>模块系统新增了很多API允许实现一些过去不可能实现的功能。可以在RDB文件中存储任意数据，针对server事件，可以捕获、重写执行命令<br>过期周期重写可以更快地淘汰到期的keys<br>所有的channel都支持SSL<br>ACL权限控制，可以定义users可以只使用某些命令、某些keys<br>新增了协议<code>RESP3</code><br>server端新增对client缓存的支持(仍处于实现性阶段)<br>可以使用多线程处理I/O(选择性)，单实例中pipelining不可用时，每个线程允许2倍的操作<br>支持无磁盘复制，第一次同步加载RDB文件时可以直接从socket加载到内存<br>redis-benchmark支持集群模式<br>SRANDMEMBER和相同的命令支持更好的分布<br>系统层面支持重写rewritten<br>新增集群代理(redis cluster proxy)</p>
</blockquote>
<p>细节：</p>
<blockquote>
<p>ACL LOG:权限控制日志<br>client端缓存重新设计：keys命令不再缓存slots；Broadcasting模式；OPTIN/OPTOUT模式<br>持久化较少的实例之间，用于复制的RDB文件被移除</p>
<p>新命令：LCS (Longest Common Subsequence)<br>复制过程支持MULTI/EXEC命令<br>RDB加载速度提升</p>
</blockquote>
<blockquote>
<p>linux/bsd上支持设置’CPU亲缘性’(将4个线程设置在4个CPU上)<br>client端缓存：在Server Info中添加’Tracking Prefix Number Stats’<br>redis-benchmark增加–user权限控制</p>
</blockquote>
<blockquote>
<p>添加LPOS命令搜索list<br>redis-cli端添加TLS参数–pipe, –rdb,  –replica<br>添加TLS会话缓存配置</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Flutter使用SkSL预热优化编译(译)</title>
    <url>/2020/08/09/flutter-sksl/</url>
    <content><![CDATA[<p>原文地址：<a href="https://github.com/flutter/flutter/wiki/Reduce-shader-compilation-jank-using-SkSL-warm-up" target="_blank" rel="noopener">https://github.com/flutter/flutter/wiki/Reduce-shader-compilation-jank-using-SkSL-warm-up</a></p>
<p>Flutter app在第一次启动的时候通常比较糟糕，SkSL(Skia Shader Laguage)渲染预热技术可以加速超过2倍的速度。</p>
<a id="more"></a>
<p>shader通常是运行在GPU上的一段程序。当一个shader第一次运行的时候，需要先编译。编译时间在几百毫秒，流畅的动画需要在’60FPS/16s’，所以导致数十倍的帧丢失，FPS可以从60降到6。轨迹中<code>GrGLProgramBuilder::finalize</code>就是最好的证据。</p>
<h2 id="SkSL预热"><a href="#SkSL预热" class="headerlink" title="SkSL预热"></a>SkSL预热</h2><p>Flutter提供了命令行工具可以查看哪些shaders需要使用SkSL技术，SkSL可以被打包到app，在用户第一次打开app进行预热从而减少编译时间。<br>使用步骤：</p>
<ol>
<li><code>flutter run --profile --cache-sksl</code></li>
<li>操作app触发所有需要运行动画的地方</li>
<li>在运行<code>flutter run</code>的命令行输入<code>M</code>将SkSL shaders保存到本地文件<code>flutter_01.sksl.json</code></li>
<li><p>使用SkSL预热技术编译app</p>
 <figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">flutter build apk --bundle-sksl-path flutter_01<span class="selector-class">.sksl</span><span class="selector-class">.json</span> <span class="keyword">for</span> Android</span><br><span class="line">flutter build ios --bundle-sksl-path flutter_01<span class="selector-class">.sksl</span><span class="selector-class">.json</span> <span class="keyword">for</span> iOS.</span><br></pre></td></tr></table></figure>
</li>
<li><p>app编译完成</p>
</li>
</ol>
<p>注意：可以在app整合一些测试用例用一个命令来完成<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">flutter drive --profile --cache-sksl --write-sksl-on-<span class="keyword">exit</span> flutter_01.sksl.json -t test_driver<span class="regexp">/app.dart</span></span><br></pre></td></tr></table></figure></p>
<p>以<a href="https://github.com/flutter/flutter/tree/master/dev/integration_tests/flutter_gallery" target="_blank" rel="noopener">Flutter gallery</a>为例，使用测试用例整合到CI，每次提交后都会产生SkSLs验证性能</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="为什么不预热所有的shaders"><a href="#为什么不预热所有的shaders" class="headerlink" title="为什么不预热所有的shaders"></a>为什么不预热所有的shaders</h3><p>如果只有有限的shaders，可以事先预热所有的shaders。实际中为了最优的性能，Flutter后台运行的Skia GPU可以在运行中根据参数(例如, draws, device models, and driver versions)动态的生成shaders。由于各种参数的组合，shaders的数量可能是指数级别的。</p>
<h3 id="从一台设备捕获的SkSL是否可以帮助着shader在另一台设备上进行编译"><a href="#从一台设备捕获的SkSL是否可以帮助着shader在另一台设备上进行编译" class="headerlink" title="从一台设备捕获的SkSL是否可以帮助着shader在另一台设备上进行编译"></a>从一台设备捕获的SkSL是否可以帮助着shader在另一台设备上进行编译</h3><p>理论上并不保障，但是如果跨设备不兼容也不会导致问题。实际上，SkSL即使在以下场景表现也出奇的好:<br>(1) 从iOS获取的SkSLs应用在Android设备上<br>(2) 从模拟器获取的SkSLs应用在手机上<br>目前，由于Flutter实验室只有有限的设备，并没有足够的数据，不能提供足够的跨设备案例。</p>
<h3 id="SkSL在新版iPhones上不起作用"><a href="#SkSL在新版iPhones上不起作用" class="headerlink" title="SkSL在新版iPhones上不起作用"></a>SkSL在新版iPhones上不起作用</h3><p>对于所有iOS设备来说，FLutter最近从OpenGL迁移到Metal上。但是SkSL只是针对OpenGL实现了预热功能，所以SkSL技术默认只对老版本的iOS设备有用。</p>
]]></content>
  </entry>
  <entry>
    <title>MySQL新特性概览</title>
    <url>/2020/05/12/a-overview-mysql/</url>
    <content><![CDATA[<p>以前一直存在一个观念：自己是Javaer，对MySQL不需要过多的理解。侧面反映还是接触的数据量太小，对细节把握得不够。到了5年这个坎，真的需要对必备技能做到满输出了。</p>
<a id="more"></a>
<h2 id="mysql5-6"><a href="#mysql5-6" class="headerlink" title="mysql5.6"></a>mysql5.6</h2><h2 id="mysql5-7"><a href="#mysql5-7" class="headerlink" title="mysql5.7"></a>mysql5.7</h2><h2 id="mysql8-0"><a href="#mysql8-0" class="headerlink" title="mysql8.0"></a>mysql8.0</h2>]]></content>
  </entry>
  <entry>
    <title>thinking-in-2020</title>
    <url>/2020/01/16/thinking-in-2020/</url>
    <content><![CDATA[<p>这篇博客拖了好久，总想说点什么，可写了三言两语不知道写点什么<br>五年了！IT这个行业3年、5年、10年，每一步都是一个坎，在这个点，你需要做成什么样子，掌握什么样的技术，都是一个决定性的时刻。回顾我这5年来，从行业小白到现在的废柴，虽然命途多舛，但依然抱着一颗改变世界的心去“跳舞”。</p>
<p>在这个过程中，有激情，也有困惑。<br><a id="more"></a></p>
<h2 id="从技术角度去看"><a href="#从技术角度去看" class="headerlink" title="从技术角度去看"></a>从技术角度去看</h2><h2 id="非技术角度"><a href="#非技术角度" class="headerlink" title="非技术角度"></a>非技术角度</h2>]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>java永久代、元数据区</title>
    <url>/2019/11/14/java-jvm-permgen/</url>
    <content><![CDATA[<p>今天在维护一个jsp + tomcat的老项目中，开始使用JRE1.8运行，没有问题，切换到JRE1.7运行就报错:<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">java<span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span>: PermGen space</span><br></pre></td></tr></table></figure></p>
<p>添加运行时参数<code>-XX:MaxPermSize=512m</code>解决问题，这里涉及到jvm运行时内存的变化。</p>
<a id="more"></a>
<h2 id="永久代-Perm-Gen"><a href="#永久代-Perm-Gen" class="headerlink" title="永久代 Perm Gen"></a>永久代 Perm Gen</h2><p>PermGen存在于<code>jdk1.7-</code>版本中，主要存储内容：</p>
<blockquote>
<p>class类的名称、字段、方法<br>字节码<br>常量池<br>对象数组/类型数组的class<br>JIT编译后的class信息</p>
</blockquote>
<h2 id="元数据区-Metaspace"><a href="#元数据区-Metaspace" class="headerlink" title="元数据区 Metaspace"></a>元数据区 Metaspace</h2>]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中所有日志</title>
    <url>/2019/11/02/mysql-log/</url>
    <content><![CDATA[<p>mysql根据不同的用途划分了很多日志，系统崩溃日志、sql查询日志<br>慢查询日志、二进制日志(主从复制 binlog)、事务日志(undolog)、中继日志(relay log)</p>
<a id="more"></a>
<h2 id="error-log"><a href="#error-log" class="headerlink" title="error log"></a>error log</h2><p>错误日志默认是开启的<br>用途：</p>
<ol>
<li>记录MySQL启动、关闭过程中的信息</li>
<li>记录MySQL运行中错误</li>
<li>记录事件调度。比如<br>配置：<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">log</span>-<span class="keyword">error</span>=<span class="string">"filename.log"</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>查看命令：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'log_error%'</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="general-log"><a href="#general-log" class="headerlink" title="general log"></a>general log</h2><p>查询日志默认是关闭的<br>用途：</p>
<ol>
<li>记录MySQL运行中所有的查询操作<br>配置：<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">log-output</span>=FILE    <span class="comment"># 输出类型</span></span><br><span class="line"><span class="attr">general-log</span>=<span class="number">1</span>      <span class="comment"># </span></span><br><span class="line"><span class="attr">general_log_file</span>=<span class="string">"filename.log"</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>查看命令：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'general_log%'</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="slow-query-log"><a href="#slow-query-log" class="headerlink" title="slow query log"></a>slow query log</h2><p>慢查询日志默认是关闭的，记录超过<code>long_query_time</code>时长的查询。<br>用途：</p>
<ol>
<li>记录MySQL查询时间长的语句，方便排查性能问题</li>
</ol>
<p>配置：<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">log-output</span>=FILE</span><br><span class="line"><span class="attr">log_slow_queries</span>=<span class="number">1</span>    //MySQL <span class="number">5.6</span>将此参数修改为了slow_query_log</span><br><span class="line"><span class="attr">slow_query_log_file</span>=<span class="string">"filename.log"</span></span><br><span class="line"><span class="attr">long_query_time</span>=<span class="number">10</span>    //慢查的时长单位为秒，可以精确到小数点后<span class="number">6</span>位(微秒)</span><br></pre></td></tr></table></figure></p>
<p>查看命令：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'slow_query_log%'</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h2><p>默认关闭，常用于数据库崩溃恢复、主从复制<br>用途：</p>
<ol>
<li>记录MySQL运行过程中所有的DDL(修改数据库、数据表的语句)、DML(更新数据的语句)语句</li>
</ol>
<p>刷盘策略：<br>sync_binlog：控制每次事务提交时，Binlog日志多久刷新到磁盘上，可取值：0或者n(N为正整数)。<br>  不同取值会影响MySQL的性能和异常crash后数据能恢复的程度。当sync_binlog=1时，MySQL每次事务提交都会将binlog_cache中的数据强制写入磁盘。</p>
<p>配置：<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">log-bin</span>=<span class="string">"filename-bin"</span></span><br><span class="line"><span class="attr">max_binlog_size</span>=&#123;<span class="number">4096</span> .. <span class="number">1073741824</span>&#125;  // 设置二进制文件最大值</span><br><span class="line"><span class="attr">expire_logs_days</span> = <span class="number">5</span>       // 二进制文件在服务器保存天数</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>某事务所产生的日志信息只能写入一个二进制日志文件，因此，实际上的二进制日志文件可能大于这个指定的上限。<br><strong>注意：</strong><code>expire_logs_days</code>参数只有在MySQL重启、切换二进制文件时生效</p>
<h3 id="查看日志："><a href="#查看日志：" class="headerlink" title="查看日志："></a>查看日志：</h3><p><code>bin log</code>的物理文件存储在<code>data</code>目录下，类如<code>mysql-bin.000001</code>。二进制日志在一下3种情况下会写入到新的文件：</p>
<ol>
<li>MySQL重启</li>
<li>二进制文件容量达到最大值</li>
<li>手动执行命令<code>flush logs</code></li>
</ol>
<h4 id="1-原生命令行查询"><a href="#1-原生命令行查询" class="headerlink" title="1. 原生命令行查询"></a>1. 原生命令行查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">binlog</span> <span class="keyword">events</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">binlog</span> <span class="keyword">events</span> <span class="keyword">in</span> <span class="string">'mysql-bin.000002'</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">binlog</span> <span class="keyword">events</span> <span class="keyword">in</span> <span class="string">'mysql-bin.000002'</span>  <span class="keyword">from</span> <span class="number">107</span>;</span><br></pre></td></tr></table></figure>
<h4 id="2-工具查询"><a href="#2-工具查询" class="headerlink" title="2. 工具查询"></a>2. 工具查询</h4><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">mysqlbinlog</span></span> ../data/mysql-bin<span class="number">.000003</span></span><br></pre></td></tr></table></figure>
<h3 id="日志刷盘时间"><a href="#日志刷盘时间" class="headerlink" title="日志刷盘时间"></a>日志刷盘时间</h3><h3 id="清除二进制日志"><a href="#清除二进制日志" class="headerlink" title="清除二进制日志"></a>清除二进制日志</h3><p>清除所有日志（不存在主从复制关系）<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">mysql&gt; RESET MASTER<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>清除指定日志之前的所有日志<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">mysql&gt; PURGE <span class="keyword">MASTER</span> <span class="title">LOGS</span> TO 'mysql-bin.<span class="number">000003</span>';</span><br></pre></td></tr></table></figure></p>
<p>清除某一时间点前的所有日志<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">mysql&gt; PURGE <span class="keyword">MASTER</span> <span class="title">LOGS</span> BEFORE '<span class="number">2015</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>';</span><br></pre></td></tr></table></figure></p>
<p>清除 n 天前的所有日志<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">mysql&gt; PURGE <span class="keyword">MASTER</span> <span class="title">LOGS</span> BEFORE CURRENT_DATE - INTERVAL <span class="number">10</span> DAY;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong> </p>
<ol>
<li>不要使用<code>rm</code>命令手动删除</li>
</ol>
<h2 id="undolog-redolog"><a href="#undolog-redolog" class="headerlink" title="undolog/redolog"></a>undolog/redolog</h2><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>记录数据页的物理修改，所以一般是物理介质文件，用来恢复提交后的物理数据页，且只能恢复到最后一次commit提交的位置。<br>redo log包括两部分：内存中的、磁盘上的，假如系统奔溃/宕机，将会导致内存中数据丢失，在事务提交时，将该事务所有事务日志写入磁盘</p>
<h3 id="undo-log：记录事务信息，"><a href="#undo-log：记录事务信息，" class="headerlink" title="undo log：记录事务信息，"></a>undo log：记录事务信息，</h3><p>配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>刷盘策略：</p>
<ol>
<li>innodb_flush_method: 控制innodb数据文件、日志文件的打开和刷盘的方式。<blockquote>
<p>fsync<br>O_DIRECT(不经过系统内核buffer，直接从内存写入磁盘)。</p>
</blockquote>
</li>
<li><p>innodb_flush_log_at_trx_commit: 控制每次事务提交时，redo log的写盘和落盘策略，即如何将buffer中的日志刷盘到磁盘中。可取值：0、1、2，默认值为1。</p>
<blockquote>
<p>当innodb_flush_log_at_trx_commit=1时，每次事务提交，会等待buffer中的日志写到log文件并刷新到磁盘上才返回成功。这种方式即使系统崩溃也不会丢失数据，但是IO性能较差。<br>=0时，事务提交时，并不会刷盘，而是每隔1s进行一次刷盘：先写入os buffer，再写入磁盘。系统奔溃会导致丢失这1s的数据。<br>=2时，事务提交时，将数据写入os buffer，然后每隔1s后将数据从os buffer写入磁盘</p>
</blockquote>
</li>
<li><p>innodb_doublewrite：控制是否打开double writer功能，取值ON或者OFF。<br>当Innodb的page size默认16K，磁盘单次写的page大小通常为4K或者远小于Innodb的page大小时，发生了系统断电/os crash ，刚好只有一部分写是成功的，则会遇到partial page write问题，从而可能导致crash后由于部分写失败的page影响数据的恢复。InnoDB为此提供了Double Writer技术来避免partial page write的发生。</p>
</li>
</ol>
<h3 id="单实例模式"><a href="#单实例模式" class="headerlink" title="单实例模式"></a>单实例模式</h3><p>MySQL单实例，Binlog关闭场景：<br>  innodb_flush_log_at_trx_commit=1，innodb_doublewrite=ON时，能够保证不论是MySQL Crash 还是OS Crash 或者是主机断电重启都不会丢失数据。<br>MySQL单实例，Binlog开启场景：<br>  默认innodb_support_xa=ON，开启binlog后事务提交流程会变成两阶段提交，这里的两阶段提交并不涉及分布式事务，mysql把它称之为内部xa事务。<br>  当innodb_flush_log_at_trx_commit=1，<br>  sync_binlog=1，innodb_doublewrite=ON,<br>  innodb_support_xa=ON时，同样能够保证不论是MySQL Crash 还是OS Crash 或者是主机断电重启都不会丢失数据。</p>
<h3 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h3><h2 id="relay-log"><a href="#relay-log" class="headerlink" title="relay log"></a>relay log</h2><p>用于从数据库，从数据从主库申请复制数据时，从数据库先写relay log，然后再将数据从relay log写入数据库</p>
<h2 id="日志写入顺序"><a href="#日志写入顺序" class="headerlink" title="日志写入顺序"></a>日志写入顺序</h2><ol>
<li>数据修改前，写入缓存中的redo log中</li>
<li>修改记录数据</li>
<li>事务提交指令时，向redo log中写入日志，同时一次性写入缓存中的bin log</li>
<li>执行提交动作</li>
</ol>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2>]]></content>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务--网关(三)</title>
    <url>/2019/08/15/sc-zuul/</url>
    <content><![CDATA[<p>nginx、zuul、gateway、kong都是网关组件，基于不同的结构设计模式实现</p>
<a id="more"></a>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>nginx使用漏桶算法</p>
<p><code>limit_req_zone</code><br><code>limit_req_conn</code></p>
<h3 id="限流-1"><a href="#限流-1" class="headerlink" title="限流"></a>限流</h3><h2 id="Zuul1"><a href="#Zuul1" class="headerlink" title="Zuul1"></a>Zuul1</h2><h3 id="过滤器Filter"><a href="#过滤器Filter" class="headerlink" title="过滤器Filter"></a>过滤器Filter</h3><p>按照生命周期大约有4种过滤器：</p>
<ol>
<li><p>pre </p>
</li>
<li><p>routing</p>
</li>
<li><p>post </p>
</li>
<li><p>error</p>
</li>
</ol>
<h3 id="限流-2"><a href="#限流-2" class="headerlink" title="限流"></a>限流</h3><p>主流的有4种限流方式：</p>
<ol>
<li>根据认证用户</li>
<li>根据原始请求</li>
<li>根据URL</li>
<li>根据ServiceId</li>
</ol>
<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>zuul-ratelimit</p>
<h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><h3 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h3><p>zuul默认整合了ribbon实现路由</p>
<p>配置属性：<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    loadbalancer:</span></span><br><span class="line"><span class="attr">      retry:</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">true</span>  <span class="comment"># ribbon重试默认已经开启</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="comment"># 重试必配，据说在Brixton.SR5版的spring cloud中该配置默认是true，结果在Dalston.SR1中看到的是false</span></span><br><span class="line"><span class="attr">  retryable:</span> <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="attr">  ConnectTimeout:</span> <span class="number">250</span>   <span class="comment"># ribbon重试超时时间</span></span><br><span class="line"><span class="attr">  ReadTimeout:</span> <span class="number">1000</span>     <span class="comment"># 建立连接后的超时时间</span></span><br><span class="line"><span class="attr">  OkToRetryOnAllOperations:</span> <span class="literal">true</span>  <span class="comment"># 对所有操作请求都进行重试</span></span><br><span class="line"><span class="attr">  MaxAutoRetriesNextServer:</span> <span class="number">2</span>  <span class="comment"># 重试负载均衡其他的实例最大重试次数，不包括首次server</span></span><br><span class="line"><span class="attr">  MaxAutoRetries:</span> <span class="number">1</span>  <span class="comment"># 同一台实例最大重试次数，不包括首次调用</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>熔断器的超时时间<code>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</code>需要大于ribbon的超时时间，否则不会触发重试</p>
<h4 id="垮zone重试"><a href="#垮zone重试" class="headerlink" title="垮zone重试"></a>垮zone重试</h4><h2 id="Zuul2"><a href="#Zuul2" class="headerlink" title="Zuul2"></a>Zuul2</h2><table>
<thead>
<tr>
<th>对比</th>
<th style="text-align:center">Zuul1</th>
<th style="text-align:center">Zuul2</th>
<th style="text-align:center">Gateway</th>
</tr>
</thead>
<tbody>
<tr>
<td>同步</td>
<td style="text-align:center">阻塞</td>
<td style="text-align:center">异步非阻塞</td>
<td style="text-align:center">非阻塞</td>
</tr>
<tr>
<td>整合SpringCloud</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td>限流</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td>自定义filter</td>
<td style="text-align:center">-</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持(内置了很多filter)</td>
</tr>
</tbody>
</table>
<h2 id="Kong"><a href="#Kong" class="headerlink" title="Kong"></a>Kong</h2><p>kong可以说是nginx的升级版，基于OpenResty。</p>
<h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><ol>
<li>upstream</li>
<li>target</li>
<li>service</li>
<li>route</li>
</ol>
]]></content>
      <tags>
        <tag>网关</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux--零拷贝</title>
    <url>/2019/06/17/linux-zerocopy/</url>
    <content><![CDATA[<p>linux中的零拷贝技术</p>
<a id="more"></a>
<h2 id="I-O原理"><a href="#I-O原理" class="headerlink" title="I/O原理"></a>I/O原理</h2><p>普通I/O：应用程序或者运行在用户模式下的库函数访问硬件设备时，I/O操作需要</p>
<ol>
<li>硬件和系统之间的零拷贝</li>
<li>软件和系统之间的零拷贝</li>
</ol>
<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><h4 id="SIGBUS中断"><a href="#SIGBUS中断" class="headerlink" title="SIGBUS中断"></a>SIGBUS中断</h4><p>其他进程同时对文件的操作导致write系统调用中断</p>
<p>解决方法：</p>
<p>方案1. 增加SIGBUS错误信号处理<br>方案2. 对文件加锁，当有其它的进程对文件进行操作时，触发SIGBUS中断</p>
<h2 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h2><h3 id="局限性-1"><a href="#局限性-1" class="headerlink" title="局限性"></a>局限性</h3><h4 id="数据污染"><a href="#数据污染" class="headerlink" title="数据污染"></a>数据污染</h4><p>叶缓存可能被污染</p>
<h2 id="改进版sendfile"><a href="#改进版sendfile" class="headerlink" title="改进版sendfile"></a>改进版sendfile</h2><p>文件描述符拷贝</p>
<h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>FileChannel类</p>
<p>MappedByteBuffer类</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat--类加载模型(五)</title>
    <url>/2019/06/16/tomcat-classloader/</url>
    <content><![CDATA[<p>tomcat类加载器破坏了jvm的双亲委派机制</p>
<a id="more"></a>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.catalina.startup;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Daemon reference.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">Object</span> catalinaDaemon = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">ClassLoader commonLoader = <span class="keyword">null</span>;</span><br><span class="line">ClassLoader catalinaLoader = <span class="keyword">null</span>;</span><br><span class="line">ClassLoader sharedLoader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> initClassLoaders() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        commonLoader = createClassLoader(<span class="string">"common"</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (commonLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// no config file, default to this loader - we might be in a 'single' env.</span></span><br><span class="line">            commonLoader = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        catalinaLoader = createClassLoader(<span class="string">"server"</span>, commonLoader);</span><br><span class="line">        sharedLoader = createClassLoader(<span class="string">"shared"</span>, commonLoader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        handleThrowable(t);</span><br><span class="line">        <span class="built_in">log</span>.error(<span class="string">"Class loader creation threw exception"</span>, t);</span><br><span class="line">        System.<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>类加载器</th>
<th style="text-align:center">tomcat可见性</th>
<th style="text-align:center">webapp可见性</th>
</tr>
</thead>
<tbody>
<tr>
<td>commonLoader</td>
<td style="text-align:center">可见</td>
<td style="text-align:center">可见</td>
</tr>
<tr>
<td>catalinaLoader</td>
<td style="text-align:center">可见</td>
<td style="text-align:center">不可见</td>
</tr>
<tr>
<td>sharedLoader</td>
<td style="text-align:center">不可见</td>
<td style="text-align:center">可见</td>
</tr>
<tr>
<td>WebappClassLoader</td>
<td style="text-align:center">不可见</td>
<td style="text-align:center">只对当前web可见</td>
</tr>
</tbody>
</table>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ol>
<li>jar类库隔离：tomcat可以部署多个应用，如果引用多个不同版本的jar，类实现不同，所以需要加载不同的jar包</li>
<li>jar类库共享：如果jar版本相同，则只加载一份</li>
<li>安全隔离：tomcat自身的类加载器和web应用的类加载器隔离</li>
<li>热加载：jsp修改后不需要重启也可以刷新，这样就需要动态加载jsp文件</li>
</ol>
]]></content>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat启动流程(二)</title>
    <url>/2019/06/15/tomcat-startup/</url>
    <content><![CDATA[<p>tomcat启动流程</p>
<a id="more"></a>
<h2 id="Bootstrap类启动"><a href="#Bootstrap类启动" class="headerlink" title="Bootstrap类启动"></a>Bootstrap类启动</h2><p>tomcat支持多种方式启动，最常用、最稳定的是基于<code>server.xml</code>方式的启动，实现类Bootstrap。</p>
<h2 id="Tomcat类启动"><a href="#Tomcat类启动" class="headerlink" title="Tomcat类启动"></a>Tomcat类启动</h2><p>Tomcat类用于内嵌tomcat的最小化启动</p>
<p>条件:</p>
<ul>
<li>所有的class、servlet文件都在classpath路径下</li>
<li>需要临时的工作目录</li>
<li>不需要配置文件，<code>web.xml</code>文件是可选的，Tomcat类提供了设置方法</li>
</ul>
<p>提供了各种配置servlet和webapp的方法，默认创建一个内存安全域。如果需要更复杂的安全设置，可以自己实现一个继承Tomcat的子类</p>
<p>提供了一系列方法(例如addWebapp)用来配置<code>web context</code>，然后创建并添加到<code>Host</code>，并不使用全局的web.xml，同时添加一个<code>lifecycle</code>监听器，监听器添加默认的Servlet、JSP文件。</p>
<p>在更复杂的场景，可能更喜欢使用API来创建Context。如果模拟<code>addWebapp</code>方法的行为，则需要调用两个方法 <code>getDefaultWebXmlListener()</code>和<code>noDefaultWebXmlPath()</code>。</p>
<p> <code>getDefaultWebXmlListener()</code>返回一个LifecycleListener监听器，如果添加了这个监听器，则必须禁止使用全局的<code>web.xml</code>。</p>
<p> <code>noDefaultWebXmlPath()</code>返回一个虚假路径阻止ContextConfig配置全局<code>web.xml</code>。</p>
]]></content>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat--设计模式(四)</title>
    <url>/2019/06/13/tomcat-pattern/</url>
    <content><![CDATA[<p>设计模式总共有23种：</p>
<ol>
<li></li>
<li></li>
<li></li>
</ol>
<p>设计模式规则：<br>把需要变化的部分独立出来，不要和不变的混在一起<br>针对接口编程，而不是针对实现编程<br>多用组合，少用继承<br>开放-关闭原则：类应该对扩展开放，对修改关闭<br>依赖倒置原则：<br>最少知识原则：减少对象之间的交互</p>
<a id="more"></a>
<p>Tomcat中的设计模式一共有</p>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>目的：将一个接口转换成另一个接口<br>规律：如果遵守规范的话，一般Adapter结尾的类都是典型的适配器<br>核心类 Adapter、CoyoteAdapter、Connector</p>
<h2 id="门面模式-外观模式"><a href="#门面模式-外观模式" class="headerlink" title="门面模式/外观模式"></a>门面模式/外观模式</h2><p>目的：让接口更简单<br>规律：如果遵守规范的话，一般Facade结尾的类都是典型的门面<br>核心类 ServletConfig、StandardWrapper、StandardWrapperFacade</p>
<h2 id="监听模式-观察者模式"><a href="#监听模式-观察者模式" class="headerlink" title="监听模式/观察者模式"></a>监听模式/观察者模式</h2><p>核心类 Lifecycle、LifecycleBase、LifecycleListener、LifecycleEvent、ContextConfig、EngineConfig、HostConfig</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>我个人来看StandardHost的实现有命令模式的影子<br>核心类 Lifecycle、LifecycleBase、StandardHost</p>
]]></content>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat请求过程--NIO(三)</title>
    <url>/2019/06/13/tomcat-nio/</url>
    <content><![CDATA[<p>tomcat处理请求的NIO是基于jdk的NIO操作</p>
<a id="more"></a>
]]></content>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务--路由器(五)</title>
    <url>/2019/06/12/sc-ribbon/</url>
    <content><![CDATA[<p>在wei服务中刚开始使用dubbo通信，后来改为ribbon/feign，feign实际上是在ribbon上又封装了一层</p>
<a id="more"></a>
<h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h4 id="轮询策略"><a href="#轮询策略" class="headerlink" title="轮询策略"></a>轮询策略</h4><h4 id="随机策略"><a href="#随机策略" class="headerlink" title="随机策略"></a>随机策略</h4><h4 id="可用过滤策略-AvailabilityFilteringRule"><a href="#可用过滤策略-AvailabilityFilteringRule" class="headerlink" title="可用过滤策略(AvailabilityFilteringRule)"></a>可用过滤策略(AvailabilityFilteringRule)</h4><p>过滤掉连接失败的服务节点，并且过滤掉高并发的服务节点，然后从健康的服务节点中，使用轮询策略选出一个节点返回。</p>
<h4 id="响应时间权重策略-WeightedResponseTimeRule"><a href="#响应时间权重策略-WeightedResponseTimeRule" class="headerlink" title="响应时间权重策略(WeightedResponseTimeRule)"></a>响应时间权重策略(WeightedResponseTimeRule)</h4><p>根据响应时间，分配一个权重weight，响应时间越长，weight越小，被选中的可能性越低。</p>
<h4 id="轮询失败重试策略-RetryRule"><a href="#轮询失败重试策略-RetryRule" class="headerlink" title="轮询失败重试策略(RetryRule)"></a>轮询失败重试策略(RetryRule)</h4><p>首先使用轮询策略进行负载均衡，如果轮询失败，则再使用轮询策略进行一次重试，相当于重试下一个节点，看下一个节点是否可用，如果再失败，则直接返回失败。</p>
<p>重试的时间间隔，默认是500毫秒</p>
<h4 id="并发量最小可用策略（BestAvailableRule）"><a href="#并发量最小可用策略（BestAvailableRule）" class="headerlink" title="并发量最小可用策略（BestAvailableRule）"></a>并发量最小可用策略（BestAvailableRule）</h4><p>选择一个并发量最小的server返回。<br>如何判断并发量最小呢？ServerStats有个属性activeRequestCount，这个属性记录的就是server的并发量。轮询所有的server，选择其中activeRequestCount最小的那个server，就是并发量最小的服务节点。</p>
<h4 id="ZoneAvoidanceRule"><a href="#ZoneAvoidanceRule" class="headerlink" title="ZoneAvoidanceRule"></a>ZoneAvoidanceRule</h4><p>策略描述：复合判断server所在区域的性能和server的可用性，来选择server返回。</p>
<h3 id="自定义负载均衡策略"><a href="#自定义负载均衡策略" class="headerlink" title="自定义负载均衡策略"></a>自定义负载均衡策略</h3><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><h2 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h2>]]></content>
  </entry>
  <entry>
    <title>Redis中的跳表(二)</title>
    <url>/2019/06/07/redis-skiplist/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>skiplist</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis哨兵机制(七)</title>
    <url>/2019/06/07/redis-election/</url>
    <content><![CDATA[<p>redis引入了哨兵机制</p>
<a id="more"></a>
<h2 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h2><h3 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h3><p>启动哨兵机制，可以对主从数据库进行监控</p>
<h3 id="一主多从"><a href="#一主多从" class="headerlink" title="一主多从"></a>一主多从</h3><p>启动多个哨兵(建议3个，并且使用奇数个哨兵)，可以对主从数据库进行监控，哨兵之间也可以互相通信。<br>哨兵主要功能：</p>
<ol>
<li>监控：监控master和slave是否运行正常</li>
<li>提醒：某个redis出现故障，可以发起通知</li>
<li>自动故障转移：当一个master不能正常工作时，将master下其中一个slave转为master</li>
</ol>
<p>补充：为什么哨兵至少3个？</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>每个哨兵会向其它哨兵、master、slave定时发送消息，保持心跳。如果指定时间未回应，则认为对方<strong>主观下线</strong>；若多数哨兵都认为某一服务没响应，则认为<strong>客观下线</strong></p>
<h2 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h2><p>用于接收master是否下线的消息</p>
<h2 id="选举master协议"><a href="#选举master协议" class="headerlink" title="选举master协议"></a>选举master协议</h2><p>用来决定是否执行故障转移，以及slave中的选主<br>选主会有两个过程：</p>
<h3 id="Sentinel哨兵选出leader"><a href="#Sentinel哨兵选出leader" class="headerlink" title="Sentinel哨兵选出leader"></a>Sentinel哨兵选出leader</h3><p>当某个哨兵节点确认master主管下线后，发出广播请求其它哨兵选举自己为leader，<br>被请求的哨兵如果没有选举过其它哨兵的请求，则同意该请求，否则不同意<br>当哨兵节点票数达到Max(quorum, num(sentinel)/2 + 1)，则升级为leader</p>
<h3 id="Sentinel-Leader选举主节点master"><a href="#Sentinel-Leader选举主节点master" class="headerlink" title="Sentinel Leader选举主节点master"></a>Sentinel Leader选举主节点master</h3><p>master选举：</p>
<image src="https://impwang.oss-cn-beijing.aliyuncs.com/redis/redis-leader.png">

<p>slave-priority在conf中配置</p>
</image>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper基于TCP的FastLeader(四)</title>
    <url>/2019/06/06/zk-fastleader3/</url>
    <content><![CDATA[<p>TCP选举算法</p>
<a id="more"></a>
<h2 id="核心结构"><a href="#核心结构" class="headerlink" title="核心结构"></a>核心结构</h2><h3 id="myid"><a href="#myid" class="headerlink" title="myid"></a>myid</h3><p>对应服务器在集群中的唯一ID</p>
<h3 id="zxid"><a href="#zxid" class="headerlink" title="zxid"></a>zxid</h3><p>类似于事务ID，顺序递增</p>
<p>|  高32位  |  低32位  |<br>epoch_h：用于标记leader的epoch，从1开始，每次选举出新的leader<br>，epoch_h加1，</p>
<p>epoch_l：用于标记epoch_h内的版本，epoch_h改变后，epoch_l会被重置</p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>服务器状态：<br>looking：<br>leading：<br>following：<br>observing:</p>
<h3 id="选票数据结构"><a href="#选票数据结构" class="headerlink" title="选票数据结构"></a>选票数据结构</h3><p>选举领导时会进行投票，投票的数据结构：</p>
<p>logicClock: 表示该服务器发起的是第几轮投票，每个服务器都维护一个自增的logicClock<br>state: 当前服务器状态<br>self_id: 当前服务器的myid<br>self_zxid: zxid<br>vote_id: 被推选的的服务器的myid<br>vote_zxid: 被推选的服务器zxid</p>
<h2 id="选举流程"><a href="#选举流程" class="headerlink" title="选举流程"></a>选举流程</h2><p>选举过程很重要，也很复杂，做了一个流程图，不合理的回头补充：</p>
<image src="https://impwang.oss-cn-beijing.aliyuncs.com/zookeeper/FastLeaderElection%E9%80%89%E4%B8%BE%E5%8E%9F%E7%90%86.png">

<p>投票过程数据结构: (logicClock, myid, zxid)<br>投票箱存储结构：(投票服务器id, 被推选服务器id)</p>
</image>]]></content>
      <tags>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper选举算法基础(三)</title>
    <url>/2019/06/06/zk-election-base/</url>
    <content><![CDATA[<p>选举算法有多种</p>
<a id="more"></a>
<h2 id="选举算法"><a href="#选举算法" class="headerlink" title="选举算法"></a>选举算法</h2><p>electionAlg配置：</p>
<ol>
<li>0：基于UDP的LeaderElection</li>
<li>1：基于UDP的FastLeaderElection</li>
<li>2：基于UDP和认证的FastLeaderElection</li>
<li>3：基于TCP的FastLeaderElection(新版本默认算法)</li>
</ol>
]]></content>
      <tags>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper选举过程(五)</title>
    <url>/2019/06/06/zk-crash-election/</url>
    <content><![CDATA[<p>zk集群有正常启动过程，也会有leader/follower崩溃重启、网络分区问题，这样就导致需要重新选举</p>
<a id="more"></a>
<h2 id="正常集群启动选举"><a href="#正常集群启动选举" class="headerlink" title="正常集群启动选举"></a>正常集群启动选举</h2><h2 id="Leader重启选举"><a href="#Leader重启选举" class="headerlink" title="Leader重启选举"></a>Leader重启选举</h2><p>leader由于故障崩溃、或者网络分区导致不可连接。<br>选举流程图：</p>
<image src="https://impwang.oss-cn-beijing.aliyuncs.com/zookeeper/leader-2.png">

<h2 id="Follower重启选举"><a href="#Follower重启选举" class="headerlink" title="Follower重启选举"></a>Follower重启选举</h2><p>follower由于故障崩溃、或者网络分区导致不可连接。<br>选举流程图：</p>
<image src="https://impwang.oss-cn-beijing.aliyuncs.com/zookeeper/leader-3.png">
</image></image>]]></content>
      <tags>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper分布式锁(六)</title>
    <url>/2019/06/06/zk-lock/</url>
    <content><![CDATA[<p>zk典型的应用是可以作为分布式锁。</p>
<a id="more"></a>
<h2 id="zk分布式锁的特性"><a href="#zk分布式锁的特性" class="headerlink" title="zk分布式锁的特性"></a>zk分布式锁的特性</h2><p>zk作为分布式锁主要利用的还是临时节点、顺序性的特性</p>
<ol>
<li>最多只有一个获取锁：最多只有一个进程获取锁</li>
<li>释放锁：获取锁的进程可以主动释放锁；进程宕机后也可以释放锁</li>
<li>锁重入：获取锁的进程在释放锁之前可以重新进入</li>
<li>感知释放锁：等待锁的进程可以感知到锁的释放，并且重新竞争锁</li>
</ol>
<h2 id="锁实现"><a href="#锁实现" class="headerlink" title="锁实现"></a>锁实现</h2><h3 id="公平式锁"><a href="#公平式锁" class="headerlink" title="公平式锁"></a>公平式锁</h3><p>基于临时节点 + 顺序性，这样创建相同的节点时，都可以创建成功，但是节点具有顺序性，每个获取锁的进程判断自己是否是最小顺序的节点来获取锁</p>
<h3 id="非公平式锁"><a href="#非公平式锁" class="headerlink" title="非公平式锁"></a>非公平式锁</h3><p>基于临时节点 + 非顺序性，这样创建相同的节点时，只能有一个创建成功，即获得锁</p>
<h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3>]]></content>
      <tags>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty传输协议</title>
    <url>/2019/06/05/netty-transport/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Netty编码解码</title>
    <url>/2019/06/05/netty-codec/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Netty概览(一)</title>
    <url>/2019/06/05/netty-base/</url>
    <content><![CDATA[<p>基于Netty4.1分支，可以看到代码已经非常复杂</p>
<a id="more"></a>
<p>netty结构图<br>基础部分：</p>
<image width="200" height="300" src="https://impwang.oss-cn-beijing.aliyuncs.com/netty/netty-base1.png">

<p>test组件：</p>
<image width="250" height="100" src="https://impwang.oss-cn-beijing.aliyuncs.com/netty/netty-base2.png">

<p>transport组件：</p>
<image width="250" height="100" src="https://impwang.oss-cn-beijing.aliyuncs.com/netty/netty-base3.png">

<h2 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h2><h2 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h2><p>示意图：</p>
<p>Reactor模型主要有2部分：</p>
<blockquote>
<p>Reactor：单独的线程，负责监听、分发事件，<br>Handlers：</p>
</blockquote>
<h4 id="1-单Reactor、单线程"><a href="#1-单Reactor、单线程" class="headerlink" title="1. 单Reactor、单线程"></a>1. 单Reactor、单线程</h4><h4 id="2-单Reactor、多线程"><a href="#2-单Reactor、多线程" class="headerlink" title="2. 单Reactor、多线程"></a>2. 单Reactor、多线程</h4><h4 id="3-主从Reactor、多线程"><a href="#3-主从Reactor、多线程" class="headerlink" title="3. 主从Reactor、多线程"></a>3. 主从Reactor、多线程</h4><p>模型：</p>
<blockquote>
<p>MainReactor：负责连接请求，把请求转交给SubReactor<br>SubReactor：负责相应Channel的I/O读写请求<br>非I/O请求则直接写入队列，等待worker threads(工作线程)处理</p>
</blockquote>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>传输服务，支持 BIO 和 NIO。<br>容器集成，支持 OSGI、JBossMC、Spring、Guice 容器。<br>协议支持，HTTP、Protobuf、二进制、文本、WebSocket、RTSP等，还支持通过实行编码解码逻辑来实现自定义协议。<br>Core 核心，可扩展事件模型、通用通信 API、支持零拷贝的 ByteBuf 缓冲对象。</p>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>Netty基于主从Reactor、多线程模型。</p>
<blockquote>
<p>bossGroup：线程池，在绑定某个端口后，从线程池获取一个线程处理Accept事件(相当于MainReactor)，这样每个端口对应一个Boss线程<br>workerGroup：线程池，SubReactor和Worker线程会共用该线程池</p>
</blockquote>
<h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>Bootstrap/ServerBootstrap<br>Future/ChannelFuture<br>Channel/ChannelHandler/ChannelPipline<br>Selector<br>NioEventLoop/NioEventLoopGroup</p>
<p>总结：从结构上看，核心功能主要有2个：</p>
<ol>
<li>I/O模型</li>
<li>解析协议(编码/解码)</li>
</ol>
</image></image></image>]]></content>
  </entry>
  <entry>
    <title>关于失去</title>
    <url>/2019/05/30/thinking-in-lost/</url>
    <content><![CDATA[<p>关于失去，说是老了也好，说是闲的也好，总之，这一刻，因为一些人，一些事儿。总想说点什么。</p>
<a id="more"></a>
<p>自从开始写代码这个行业，大多的时间忙于各种新技术的更新换代，怕自己被淘汰，就陷于无尽的焦虑当中。很少有时间享受读一本书，出去骑行的慢时光。即便这样，仍然面临被很多人拍死在沙滩上的处境。<br>最近得闲，因为某种原因，李志的专辑被全平台下线，网上遍寻，有幸发现一个网站《麦田音乐网》，这是一个运营了十多年的网站，而且是个人运营，很是惊讶，竟然还有这种佛系的地方。<br>大致浏览了一下，猜测站长应该是个很厉害、又有点文艺的人，我看大家称呼他鬼哥。网站中除了歌单，最精彩的地方是，还有个麦游记，然后就有很多人会写下自己的故事，感觉类似于那个很有创意的淘宝卖家《CY故事 • 一家卖故事的淘宝店》(有点忘了，可以去查了一下)，这些故事总能触动内心深处的某些东西。</p>
<p>网站有个很醒目的flag：”我没法像个农民那样善良，只是麦子还在对着太阳愤怒生长”，第一印象就是《麦田里的守望者》，然后一层一层的“扒光”，在留言本的地方，站长的：</p>
<blockquote>
<p>欢迎来到“麦田音乐网”，如果您有什么想说的话，请在这里留言！<br>麦田音乐网建于2006年，是一个简单纯粹的音乐、文字分享网站。<br>在浮躁、喧嚣的互联网中，希望你能在这里静下来。<br>网站取名于《麦田里的守望者》、《小王子》、海子的诗、梵高与麦田。<br>站长QQ:40589302 微信:linfox<br>微信公众号“麦音乐”：maiyinyue<br>不换友情链接。</p>
</blockquote>
<p>留言本下有些留言真的是别有意味，这种感觉恐怕就是旧友久别重逢而不曾遗忘的感觉吧。</p>
<blockquote>
<p>猪诺 2019-01-29    11:42 上午<br>初中时开始听，现在我研三即将毕业。一晃这么多年。<br>QQ上还加着你，但是QQ已经不用了。<br>走了好久，发现麦田还在，真好。</p>
</blockquote>
<p>在留言本后还有个淘宝店铺，也是十多年的老店，打开店铺，果然做生意也是很佛系的，我比较喜欢的是里面的文化衫，”grunge is dead”，”we are young”。真是一个很有趣的人。</p>
<p>总之，这是一个很有内容的网站，作为一个技术人，接触了太多的网站，这算是网站中的一股清流了。<br>意犹未尽之余，去查了一下”伍尔芙”，著名的一句话：“你不能通过逃避生活以寻找安宁，有机会读一下《海浪》”。<br>“科特柯本”，摇滚乐、朋克，这些东西没有系统的了解过，瞬间感觉自己的孤陋寡闻，不禁反思“我究竟是个有趣的人吗？”，因为最近也在读王小波，颇多感慨，也许自己还是太晚熟了，失去了太多宝贵的时间；<br>“麦田里的守望者”，这本书其实很早有了解，但是一直没读过，去豆瓣了解了一下，中间刘瑜老师在2009年的一条评论还是令人深思的，的确，生活有美好，也有颓废，但是不能只看到颓废。然后打开刘瑜老师的个人博客，域名早已变成一个机械公司的网站…</p>
<p>生活，究竟是什么？可能我们每个人都问过自己，也在不断的寻找答案，尤其是这个快速迭代的时代，很多的东西终会被新的事物掩盖，但是她的美好，或者对她的依恋，却仍然在散发着光辉。</p>
<p>就好像这个网站，有一天会不会突然不能用了？我不知道，但我会尽力维护下去，当成一种信仰。我想要看清这个世界！</p>
]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper原子广播协议ZAB(二)</title>
    <url>/2019/04/12/zk-zab/</url>
    <content><![CDATA[<p>ZAB 源自一致性协议</p>
<a id="more"></a>
<h2 id="Paxos协议"><a href="#Paxos协议" class="headerlink" title="Paxos协议"></a>Paxos协议</h2><p>Paxos(帕索克斯)：<br>Chubby技术架构</p>
<h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><p>ZAB(Zookeeper Atomic Broadcast)：ZooKeeper原子消息广播协议，因为paxos太过于复杂，zk基于paxos实现了ZAB协议</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol>
<li>保证各个服务器之间的数据一致性</li>
<li>leader节点无法工作后，ZAB协议自动从Follower节点中选举新的leader</li>
</ol>
<h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><p>写请求分为leader、follower/observer两种接收</p>
<h4 id="写leader"><a href="#写leader" class="headerlink" title="写leader"></a>写leader</h4><h4 id="写follower-observer"><a href="#写follower-observer" class="headerlink" title="写follower/observer"></a>写follower/observer</h4><p>follower/observer接收到写请求都会转发到leader，再由leader<br>做一些ACK机制处理</p>
<h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><p>leader/follower/observer都可以处理读请求，直接返回结果给客户端</p>
<h2 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h2><p>因为leader负责写操作，leader随时可能挂掉，接着进入选举过程，这个期间如何保证数据一致性</p>
<p>leader可能挂掉的场景：</p>
<ol>
<li>数据到达Leader节点前</li>
<li>数据到达 Leader 节点，但未复制到 Follower 节点</li>
<li>数据到达 Leader 节点，成功复制到 Follower 所有节点，但还未向 Leader 响应接收</li>
<li>数据到达 Leader 节点，成功复制到 Follower 部分节点，但还未向 Leader 响应接收</li>
<li>数据到达 Leader 节点，成功复制到 Follower 所有或多数节点，数据在 Leader 处于已提交状态，但在 Follower 处于未提交状态</li>
<li>数据到达 Leader 节点，成功复制到 Follower 所有或多数节点，数据在所有节点都处于已提交状态，但还未响应 Client</li>
<li>网络分区导致的脑裂情况，出现双 Leader</li>
</ol>
]]></content>
      <tags>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>关于写作</title>
    <url>/2019/03/23/thinking-in-writing/</url>
    <content><![CDATA[<p>关于我，对于感兴趣的事情，会尽力克服拖延症，带着乐趣去做一些事情。但是往往有时候因为忙或者其他原因，一直拖延，直到欠下的债太多，才会强迫自己重新开始。</p>
<a id="more"></a>
<p>写作其实是一件很费力的事情，尤其是写技术博客，更是需要很多精力，关于写的一些东西，有时间会结合一些方法论补充一下。强化一下自己的写作意识:(待续…</p>
]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet Web容器</title>
    <url>/2019/02/12/tomcat-jetty-undertow/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h2><h2 id="jetty"><a href="#jetty" class="headerlink" title="jetty"></a>jetty</h2><h2 id="undertow"><a href="#undertow" class="headerlink" title="undertow"></a>undertow</h2>]]></content>
  </entry>
  <entry>
    <title>写在2019上班的第二天</title>
    <url>/2019/02/12/thinking-in-2019/</url>
    <content><![CDATA[<p>从2019年元旦开始，就在筹划写一篇总结，一直拖到今天。</p>
<p>写博客其实是一件很费时的事情，也只有在冷静的时候，才会静下心来思考这件事情，这可能也是迟迟未写的原因之一吧。</p>
<a id="more"></a>
<h1 id="2018回顾"><a href="#2018回顾" class="headerlink" title="2018回顾"></a>2018回顾</h1><p>2018这一年，经历了很多的事情，主题是工作，也关乎风月。</p>
<h2 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h2><p>工作上，3月1号出门面试，第一家面的x德，3月2号去面的x东。刚开始不太喜欢加班，就接了x德的offer，是一个全新的团队，也为后来埋了很多坑，具体的就不再吐槽了，主要说说自己的问题。这半年里，了解了一下区块链，没多久，国内外接连出台了很多对区块链比特币的整顿政策，一下子凉凉。在工作中开始使用SpringBoot、SpringCloud的一整套架构。半年后接受不了团队混乱的管理，打算出来。甚至怀疑所谓的技术理想。</p>
<p>4月初清明节上午加班，下午赶飞机飞到重庆。对重庆的好感来自于《从你的全世界路过》，就这样一个人在重庆呆了三天，这是一座很有特色的城市，但是景点过于商业化，未来有机会和另一个人一起过来。</p>
<p>5月初独自骑车子从沙河一直骑到十三陵，这是在北京的第一次骑行，而且是一个人，路上车轱辘散架、大卡车、回来的路上遇到下雨，晚上直到十一点多才回到家里，又累又困，可以说真的是一次记忆深刻的骑行了。</p>
<p>从x德出来后，困惑了一段时间，想起自己一直想去未去的西藏，果断买了票过去。去到一个完全陌生而又向往的地方，一开始充满了期待。布达拉宫、大昭寺、巴松错、羊湖、日喀则、珠峰，一切都是新的。在林芝的时间，去见了朋友。而在西藏的这段时间里，让我有了更多的独处时间去思考，想起这半年来的各种事情，突然就感到豁然开朗。就这样待到11月份，后来的几天有点审美疲劳了吧，就天天坐在布达拉宫广场晒太阳。有拍婚纱照的，有朝圣的。后来甚至有点期待返京的日子。这可能就是“旅行就是从自己厌倦的地方去到一个别人厌倦的地方吧”。如果说旅行的意义是什么，我想，就是让自己进入慢节奏的生活，去思考，把自己的生活捋顺吧。意外的是收获了一首好歌–《狗屁青春》，朴树唱的，在路上听的时候还别有一番滋味。</p>
<p>从西藏回来后，心态好了很多，一些事情想通后也没有必要再去在乎或者纠结。只把心思放在工作上，希望能有更多的产出，</p>
<h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><h3 id="看过的电影："><a href="#看过的电影：" class="headerlink" title="看过的电影："></a>看过的电影：</h3><p>华尔街之子</p>
<p>大空头</p>
<p>互联网之子</p>
<p>驴得水</p>
<p>狗十三</p>
<p>人生果实</p>
<h3 id="看过的书："><a href="#看过的书：" class="headerlink" title="看过的书："></a>看过的书：</h3><p>《回来》</p>
<p>《人类简史》</p>
<p>《商业的本质》</p>
<p>《引爆点》</p>
<p>《黑客与画家》</p>
<p>《独居的一年》</p>
<p>《小王子》</p>
<p>《我们都是孤独的行路人》</p>
<p>《只是为了好玩儿》</p>
<h1 id="2019展望"><a href="#2019展望" class="headerlink" title="2019展望"></a>2019展望</h1><ol>
<li>考驾照，一直拖到现在还未完成的计划今年必须完成</li>
<li>学习吉他，虽然五音不全，年少不再，还是要学习一门乐器</li>
<li>坚持健身(跑步)，这个年龄总该意识到这个问题</li>
<li>工作上有一些突破</li>
<li>买一辆更好的山地车去骑行</li>
<li>读30本书，那些一年读100本书的人真的很厉害了</li>
</ol>
<p>人生需要不断的前行、试错、复盘。前面走了太多的弯路，未来要跑起来鸭！以后会尽量把经历记录下来，也不免是人生的一些回忆。</p>
]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat--概览(一)</title>
    <url>/2019/01/03/tomcat-base/</url>
    <content><![CDATA[<p>Tomcat作为常见的Servlet容器，我接触的从最初的SSH/SSM架构，Tomcat需要单独维护，到SpringBoot的嵌入式容器。</p>
<a id="more"></a>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="https://impwang.oss-cn-beijing.aliyuncs.com/tomcat/tomcat-base.png" alt="架构示意图："></p>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>Server包含一个或多个Service</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service是多个Connector和一个Container的集合，因为有不同的协议，需要用相应的Connector接收请求，转发给Container</p>
<h3 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h3><p>Connector安装不同的协议分为：</p>
<ol>
<li>HTTP Connector</li>
<li>AJP Connector</li>
</ol>
<h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><h4 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h4><p>负责处理Service的请求，Connector作为中间媒介</p>
<h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p>表示一个虚拟主机，每个虚拟主机和一个网络域名对应</p>
<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>每个Context对应一个Web应用</p>
<p>Wrapper：代表一个Servlet，使用门面设计模式</p>
<p>Connector有两种：可以在server.xml中看到配置<br>1) 监听8080端口<br>2) 监听8009端口</p>
<h4 id="Wrapper"><a href="#Wrapper" class="headerlink" title="Wrapper"></a>Wrapper</h4><h3 id="其它组件"><a href="#其它组件" class="headerlink" title="其它组件"></a>其它组件</h3><h4 id="manager"><a href="#manager" class="headerlink" title="manager"></a>manager</h4><p>主要用来管理会话</p>
<h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h4><p>启动Context，管理context的ClassLoader。</p>
<h4 id="pipline"><a href="#pipline" class="headerlink" title="pipline"></a>pipline</h4><p>Enging/Host/Context都有一个管道，在每个管道中设置了不同的valve，由valve做一些处理</p>
<h4 id="valve"><a href="#valve" class="headerlink" title="valve"></a>valve</h4><p>用来做一些拦截处理，</p>
<h4 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h4><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>1、</p>
<p>3、并行类加载</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="独立容器"><a href="#独立容器" class="headerlink" title="独立容器"></a>独立容器</h3><p>1、日志乱码问题</p>
<h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><p>1、URL路径转义问题</p>
]]></content>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis缓存过期策略(四)</title>
    <url>/2018/12/16/redis-cache-policy/</url>
    <content><![CDATA[<a id="more"></a>
<p>策略方式：</p>
<ol>
<li>定期过期：每隔一段固定时间，去扫描一定数量的数据库中expires字典表的key，到过期时间自动清除；占用CPU资源</li>
<li>惰性过期：当访问key时，才判断是否过期，过期则清除；如果大量key没有被访问，则不会被清除</li>
</ol>
<p><strong>Redis中同时使用了惰性过期和定期过期策略</strong></p>
]]></content>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis内存策略(三)</title>
    <url>/2018/12/16/redis-mem-policy/</url>
    <content><![CDATA[<p>Redis用于缓存的内存不足时，如何处理新写入需要申请额外空间的数据。</p>
<a id="more"></a>
<p><strong>32bit系统最大不能超过3G，64bit系统设置为0表示不限制</strong></p>
<p>设置淘汰策略：<br>    config get maxmemory<br>    config get maxmemory-policy</p>
<h2 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h2><h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><h3 id="6种淘汰策略"><a href="#6种淘汰策略" class="headerlink" title="6种淘汰策略"></a>6种淘汰策略</h3><ol>
<li>volatile-lru:从已设置过期时间的内存数据集中挑选最近最少使用的数据 淘汰；</li>
<li>volatile-ttl: 从已设置过期时间的内存数据集中挑选即将过期的数据 淘汰；</li>
<li>volatile-random:从已设置过期时间的内存数据集中任意挑选数据 淘汰；</li>
<li>allkeys-lru:从内存数据集中挑选最近最少使用的数据 淘汰；</li>
<li>allkeys-random:从数据集中任意挑选数据 淘汰；</li>
<li>no-enviction(驱逐)：禁止驱逐数据。（默认淘汰策略。当redis内存数据达到maxmemory，在该策略下，直接返回OOM错误）；</li>
</ol>
<h2 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h2><p>redis在清理大量的key之后，原来申请的内存将继续持有而并不会立即释放，此时将会存在大量的内存碎片。<br>可以通过<code>info memory</code>查看内存信息：<br><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">redis3.x</span><br><span class="line"><span class="meta"># Memory</span></span><br><span class="line"><span class="symbol">used_memory:</span><span class="number">879848</span></span><br><span class="line"><span class="symbol">used_memory_human:</span><span class="number">859.23</span>K</span><br><span class="line"><span class="symbol">used_memory_rss:</span><span class="number">2646016</span> 			<span class="meta"># 实际使用内存</span></span><br><span class="line"><span class="symbol">used_memory_rss_human:</span><span class="number">2.52</span>M			<span class="meta"># 申请内存</span></span><br><span class="line"><span class="symbol">used_memory_peak:</span><span class="number">898272</span></span><br><span class="line"><span class="symbol">used_memory_peak_human:</span><span class="number">877.22</span>K</span><br><span class="line"><span class="symbol">total_system_memory:</span><span class="number">3956277248</span></span><br><span class="line"><span class="symbol">total_system_memory_human:</span><span class="number">3.68</span>G</span><br><span class="line"><span class="symbol">used_memory_lua:</span><span class="number">37888</span></span><br><span class="line"><span class="symbol">used_memory_lua_human:</span><span class="number">37.00</span>K</span><br><span class="line"><span class="symbol">maxmemory:</span><span class="number">0</span></span><br><span class="line"><span class="symbol">maxmemory_human:</span><span class="number">0</span>B</span><br><span class="line"><span class="symbol">maxmemory_policy:</span>noeviction</span><br><span class="line"><span class="symbol">mem_fragmentation_ratio:</span><span class="number">3.01</span>		<span class="meta"># 碎片率</span></span><br><span class="line"><span class="symbol">mem_allocator:</span>libc</span><br><span class="line"></span><br><span class="line">redis6.x</span><br><span class="line"><span class="symbol">used_memory:</span><span class="number">864920</span></span><br><span class="line"><span class="symbol">used_memory_human:</span><span class="number">844.65</span>K</span><br><span class="line"><span class="symbol">used_memory_rss:</span><span class="number">8384512</span></span><br><span class="line"><span class="symbol">used_memory_rss_human:</span><span class="number">8.00</span>M</span><br><span class="line"><span class="symbol">used_memory_peak:</span><span class="number">864920</span></span><br><span class="line"><span class="symbol">used_memory_peak_human:</span><span class="number">844.65</span>K</span><br><span class="line"><span class="symbol">used_memory_peak_perc:</span><span class="number">100.01</span>%</span><br><span class="line"><span class="symbol">used_memory_overhead:</span><span class="number">819922</span></span><br><span class="line"><span class="symbol">used_memory_startup:</span><span class="number">802936</span></span><br><span class="line"><span class="symbol">used_memory_dataset:</span><span class="number">44998</span></span><br><span class="line"><span class="symbol">used_memory_dataset_perc:</span><span class="number">72.60</span>%</span><br><span class="line"><span class="symbol">allocator_allocated:</span><span class="number">1007744</span></span><br><span class="line"><span class="symbol">allocator_active:</span><span class="number">1228800</span></span><br><span class="line"><span class="symbol">allocator_resident:</span><span class="number">3506176</span></span><br><span class="line"><span class="symbol">total_system_memory:</span><span class="number">3956277248</span></span><br><span class="line"><span class="symbol">total_system_memory_human:</span><span class="number">3.68</span>G</span><br><span class="line"><span class="symbol">used_memory_lua:</span><span class="number">37888</span></span><br><span class="line"><span class="symbol">used_memory_lua_human:</span><span class="number">37.00</span>K</span><br><span class="line"><span class="symbol">used_memory_scripts:</span><span class="number">0</span></span><br><span class="line"><span class="symbol">used_memory_scripts_human:</span><span class="number">0</span>B</span><br><span class="line"><span class="symbol">number_of_cached_scripts:</span><span class="number">0</span></span><br><span class="line"><span class="symbol">maxmemory:</span><span class="number">0</span></span><br><span class="line"><span class="symbol">maxmemory_human:</span><span class="number">0</span>B</span><br><span class="line"><span class="symbol">maxmemory_policy:</span>noeviction</span><br><span class="line"><span class="symbol">allocator_frag_ratio:</span><span class="number">1.22</span></span><br><span class="line"><span class="symbol">allocator_frag_bytes:</span><span class="number">221056</span></span><br><span class="line"><span class="symbol">allocator_rss_ratio:</span><span class="number">2.85</span></span><br><span class="line"><span class="symbol">allocator_rss_bytes:</span><span class="number">2277376</span></span><br><span class="line"><span class="symbol">rss_overhead_ratio:</span><span class="number">2.39</span></span><br><span class="line"><span class="symbol">rss_overhead_bytes:</span><span class="number">4878336</span></span><br><span class="line"><span class="symbol">mem_fragmentation_ratio:</span><span class="number">10.18</span></span><br><span class="line"><span class="symbol">mem_fragmentation_bytes:</span><span class="number">7560616</span></span><br><span class="line"><span class="symbol">mem_not_counted_for_evict:</span><span class="number">0</span></span><br><span class="line"><span class="symbol">mem_replication_backlog:</span><span class="number">0</span></span><br><span class="line"><span class="symbol">mem_clients_slaves:</span><span class="number">0</span></span><br><span class="line"><span class="symbol">mem_clients_normal:</span><span class="number">16986</span></span><br><span class="line"><span class="symbol">mem_aof_buffer:</span><span class="number">0</span></span><br><span class="line"><span class="symbol">mem_allocator:</span>jemalloc<span class="number">-5.1</span><span class="number">.0</span></span><br><span class="line"><span class="symbol">active_defrag_running:</span><span class="number">0</span></span><br><span class="line"><span class="symbol">lazyfree_pending_objects:</span><span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>redis在4.x版本后才支持碎片整理<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">config <span class="builtin-name">get</span> activefrag</span><br><span class="line">config <span class="builtin-name">set</span> activefrag <span class="literal">yes</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础</title>
    <url>/2018/12/15/mysql-base/</url>
    <content><![CDATA[<p>MySQL有三种版本，</p>
<a id="more"></a>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h2 id="Percona"><a href="#Percona" class="headerlink" title="Percona"></a>Percona</h2><p>XtraDB引擎</p>
<h2 id="MariaDB"><a href="#MariaDB" class="headerlink" title="MariaDB"></a>MariaDB</h2>]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>通信协议的演变</title>
    <url>/2018/11/21/net-http-overview/</url>
    <content><![CDATA[<p>HTTP协议一直在演进，最近出了HTTP3，基于UDP协议的QUIC协议</p>
<a id="more"></a>
<h2 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h2><h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><h3 id="http1-0和http1-1的比较"><a href="#http1-0和http1-1的比较" class="headerlink" title="http1.0和http1.1的比较"></a>http1.0和http1.1的比较</h3><ol>
<li>http1.0需要keep-alive参数告知服务器建立一个长连接，http1.1默认支持keep-alive</li>
<li>http1.0没有host域的，http1.1才支持这个参数</li>
<li>http1.1支持只发送header信息</li>
</ol>
<h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2><pre><code>http2.0基于SPDY协议
http2.0采用二进制格式，而非文本格式
http2.0是完全多路复用的，而非有序阻塞的(只需一个连接即可实现并行); http1.x线端阻塞问题，http1.1流水线技术
http2.0使用报头压缩，降低了开销
http2.0可以将响应主动推送到客户端缓存
</code></pre><p>SPDY协议：Google开发的下一代网络协议，并不是用来替代HTTP协议，而是对HTTP协议的增强。目前支持的有Netty和Nginx</p>
<ol>
<li>多路复用请求：在单个SPDY连接能并发的发起请求，并不限制请求数；</li>
<li>请求优先级：客户端能请求某个资源被优先传输。这避免了高优先级请求被非关键资源堵塞网络通道的问题；</li>
<li>头部压缩：客户端现在发送了大量冗余的HTTP头部信息。因为一个页面可能有50到100个子请求，这些数据是巨大的；</li>
<li>服务端推送流：服务端能向客户端推送数据不需要客户端发起一个请求</li>
</ol>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>需要客户端和服务器同时支持SPDY</p>
<p>协议解析复杂</p>
<h3 id="SPDY与http1-1的比较"><a href="#SPDY与http1-1的比较" class="headerlink" title="SPDY与http1.1的比较"></a>SPDY与http1.1的比较</h3><ol>
<li>一个SPDY连接允许建立多条stram，并发多个HTTP请求；http1.1一个连接只能处理一个请求</li>
<li>spdy请求可以具有优先级，客户端可以要求服务器优先发送重要资源；http1.1一个非关键请求可以阻塞服务器对后面请求的处理</li>
<li>spdy允许压缩头部，减少HTTP头部大小，减少带宽占用；http1.1头部冗余，User-Agent、Host重复发送</li>
<li>spdy服务器可以主动给客户端推送数据；http1.1只要客户端可以发送请求</li>
</ol>
<h2 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h2><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p>详细：</p>
<h2 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h2>]]></content>
      <categories>
        <category>NetWork</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议</title>
    <url>/2018/11/21/net-http/</url>
    <content><![CDATA[<p>HTTP协议一直在演进，最近出了HTTP3，基于UDP协议的QUIC协议</p>
<a id="more"></a>
<h2 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h2><h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><h3 id="http1-0和http1-1的比较"><a href="#http1-0和http1-1的比较" class="headerlink" title="http1.0和http1.1的比较"></a>http1.0和http1.1的比较</h3><ol>
<li>http1.0需要keep-alive参数告知服务器建立一个长连接，http1.1默认支持keep-alive</li>
<li>http1.0没有host域的，http1.1才支持这个参数</li>
<li>http1.1支持只发送header信息</li>
</ol>
<h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2><pre><code>http2.0基于SPDY协议
http2.0采用二进制格式，而非文本格式
http2.0是完全多路复用的，而非有序阻塞的(只需一个连接即可实现并行); http1.x线端阻塞问题，http1.1流水线技术
http2.0使用报头压缩，降低了开销
http2.0可以将响应主动推送到客户端缓存
</code></pre><p>SPDY协议：Google开发的下一代网络协议，并不是用来替代HTTP协议，而是对HTTP协议的增强。目前支持的有Netty和Nginx</p>
<ol>
<li>多路复用请求：在单个SPDY连接能并发的发起请求，并不限制请求数；</li>
<li>请求优先级：客户端能请求某个资源被优先传输。这避免了高优先级请求被非关键资源堵塞网络通道的问题；</li>
<li>头部压缩：客户端现在发送了大量冗余的HTTP头部信息。因为一个页面可能有50到100个子请求，这些数据是巨大的；</li>
<li>服务端推送流：服务端能向客户端推送数据不需要客户端发起一个请求</li>
</ol>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>需要客户端和服务器同时支持SPDY</p>
<p>协议解析复杂</p>
<h3 id="SPDY与http1-1的比较"><a href="#SPDY与http1-1的比较" class="headerlink" title="SPDY与http1.1的比较"></a>SPDY与http1.1的比较</h3><ol>
<li>一个SPDY连接允许建立多条stram，并发多个HTTP请求；http1.1一个连接只能处理一个请求</li>
<li>spdy请求可以具有优先级，客户端可以要求服务器优先发送重要资源；http1.1一个非关键请求可以阻塞服务器对后面请求的处理</li>
<li>spdy允许压缩头部，减少HTTP头部大小，减少带宽占用；http1.1头部冗余，User-Agent、Host重复发送</li>
<li>spdy服务器可以主动给客户端推送数据；http1.1只要客户端可以发送请求</li>
</ol>
<h2 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h2>]]></content>
      <categories>
        <category>NetWork</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Srping AOP(2)</title>
    <url>/2018/11/20/spring-aop/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>mysql踩坑经历</title>
    <url>/2018/10/12/mysql-bugs/</url>
    <content><![CDATA[<p>mysql使用中还是会有各种各样的坑，在实际使用中就遇到几个小问题，</p>
<a id="more"></a>
<ol>
<li><p>tinyint(1)的问题</p>
<p> tinyint(1)字段中数值大于1时，都返回true</p>
<p> 原因：</p>
<p> MySQL没有bool的概念，tinyint(1)隐式作为bool类型，0为false，非0为true。</p>
<p> 解决方案：</p>
<blockquote>
<p>在URL连接路径中添加 ‘Treat Tiny As Boolean=false’<br>在sql语句中 tinyint字段*1<br>使用tinyint(4)或者int类型</p>
</blockquote>
</li>
<li><p>时间大于2037年的问题</p>
<p> mysql时间不支持大于2037年的后时间，查询返回0.</p>
</li>
</ol>
<ol start="3">
<li><p>北京时间’1970-01-01 08:00:00’的问题</p>
<p> 当字段为’1970-01-01 08:00:00’的时候报错<br> com.mysql.jdbc.MysqlDataTruncation: Data truncation: Incorrect datetime value: ‘1970-01-01 08:00:00’ for column</p>
<p> 原因：</p>
<p> mysql时间的支持范围是’1970-01-01 08:00:01’，    而传入的字段时区是GMT+8，转为’1970-01-01 08:00:00’，不在支持范围内，所以抛异常</p>
</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Java虚拟机(一)</title>
    <url>/2018/09/28/java-jvm/</url>
    <content><![CDATA[<p>JVM运行时栈帧模型</p>
<a id="more"></a> 
<h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>可以看作当前线程所执行的字节码的行号执行器。通过改变这个计数器的值来选取下一条要执行的字节码指令。</p>
<p>每个线程有自己独立的程序计数器，各线程之间计数器互不影响，独立存储。</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>线程私有，生命周期和线程相同。<br>描述的Java方法执行的内存模型，每个方法在执行时都会创建一个栈帧：</p>
<blockquote>
<p>存储局部变量表、<br>操作数栈、<br>动态链接、<br>方法出口。</p>
</blockquote>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和Java虚拟机栈类似，用于存储本地方法的执行栈</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>被所有线程共享的一块区域，在虚拟机启动时创建。该内存区的唯一目的就是存放对象实例。</p>
<p>逃逸分析技术：</p>
<p>栈上分配</p>
<p>标量替换</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>所有线程共享的内存区。用于存储：</p>
<blockquote>
<p>被虚拟机加载的类信息：<br>常量<br>静态变量<br>即时编译器编译后的代码</p>
</blockquote>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>属于方法区的一部分。Class文件中的常量池在类加载后也会进入方法区的运行时常量池。还有常量池：编译期生成的各种字面量、符号引用、直接引用()。</p>
<p>例如String.intern()方法。</p>
<h4 id="PernGen和Metaspace"><a href="#PernGen和Metaspace" class="headerlink" title="PernGen和Metaspace"></a>PernGen和Metaspace</h4><p>PermGen：<br>永久代只是方法区在HotSpot虚拟机中的一种实现。其它类型的虚拟机没有永久代的概念。</p>
<p>jdk1.7:<br>原来存储在永久代的部分数据，现在分配到Java Heap/Native Heap。</p>
<p>jdk1.8:</p>
<blockquote>
<p>符号引用转移到native heap<br>字面量转移到Java heap<br>类的静态变量转移到Java heap<br>参数<code>-XX:PermSize -XX:MaxPermSize</code>已经失效<br>MetaSpac不在jvm中，而是使用本地内存，默认情况下，仅受本地内存限制，<br>参数<code>-XX:MetaspaceSize -XX:MaxMetaspaceSize</code>，用于限制元数据区空间，<strong>默认</strong>大小为20MB<br>参数<code>-XX:MinMetaspaceFreeRation -XX:MaxMetaspaceFreeRation</code>，用于控制GC后剩余空间容纳的百分比<br>参数<code>-XX:MinMetaspaceExpansion -XX:MaxMetaspaceExpansion</code>，用于控制元空间增长幅度<br>参数<code>-XX:+UseCompressedClassPointers -XX:+UseCompressedOops</code>会在Metaspace空间分配空间，导致默认20MB失效</p>
</blockquote>
<p>Metaspace的优点：</p>
<blockquote>
<p>jar包和应用的class文件存放在永久代，如果jar包很多，可能导致永久代溢出<br>每个应用都有自己的永久代，改用Metaspace后，应用可以共享同样的class内存空间，例如：两个项目都引用rt.jar，在元空间只保留一份</p>
</blockquote>
<p>Metaspace对GC性能的提升：</p>
<blockquote>
<p>Full GC中，指向元数据的指针不需要扫描，减少了GC开销；减少了GC Roots对象的扫描<br>元空间只有少量的指针指向Java heap，<br>避免了元数据压缩的开销</p>
</blockquote>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><h2 id="虚拟机对象"><a href="#虚拟机对象" class="headerlink" title="虚拟机对象"></a>虚拟机对象</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p><strong>注意:</strong> 仅限于普通Java对象，不包括数组、Class对象。</p>
<ol>
<li><p>当虚拟机遇到new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析、初始化过。如果没有，则执行相应的类加载过程。</p>
</li>
<li><p>为新生对象分配内存</p>
<blockquote>
<p>指针碰撞分配</p>
<p>空闲列表分配</p>
<p>内存分配的并发问题：</p>
<p>CAS + 失败重试</p>
<p>本地线程分配缓冲(TLAB)</p>
</blockquote>
</li>
<li><p>对象进行必要的设置</p>
</li>
<li>执行<init>方法</init></li>
</ol>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>对象在内存中存储包括3块区域:</p>
<blockquote>
<p>对象头：<br>     1、存储对象自身的运行时数据：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳<br>        2、类型指针：该对象指向它的类元数据的指针</p>
<p>实例数据：真正存储的有效信息，也就是在程序代码中定义的各种类型的字段内容。</p>
<p>对齐填充：非必须，起占位符的作用</p>
</blockquote>
<h3 id="对象的定位访问"><a href="#对象的定位访问" class="headerlink" title="对象的定位访问"></a>对象的定位访问</h3><p>1、句柄访问</p>
<p>优点：</p>
<p>在对象被移动时，只会改变句柄中的实例数据指针</p>
<p>2、直接指针访问</p>
<p>优点：</p>
<p>访问速度快，节省了一次指针定位的时间开销</p>
<h2 id="Win10编译OpenJDK8"><a href="#Win10编译OpenJDK8" class="headerlink" title="Win10编译OpenJDK8"></a>Win10编译OpenJDK8</h2><h2 id="Deepin编译OpenJDK8"><a href="#Deepin编译OpenJDK8" class="headerlink" title="Deepin编译OpenJDK8"></a>Deepin编译OpenJDK8</h2>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引</title>
    <url>/2018/09/28/mysql-index/</url>
    <content><![CDATA[<p>MySQL索引<br><a id="more"></a></p>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="按照划分："><a href="#按照划分：" class="headerlink" title="按照划分："></a>按照划分：</h3><h4 id="聚簇索引："><a href="#聚簇索引：" class="headerlink" title="聚簇索引："></a>聚簇索引：</h4><p>一个表只能有一个聚簇索引，InnoDB默认选择主键作为聚簇索引，如果没有主键，则选择一个唯一的非空索引替代。如果没有唯一非空列，则自定义一个主键作为聚簇索引。<br>叶子节点存储行的全部数据，节点只存储索引信息。<br>每一个叶子节点结构：主键值 + 事务ID + 回滚指针 + 剩余列的值。</p>
<p>缺点：</p>
<ol>
<li>更新索引列代价很高。由于聚簇索引需要是有序的，对更新的行，会强制移动到新的位置。如果插入新的记录，或者主键被更新导致移动行，可能造成’页分裂’问题，页分裂会占用更多的磁盘空间，因为数据不连续导致全表扫面变慢</li>
<li>二级索引回表查询问题。由于二级只存储索引和主键信息，根据二级索引过滤时，需要先查询二级索引，再查找主索引，二次I/O导致性能变差</li>
</ol>
<h4 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h4><h3 id="按照划分：-1"><a href="#按照划分：-1" class="headerlink" title="按照划分："></a>按照划分：</h3><ol>
<li><p>B-Tree索引。索引统称<br> B-Tree的特点：</p>
<blockquote>
<p>所有的值按照顺序存储<br>每一个叶子节点到根的距离相同<br>适合查找范围数据</p>
</blockquote>
<p> B-Tree的限制：</p>
<blockquote>
<p>如果不是按照索引的最左列开始查找，则无法使用索引</p>
<p>不能跳过索引中的列</p>
<p>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找</p>
</blockquote>
</li>
</ol>
<p>实际上，NDB使用的是T-Tree， MyISAM使用前缀压缩技术存储使得索引更小，索引通过物理地址查找记录；InnoDB引擎使用的是B+Tree，索引按照原数据格式存储，根据主键查找记录</p>
<p>B-Tree索引生效：</p>
<p>B-Tree索引失效：</p>
<ol start="2">
<li>哈希索引</li>
<li>空间数据索引(R-Tree)</li>
<li>全文索引</li>
</ol>
<h3 id="MyISAM和InnoDB的不同："><a href="#MyISAM和InnoDB的不同：" class="headerlink" title="MyISAM和InnoDB的不同："></a>MyISAM和InnoDB的不同：</h3><p>MyISAM使用前缀压缩使索引更小，而InnoDB按照原数据格式进行存储。</p>
<p>MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键饮用被索引的行。</p>
<h2 id="高性能索引策略"><a href="#高性能索引策略" class="headerlink" title="高性能索引策略"></a>高性能索引策略</h2><ol>
<li>索引列表达式：对索引列增加表达式，导致索引失效<br>前缀索引/索引唯一性：如果索引列太长，会导致索引变得很慢，可以采用索引部分前缀实现索引，但是要注意索引的唯一性，避免影响效率。前缀索引也导致<code>group by</code>和<code>order by</code>失效，也不能作为覆盖索引使用</li>
<li>多列索引：不同于复合索引/联合索引，假如一张表多个列需要创建索引，每个列创建单列索引并不会提高效率。存储引擎会对OR/AND语句做一些优化，索引也会经过索引，但是性能很低<br>索引顺序：多列索引中，在不考虑排序、分组的情况下，将唯一性区分度比较高的列放在最前面，</li>
<li>覆盖索引：不是所有的索引列都可以成为覆盖索引，MySQL只支持’B-Tree’类型索引为覆盖索引。EXPLAIN执行计划Extra列<code>Using index</code>表示覆盖索引生效，<code>Using where</code>表示覆盖索引失效，<code>Using where,Using index</code>表示进行了延迟关联。</li>
<li>索引排序：EXPLAIN执行计划Extra列</li>
<li>压缩索引：MyISAM引擎通过压缩索引前缀来减少内存占用，</li>
<li>重复索引/冗余索引：重复索引因为需要逐个过滤，所以会导致性能损耗。冗余索引不等于重复索引。冗余索引和重复索引都会导致INSERT、UPDATE、DELETE速度变慢。Percona提供了一些工具类来实现对冗余索引的分析。</li>
<li>闲置索引：有些索引可能 很少使用或者永远不使用，</li>
<li>索引和锁：InnoDB的行锁可以减少对锁的争用，在索引过滤数据完成后会立即释放锁，而不需要等到整个事务提交，如果索引失效，会导致全表扫描。InnoDB在二级索引上使用共享锁(S)，在主键索引上使用排他锁(X)，这就导致覆盖索引会失效，</li>
</ol>
<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL执行计划</title>
    <url>/2018/09/21/mysql-explain/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="库表结构设计优化"><a href="#库表结构设计优化" class="headerlink" title="库表结构设计优化"></a>库表结构设计优化</h2><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><h3 id="1、LIKE"><a href="#1、LIKE" class="headerlink" title="1、LIKE"></a>1、LIKE</h3><pre><code>SELECT column FROM table WHERE field LIKE &apos;%keyword%&apos;;
</code></pre><p>两边都有‘%’不走索引</p>
<pre><code>SELECT column FROM table WHERE field LIKE &apos;keyword%&apos;;
</code></pre><p>左边没有‘%’，才会走索引</p>
<p>可以通过explain执行计划查看，</p>
<p>优化替代方案：</p>
<ol>
<li>LOCATE(‘substr’, field, pos)</li>
<li>POSITION(‘substr’ IN field)</li>
<li>INSTR(field, ‘substr’)</li>
<li>FIND_IN_SET(‘substr’, field)</li>
</ol>
<h3 id="2、IN、NOT-IN"><a href="#2、IN、NOT-IN" class="headerlink" title="2、IN、NOT IN"></a>2、IN、NOT IN</h3><h3 id="3、int-datetime-timstamp时间存储"><a href="#3、int-datetime-timstamp时间存储" class="headerlink" title="3、int/datetime/timstamp时间存储"></a>3、int/datetime/timstamp时间存储</h3><p>对于MyISAM引擎，不建立索引的情况下（推荐），效率从高到低：</p>
<pre><code>int &gt; UNIX_TIMESTAMP(timestamp) &gt; datetime（直接和时间比较）&gt;timestamp（直接和时间比较）&gt;UNIX_TIMESTAMP(datetime) 。
</code></pre><p>对于MyISAM引擎，建立索引的情况下，效率从高到低： </p>
<pre><code>UNIX_TIMESTAMP(timestamp) &gt; int &gt; datetime（直接和时间比较）&gt;timestamp（直接和时间比较）&gt;UNIX_TIMESTAMP(datetime) 。
</code></pre><p>对于InnoDB引擎，没有索引的情况下(不建议)，效率从高到低：</p>
<pre><code>int &gt; UNIX_TIMESTAMP(timestamp) &gt; datetime（直接和时间比较） &gt; timestamp（直接和时间比较）&gt; UNIX_TIMESTAMP(datetime)。
</code></pre><p>对于InnoDB引擎，建立索引的情况下，效率从高到低：</p>
<pre><code>int &gt; datetime（直接和时间比较） &gt; timestamp（直接和时间比较）&gt; UNIX_TIMESTAMP(timestamp) &gt; UNIX_TIMESTAMP(datetime)。
</code></pre><h3 id="4、固定长度的表更快"><a href="#4、固定长度的表更快" class="headerlink" title="4、固定长度的表更快"></a>4、固定长度的表更快</h3><p>避免VARCHAR、TEXT、BLOB字段</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>执行计划,优化</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL分库分表技术</title>
    <url>/2018/09/17/mysql-sharding/</url>
    <content><![CDATA[<p>分库分表主要针对大流量用户网站，但是作为有追求的程序员，还是要熟悉理论，用的时候方便快速上手解决业务问题，毕竟生活主要还是Crud Boy</p>
<a id="more"></a> 
<p>分区：将存放数据的文件拆分成很多块儿，</p>
<p>分片：将数据分散存储在不同的服务器上</p>
<h2 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h2><h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>在同一个数据库中，将表数据存储在表名不同、结构相同的表中</p>
<h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol>
<li><p>跨库join问题</p>
<p> 拆库后数据可能分布在不同的实例、物理主机，基于安全，一般禁止跨库join、group by、order等操作。</p>
<p> 解决方案：</p>
<p> 1)、全局表：即字典表，所有可能关联表。将这些表在每个数据库保存一份，</p>
<p> 2)、字段冗余：不同的表保存一些关联表的字段，可能导致‘数据一致性’问题，因为要在不同的表维护相同的字段</p>
<p> 3)、 数据同步：</p>
<p> 4)、系统层组装：即通过代码组装处理数据，for循环可能导致循环RPC问题，循环查询数据库，连接费时。建议一次查询返回所有结果。</p>
</li>
<li><p>跨库事务问题(分布式事务)</p>
</li>
</ol>
<h2 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h2><h3 id="水平分表-横向分表"><a href="#水平分表-横向分表" class="headerlink" title="水平分表/横向分表"></a>水平分表/横向分表</h3><p>将表结构进行拆分，通过更细粒度的控制，将表分散在不同的服务器上，减少单表的压力</p>
<h3 id="水平分库分表"><a href="#水平分库分表" class="headerlink" title="水平分库分表"></a>水平分库分表</h3><ol>
<li>查询切分 将ID和库映射关系放在单独的主库中</li>
<li>范围切分 按照时间区间/ID区间切分</li>
<li>Hash切分 取模切分</li>
</ol>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>开源：</p>
<p>MyCAT: 基于Cobar</p>
<p>Sharding-JDBC(sharding-shpere): 当当基于JDBC</p>
<p>Cobar: 阿里巴巴，一年不维护</p>
<p>DBPRoxy: 美团，基于360的Atlas，两年不维护</p>
<p>Oceanus: 50同城团队</p>
<p>Atlas: 360团队，不推荐</p>
<p>TDDL: 依赖Dimond，已死</p>
<p>MaxScale: MariaDB作者官方，不支持分库分表</p>
<p>MySQL Route: MySQL官方</p>
<p>商业：</p>
<p>OneProxy：平民软件</p>
<p>DRDS: 阿里巴巴，基于Cobar、MySQL-Proxy</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>分库分表</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL基础环境搭建</title>
    <url>/2018/09/04/postgresql-base/</url>
    <content><![CDATA[<p>写这一篇博客的意义就是让自己保持经常写作的习惯，否则超过三天不写，就会一直拖延、逃避，不想当架构师的码农不是好程序员。</p>
<a id="more"></a>
<h2 id="CentOS7"><a href="#CentOS7" class="headerlink" title="CentOS7"></a>CentOS7</h2><h3 id="yum默认安装-可能导致安装版本过低"><a href="#yum默认安装-可能导致安装版本过低" class="headerlink" title="yum默认安装(可能导致安装版本过低)"></a>yum默认安装(可能导致安装版本过低)</h3><pre><code>yum install postgresql-server postgresql
</code></pre><p>(推荐官网安装)</p>
<p><a href="https://www.postgresql.org/download/linux/redhat/" target="_blank" rel="noopener">官网</a></p>
<p>官方安装报错：</p>
<p>yum install <a href="https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm" target="_blank" rel="noopener">https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm</a><br>已加载插件：fastestmirror<br>无法打开 <a href="https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm" target="_blank" rel="noopener">https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm</a> ，跳过。<br>错误：无须任何处理</p>
<p>更新yum仓库：</p>
<pre><code>rpm -Uvh https://download.postgresql.org/pub/repos/yum/10/redhat/rhel-7-x86_64/pgdg-centos10-10-2.noarch.rpm

yum install -y postgresql10-server postgresql10
</code></pre><p>也可以手动下载安装：<br><a href="https://yum.postgresql.org/rpmchart.php" target="_blank" rel="noopener">下载地址</a></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code>postgresql-setup initdb
</code></pre><h3 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h3><pre><code>systemctl enable postgresql.service
systemctl start postgresql.service
</code></pre><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><pre><code>CREATE USER postgres WITH PASSWORD &apos;&apos;;
DROP DATABASE postgres;
CREATE DATABASE postgres OWNER postgres;
GRANT ALL PRIVILEGES ON DATABASE postgres to postgres;
ALTER ROLE postgres CREATEDB;
</code></pre><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>切换用户</p>
<pre><code>su - postgres
</code></pre><p>登录</p>
<pre><code>psql -U [user] -d [database] -h [host] -p [password]
</code></pre><ol>
<li><p>默认登陆</p>
<pre><code>psql
</code></pre></li>
<li><p>用户名密码登录</p>
<p>  psql -U postgres -d postgres</p>
</li>
</ol>
<p>常用REPL命令</p>
<pre><code>退出 Ctrl + D;
\password：设置当前登录用户的密码
\h：查看SQL命令的解释，比如\h select。
\?：查看psql命令列表。
\l：列出所有数据库。
\c [database_name]：连接其他数据库。
\d：列出当前数据库的所有表格。
\d [table_name]：列出某一张表格的结构。
\du：列出所有用户。
\e：打开文本编辑器。
\conninfo：列出当前数据库和连接的信息。
\password [user]: 修改用户密码
\q：退出
</code></pre><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>创建数据库、创建表、数据操作都符合SQL语法</p>
<h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>默认安装目录在<code>/usr/local/Cellar</code></p>
<pre><code>brew install postgresql
</code></pre><p>查看安装版本</p>
<pre><code>psql --version 
pg_ctl -V

// 进入数据库
psql -d postgres
</code></pre><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>初始化会在<code>/usr/local/var</code>生成postgres目录</p>
<pre><code>initdb /usr/local/var/postgres -E utf8
</code></pre><h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><p>在目录<code>~/Library/LaunchAgents</code>设置代理</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code>// 后台启动postgresql
brew services start postgresql
// 前台启动
postgres -D /usr/local/var/postgres
// 停止postgresql
brew services stop postgresql
// 重启postgresql
brew services restart postgresql
</code></pre><h3 id="查看启动成功"><a href="#查看启动成功" class="headerlink" title="查看启动成功"></a>查看启动成功</h3><pre><code>ps -ef |grep postgres
</code></pre><h3 id="命令行操作数据库"><a href="#命令行操作数据库" class="headerlink" title="命令行操作数据库"></a>命令行操作数据库</h3><pre><code>psql
psql -h localhost

// 使用超级用户登录
psql -d postgres
</code></pre><h3 id="开机自启动-1"><a href="#开机自启动-1" class="headerlink" title="开机自启动"></a>开机自启动</h3><p>设置开机自启动</p>
<pre><code>// 建立软连接
ln -sfv /usr/local/opt/postgresql/*.plist ~/Library/LaunchAgents 
// 加载
launchctl load ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist
</code></pre><p>取消开机自启动</p>
<pre><code>// 卸载
launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist
// 移除
rm -rf ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist
</code></pre><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><pre><code>brew uninstall postgres
</code></pre><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><h3 id="mac下命令行连接错误"><a href="#mac下命令行连接错误" class="headerlink" title="mac下命令行连接错误"></a>mac下命令行连接错误</h3><pre><code>psql: could not connect to server: No such file or directory
Is the server running locally and accepting
connections on Unix domain socket &quot;/tmp/.s.PGSQL.5432&quot;?
</code></pre><h3 id="Navicat客户端连接错误"><a href="#Navicat客户端连接错误" class="headerlink" title="Navicat客户端连接错误"></a>Navicat客户端连接错误</h3><pre><code>FATAL:  role &quot;postgres&quot; does not exist
</code></pre><h3 id="命令行连接错误"><a href="#命令行连接错误" class="headerlink" title="命令行连接错误"></a>命令行连接错误</h3><ol>
<li><p>psql: FATAL:  Peer authentication failed for user “kong”</p>
</li>
<li><p>psql: FATAL:  Ident authentication failed for user “kong”<br>解决： 修改配置文件</p>
</li>
</ol>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">vi /var/<span class="class"><span class="keyword">lib</span>/<span class="title">pgsql</span>/<span class="title">data</span>/<span class="title">pg_hba</span>.<span class="title">conf</span> 	</span></span><br><span class="line">systemctl reload postgresql</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title>java编译器(五)</title>
    <url>/2018/09/02/jvm-compiler/</url>
    <content><![CDATA[<p>编译器是一门很深入的模块，完全理解需要很深厚的功底，就是所谓的”内功”，例如《编译原理》，回头接着好好撸</p>
<a id="more"></a>
<p>编译器在Java中根据不同大致分为3部分：</p>
<ol>
<li>前端编译器：Javac、增量编译器ECJ</li>
<li>JIT编译器：HotSpot中的C1(Client Compiler)、C2(Server Compiler)编译器</li>
<li>AOT编译器：GNU Compiler for the Java(GCJ)、Excelsior JET</li>
</ol>
<h2 id="静态提前编译-AOT"><a href="#静态提前编译-AOT" class="headerlink" title="静态提前编译 AOT"></a>静态提前编译 AOT</h2><p>直接把.java文件编译成机器码的过程。例如：GCJ, JET</p>
<p>编译过程：</p>
<ol>
<li><p>解析与填充符号表</p>
<blockquote>
<p>词法、语法分析</p>
<p>填充符号表</p>
</blockquote>
</li>
<li><p>注解处理</p>
</li>
<li><p>语义分析与字节码生成</p>
<blockquote>
<p>标注检查: 实现方法JavaCompiler.attribute()–sun.tools.javac.comp.Attr/Check类</p>
<p>数据及控制流分析: JavaCompiler.flow()<br>解语法糖: 泛型、变长参数、自动装箱/拆箱。实现类com.sun.tools.javac.comp.TransTypes/Lower类<br>字节码生成: 把以上生成的语法树、符号表转为字节码写到磁盘，同时添加少量代码。实现类com.sun.tools.javac.jvm.Gen/ClassWriter类</p>
</blockquote>
</li>
</ol>
<h2 id="后端运行时编译-JIT"><a href="#后端运行时编译-JIT" class="headerlink" title="后端运行时编译 JIT"></a>后端运行时编译 JIT</h2><p>把字节码编译成机器码的过程。例如：C1, C2</p>
<p>HotSpot内置了两个即时编译器： Client Compiler(C1编译器) + Server Compiler(C2编译器)，默认jvm会根据自身版本和系统硬件环境自动选择模式。<br>默认使用解释器 + 编译器混合模式。</p>
<p>-client: 强制Client模式</p>
<p>-server: 强制Server模式</p>
<p>-Xint: 强制使用解释模式</p>
<p>-Xcomp: 强制使用编译模式</p>
<p>分层编译：</p>
<ol>
<li>第0层</li>
<li>第1层</li>
<li>第2层</li>
</ol>
<p>JDK1.7 Server模式下默认开启分层编译。</p>
<p>热点代码：</p>
<p>栈上替换(OSR编译)</p>
<p>热点探测：判断一段代码是不是热点代码，是不是需要即时编译的行为。</p>
<blockquote>
<p>基于采样的热点探测：周期性的检查各个线程的栈顶</p>
<p>基于计数器的热点探测：建立计数器，统计方法的执行次数。</p>
</blockquote>
<p>HotSpot采用基于计数器探测，为每个方法准备了:方法调用计数器; 回边计数器</p>
<ol>
<li><p>方法调用计数器：统计方法被调用次数</p>
<p> -XX: CompileThreshold 设置方法被调用次数的阈值    </p>
<p> -XX: -UseCounterDecay  设置关闭热度衰减</p>
<p> -XX: CounterHalfLifeTime 设置版帅周期的时间</p>
</li>
<li><p>回边计数器：统计一个方法中循环体代码执行次数</p>
<p> -XX: BackEdgeThreshold 类似于CompileThreshold</p>
<p> -XX: OnStackReplacePercentage OSR比率，Client模式和Server下 默认值不同</p>
</li>
</ol>
<p>编译优化：</p>
<ol>
<li>公共子表达式消除</li>
<li>数组范围检查</li>
<li>方法内联</li>
<li>逃逸分析</li>
</ol>
<h3 id="Java编译器和C-C-编译器的对比："><a href="#Java编译器和C-C-编译器的对比：" class="headerlink" title="Java编译器和C/C++编译器的对比："></a>Java编译器和C/C++编译器的对比：</h3><p>优点：</p>
<blockquote>
<p>调用频率预测<br>分支频率预测<br>裁剪未被选择的分支</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java,jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis集群模式(五)</title>
    <url>/2018/09/01/redis-cluster/</url>
    <content><![CDATA[<p>redis高可用有不同的实现，集群、主从</p>
<a id="more"></a>
<h2 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h2><h2 id="Codis集群"><a href="#Codis集群" class="headerlink" title="Codis集群"></a>Codis集群</h2><h2 id="ruby集群"><a href="#ruby集群" class="headerlink" title="ruby集群"></a>ruby集群</h2>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis备份</title>
    <url>/2018/09/01/redis-backup/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>备份</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis主从模式(六)</title>
    <url>/2018/09/01/redis-master-slave/</url>
    <content><![CDATA[<h2 id="Redis主从复制原理"><a href="#Redis主从复制原理" class="headerlink" title="Redis主从复制原理"></a>Redis主从复制原理</h2><pre><code>Redis使用异步复制
复制在master和slave是非阻塞模式，即在执行同步时仍然可以提供查询
</code></pre><h3 id="Redis复制工作原理："><a href="#Redis复制工作原理：" class="headerlink" title="Redis复制工作原理："></a>Redis复制工作原理：</h3><ol>
<li>如果设置了一个Slave，无论是第一次连接还是重连到Master，它都会发出一个SYNC命令；</li>
<li>当Master收到SYNC命令之后，会做两件事：<br> a) Master执行BGSAVE，即在后台保存数据到磁盘（rdb快照文件）；<br> b) Master同时将新收到的写入和修改数据集的命令存入缓冲区（非查询类）；</li>
<li>当Master在后台把数据保存到快照文件完成之后，Master会把这个快照文件传送给Slave，而Slave则把内存清空后，加载该文件到内存中；</li>
<li>而Master也会把此前收集到缓冲区中的命令，通过Reids命令协议形式转发给Slave，Slave执行这些命令，实现和Master的同步；</li>
<li>Master/Slave此后会不断通过异步方式进行命令的同步，达到最终数据的同步一致；</li>
<li>需要注意的是Master和Slave之间一旦发生重连都会引发全量同步操作。但在2.8之后版本，也可能是部分同步操作。</li>
</ol>
<h3 id="完全同步、部分同步"><a href="#完全同步、部分同步" class="headerlink" title="完全同步、部分同步"></a>完全同步、部分同步</h3><p>psync部分重新同步：是指redis因某种原因引起复制中断后，从库重新同步时，只同步主实例的差异数据(写入指令），不进行bgsave复制整个RDB文件</p>
<p>fullsync导致的问题：复制闪断导致的抖动现象</p>
<p>列举几个fullsync常见的影响：<br>    master需运行bgsave,出现fork()，可能造成master达到毫秒或秒级的卡顿(latest_fork_usec状态监控)；<br>    redis进程fork导致Copy-On-Write内存使用消耗(后文简称COW)，最大能导致master进程内存使用量的消耗。(eg 日志中输出 RDB: 5213 MB of memory used by copy-on-write)<br>    redis slave load RDB过程，会导致复制线程的client output buffer增长很大；增大Master进程内存消耗；<br>    redis保存RDB(不考虑disless replication),导致服务器磁盘IO和CPU(压缩)资源消耗<br>    发送数GB的RDB文件,会导致服务器网络出口爆增,如果千兆网卡服务器，期间会影响业务正常请求响应时间(以及其他连锁影响)</p>
<p>psync1的部分同步机制，<br>    有效解决了网络环境不稳定、redis执行高时间复杂度的命令引起的复制中断，从而导致全量同步。但在应对slave重启和Master故障切换的场景时，psync1还是需进行全量同步。</p>
<p>psync2主要让redis在从实例重启和主实例故障切换场景下，也能使用部分重新同步    </p>
<p>部分同步的原理：</p>
<ol>
<li>主从服务器的复制偏移量offset</li>
<li>主服务器的复制积压缓存区：固定长度的FIFO队列，默认大小1MB</li>
<li>PID</li>
</ol>
<p>从服务器和主服务器进行第一次复制时，主服务器会将自己的运行ID传递给从服务器，从服务器将这个ID保存起来。重连后从服务器将服务器运行ID发送给主服务器，主服务器验证是否是自己的运行ID。</p>
<p>场景1：从服务器断线，重连主服务器</p>
<p>场景2：主服务器宕机，重新启动</p>
<p>命令传播阶段</p>
<pre><code>心跳检测
</code></pre><h3 id="主观下线、客观下线"><a href="#主观下线、客观下线" class="headerlink" title="主观下线、客观下线"></a>主观下线、客观下线</h3><h3 id="Sentinel选主"><a href="#Sentinel选主" class="headerlink" title="Sentinel选主"></a>Sentinel选主</h3><p>Raft算法实现</p>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><h2 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h2><h2 id="主从从模式"><a href="#主从从模式" class="headerlink" title="主从从模式"></a>主从从模式</h2>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Srping请求流程(4)</title>
    <url>/2018/08/31/spring-web/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>java动态代理</title>
    <url>/2018/08/30/java-proxy/</url>
    <content><![CDATA[<p>代理模式可以将具体的实现与调用方法解耦，将具体的实现隐藏在内部。</p>
<a id="more"></a>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>通过反射，可以在运行时访问Java对象的属性、方法、构造方法。<br><strong>注意：</strong>final属性也可以通过反射进行访问</p>
<h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>Spring中通过xml实现bean的实例化。</li>
<li>AOP切面编程。动态代理实现，最终也是通过反射实现</li>
<li>注解。</li>
<li>Class类浏览器、对象监视器、代码分析工具</li>
</ol>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>缺陷：</p>
<ol>
<li>性能开销。反射需要查找到Class进行动态解析，也会影响jvm的优化，性能较差</li>
<li>破坏封装性。反射调用时可以忽略权限检查，可能导致安全性问题</li>
<li>丧失编译时检查。无法在编译时检查，可能导致运行时异常</li>
</ol>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>在编译阶段将接口、实现类、代理类全部编译完成。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>在程序运行期间根据需要动态的创建代理类及其实例。</p>
<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理;<br>只能对实现了接口的类生成代理，而不能针对类</p>
<p>JDK代理要求：<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">实现InvocationHandler接口</span><br><span class="line">使用Proxy.<span class="keyword">new</span><span class="type">ProxyInstance</span>产生代理对象</span><br><span class="line">被代理的对象必须实现接口，如果该对象没有实现接口则不能生成代理对象</span><br></pre></td></tr></table></figure></p>
<p>案例：</p>
<h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><h4 id="为什么需要动态代理？"><a href="#为什么需要动态代理？" class="headerlink" title="为什么需要动态代理？"></a>为什么需要动态代理？</h4><ol>
<li>需要动态的增强具体业务的逻辑，比如AOP</li>
<li>业务增强逻辑相同，可以统一处理。例如log管理、权限认证</li>
<li>可以灵活地控制被代理类，很好的解耦</li>
</ol>
<h2 id="代理在Spring中的应用"><a href="#代理在Spring中的应用" class="headerlink" title="代理在Spring中的应用"></a>代理在Spring中的应用</h2><p>JDK代理和CGLIB代理在Spring中的应用：</p>
<blockquote>
<p>如果对象实现了接口，则默认采用JDK代理实现AOP</p>
<p>如果对象没有实现接口，则必须采用CGLIB代理实现AOP</p>
</blockquote>
<p>强制使用CGLIB实现AOP：</p>
<ol>
<li>添加CGLIB库，cglib/*.jar</li>
<li>在spring配置文件中加入&lt;aop:aspectj-autoproxy proxy-target-class=”true”/&gt;</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper概览(一)</title>
    <url>/2018/08/28/zk-base/</url>
    <content><![CDATA[<p>zk是一个分布式协调服务，是Google Chubby框架的开源实现</p>
<a id="more"></a>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="特性-语义"><a href="#特性-语义" class="headerlink" title="特性/语义"></a>特性/语义</h3><ol>
<li>顺序性：客户端发起的更新操作会按照发送顺序在zk上执行</li>
<li>原子性：zk操作要么成功，要么失败，不会有中间状态</li>
<li>可靠性：客户端请求的操作一旦被接受，不会意外丢失，除非被覆盖</li>
<li>最终一致性：写操作最终会对客户端可见(并非实时一致性)</li>
</ol>
<h3 id="核心组成"><a href="#核心组成" class="headerlink" title="核心组成"></a>核心组成</h3><ol>
<li>Leader：zk集群中只能同时有一个leader，<br> 它会发起并维护和各follower、observer之间的心跳<br> 所有的写操作必须由leader完成，leader写入本地日志后，再将写操作广播给follower、observer</li>
<li>Follower：一个zk集群可能有多个follower，它会响应leader的心跳<br> follower可以直接处理客户端的读请求，并将写请求转发给leader处理<br> 在leader处理写请求的时候对请求进行投票()</li>
<li>Observer： 角色与follower类似，但无投票权</li>
</ol>
<h3 id="watch机制"><a href="#watch机制" class="headerlink" title="watch机制"></a>watch机制</h3><p>客户端所有对zk的读操作，都会有一个Watch，数据改变时，该watch机制被触发<br>特点：</p>
<blockquote>
<p>主动推送：zk服务器<strong>主动</strong>将更新推送给客户端<br>一次性：数据变化时，只会被触发一次。如果客户端想要继续监听，必须重新注册一个新的watch<br>可见性：<br>顺序性：如果多个更新触发了watch机制，watch的顺序执行</p>
</blockquote>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>zk的节点类型是一个文件系统的树形结构。每个节点存储Stat数据结构(version，cversion，aversion)，除此之外，还会记录节点本身的一些状态信息</p>
<ol>
<li><p>永久节点、临时节点</p>
<blockquote>
<p>永久节点：一旦创建，不会丢失，服务端重启后仍然存在。既可以包含数据，也可以包含子节点<br>临时节点：客户端和服务端session会话结束，节点被删除。服务端重启后，节点消失</p>
</blockquote>
</li>
<li><p>顺序节点、非顺序性节点</p>
<blockquote>
<p>顺序节点：节点名在名称后带有10位10进制序号，多个客户端可以创建名称一样的节点，后面序号递增<br>非顺序节点：客户端只能创建名称不同的节点。</p>
</blockquote>
</li>
</ol>
<h4 id="节点ACL权限"><a href="#节点ACL权限" class="headerlink" title="节点ACL权限"></a>节点ACL权限</h4><ol>
<li>CREATE: 创建子节点的权限。</li>
<li>READ: 获取节点数据和子节点列表的权限。</li>
<li>WRITE：更新节点数据的权限。</li>
<li>DELETE: 删除子节点的权限。</li>
<li>ADMIN: 设置节点ACL的权限。</li>
</ol>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ol>
<li>注册中心</li>
<li>分布式锁</li>
<li>分布式队列</li>
<li>分布式协调/通知</li>
</ol>
<h2 id="单节点环境"><a href="#单节点环境" class="headerlink" title="单节点环境"></a>单节点环境</h2><p>单节点的安装可以增加用户，而不是使用root用户启动。</p>
<ol>
<li><p>下载安装包、解压缩</p>
<pre><code>zookeeper-3.4.10.tar.gz
</code></pre></li>
<li><p>修改配置文件zoo.cfg</p>
<p> zk提供了zoo_sample.cfg在conf目录下，可以增加data、log目录，也可以直接使用模板文件。</p>
<pre><code>cp zoo_sample.cfg zoo.cfg
</code></pre></li>
<li><p>启动服务端server</p>
<p> 服务端启动可以默认启动</p>
<pre><code>bin/zkServer.sh start
</code></pre></li>
<li><p>启动客户端client</p>
<p> 客户端可以默认启动，也可以指定服务器参数</p>
<pre><code>bin/zkCli.sh
bin/zkCli.sh -server 127.0.0.1:2181
</code></pre><p> 1). 创建节点</p>
<p> 语法 </p>
<pre><code>create [-s] [-e] path data acl
</code></pre><p> “-s”表示创建一个”有序”节点; “-e”表示创建一个临时节点.【默认为持久性节点】</p>
<pre><code>create /test null  
create -s /test null 
</code></pre><p> ACL授权方式为”digest”,其中授权的用户名:密码为”test:Kk3Nr5X06NH+XdlGMyOrULgK/mo=”,ACL的权限列表为”r””w””c””d””a”.</p>
<pre><code>create -s /test null digest:test:Kk3Nr5X06NH+XdlGMyOrULgK/mo=:rwcda
create /mykey1 myvalue1
create /mykey2 myvalue2    
</code></pre><p> 2). 删除节点</p>
<p> 删除所有节点</p>
<pre><code>rmr &lt;path&gt;    #删除&quot;/test&quot;以及其下的所有子节点.
</code></pre><p> 删除指定节点 </p>
<pre><code>delete &lt;path&gt; [version]
delete /test -1   #如果此path下还有子节点,将导致删除失败.这是和&quot;rmr&quot;指令的区别.
</code></pre><p> 3). 修改节点</p>
<pre><code>set path data [version]
set /test 1313131 -1  #如果版本号为&quot;-1&quot;表示更新时忽略版本校验.
</code></pre><p> 节点设置ACL权限</p>
<pre><code>setAcl path acl
setAcl /test digest:test:Kk3Nr5X06NH+XdlGMyOrULgK/mo=:rwcda 
</code></pre><p> 4). 查看节点数据</p>
<pre><code>get /mykey1
</code></pre><p> 5). 添加授权信息</p>
</li>
</ol>
<h2 id="集群环境"><a href="#集群环境" class="headerlink" title="集群环境"></a>集群环境</h2><h2 id="zk在大型分布式系统中的应用"><a href="#zk在大型分布式系统中的应用" class="headerlink" title="zk在大型分布式系统中的应用"></a>zk在大型分布式系统中的应用</h2><ol>
<li>zk在Hadoop中的应</li>
<li>zk在HBase中的应用</li>
</ol>
]]></content>
      <categories>
        <category>ZooKeeper</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis红锁RedLock在分布式中的应用</title>
    <url>/2018/08/28/redis-redlock/</url>
    <content><![CDATA[<p>RedLock在Java中的实现是Redisson。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合之ConcurrentHashMap</title>
    <url>/2018/08/14/java-concurrenthashmap/</url>
    <content><![CDATA[<p>不同于HashMap,ConcurrentHashMap是线程安全的。</p>
<p>put(K, V)</p>
<p>get(Object)</p>
<p>containsKey(Object)</p>
<p>size()</p>
<a id="more"></a>
<h2 id="put-K-V"><a href="#put-K-V" class="headerlink" title="put(K, V)"></a>put(K, V)</h2><pre><code> @SuppressWarnings(&quot;unchecked&quot;)
public V put(K key, V value) {
    Segment&lt;K,V&gt; s;
    if (value == null)
        throw new NullPointerException();
    // 第一次hash
    int hash = hash(key);

    // 第二次hash,得到segment的索引j
    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;

    // 用unsafe的方式获取segments[j]元素 (unsafe类提供原子操作)
    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck
         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment
        s = ensureSegment(j);

    // 在segment.put中进行第三次hash
    return s.put(key, hash, value, false);
}
</code></pre><p>Segment中加锁</p>
<pre><code>final V put(K key, int hash, V value, boolean onlyIfAbsent) {
        // 加锁，ReentrantLock的tryLock()
        HashEntry&lt;K,V&gt; node = tryLock() ? null :
            scanAndLockForPut(key, hash, value);
        V oldValue;
        try {
            HashEntry&lt;K,V&gt;[] tab = table;
            int index = (tab.length - 1) &amp; hash;
            HashEntry&lt;K,V&gt; first = entryAt(tab, index);

            // 遍历
            for (HashEntry&lt;K,V&gt; e = first;;) {
                if (e != null) {
                    K k;
                    if ((k = e.key) == key ||
                        (e.hash == hash &amp;&amp; key.equals(k))) {
                        oldValue = e.value;
                        if (!onlyIfAbsent) {
                            e.value = value;
                            ++modCount;
                        }
                        break;
                    }
                    e = e.next;
                }
                else {
                    if (node != null)
                        node.setNext(first);
                    else
                        node = new HashEntry&lt;K,V&gt;(hash, key, value, first);
                    int c = count + 1;
                    if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)
                        rehash(node);
                    else
                        setEntryAt(tab, index, node);
                    ++modCount;
                    count = c;
                    oldValue = null;
                    break;
                }
            }
        } finally {
            // 解锁
            unlock();
        }
        return oldValue;
    }
</code></pre><h2 id="get-Object"><a href="#get-Object" class="headerlink" title="get(Object)"></a>get(Object)</h2><pre><code>public V get(Object key) {
    Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead
    HashEntry&lt;K,V&gt;[] tab;
    int h = hash(key);
    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;

    // UNSAFE原子获取
    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;
        (tab = s.table) != null) {
        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile
                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);
             e != null; e = e.next) {
            K k;
            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))
                return e.value;
        }
    }
    return null;
}
</code></pre><h2 id="containsKey-Object"><a href="#containsKey-Object" class="headerlink" title="containsKey(Object)"></a>containsKey(Object)</h2><pre><code>@SuppressWarnings(&quot;unchecked&quot;)
public boolean containsKey(Object key) {
    Segment&lt;K,V&gt; s; // same as get() except no need for volatile value read
    HashEntry&lt;K,V&gt;[] tab;
    int h = hash(key);
    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;
    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;
        (tab = s.table) != null) {
        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile
                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);
             e != null; e = e.next) {
            K k;
            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))
                return true;
        }
    }
    return false;
}
</code></pre><p>可以看到其实containsKey(Object)和get(Object)实现是一致的</p>
<h2 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h2><pre><code>public int size() {
    // Try a few times to get accurate count. On failure due to
    // continuous async changes in table, resort to locking.
    final Segment&lt;K,V&gt;[] segments = this.segments;
    int size;
    boolean overflow; // true if size overflows 32 bits
    long sum;         // sum of modCounts
    long last = 0L;   // previous sum
    int retries = -1; // first iteration isn&apos;t retry
    try {
        for (;;) {
            if (retries++ == RETRIES_BEFORE_LOCK) {
                for (int j = 0; j &lt; segments.length; ++j)
                    ensureSegment(j).lock(); // force creation
            }
            sum = 0L;
            size = 0;
            overflow = false;
            for (int j = 0; j &lt; segments.length; ++j) {
                Segment&lt;K,V&gt; seg = segmentAt(segments, j);
                if (seg != null) {
                    sum += seg.modCount;
                    int c = seg.count;
                    if (c &lt; 0 || (size += c) &lt; 0)
                        overflow = true;
                }
            }
            if (sum == last)
                break;
            last = sum;
        }
    } finally {
        if (retries &gt; RETRIES_BEFORE_LOCK) {
            for (int j = 0; j &lt; segments.length; ++j)
                segmentAt(segments, j).unlock();
        }
    }
    return overflow ? Integer.MAX_VALUE : size;
}
</code></pre><p>可以看到当retries++ == RETRIES_BEFORE_LOCK = 2的时候，也就是说会重试3次，然后对每一个segment进行加锁。</p>
<p>sum用来统计seg.modCount的个数，last用来记录上一次统计时sum的值。</p>
<p>第一次统计：last=0, </p>
<blockquote>
<p>如果sum=last=0，跳出for循环；</p>
<p>如果sum不等于last，则last=sum；</p>
</blockquote>
<p>第二次统计：</p>
<blockquote>
<p>如果sum=last，跳出for循环；</p>
<p>如果sum不等于last，则last=sum；</p>
</blockquote>
<pre><code>@SuppressWarnings(&quot;unchecked&quot;)
private Segment&lt;K,V&gt; ensureSegment(int k) {
    final Segment&lt;K,V&gt;[] ss = this.segments;
    long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset
    Segment&lt;K,V&gt; seg;
    if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) {
        Segment&lt;K,V&gt; proto = ss[0]; // use segment 0 as prototype
        int cap = proto.table.length;
        float lf = proto.loadFactor;
        int threshold = (int)(cap * lf);
        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap];
        if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))
            == null) { // recheck
            Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);
            while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))
                   == null) {

                // CAS算法
                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))
                    break;
            }
        }
    }
    return seg;
}
</code></pre>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java, 集合</tag>
      </tags>
  </entry>
  <entry>
    <title>spring bean注入过程(3)</title>
    <url>/2018/08/13/spring-bean/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="bean生命周期"><a href="#bean生命周期" class="headerlink" title="bean生命周期"></a>bean生命周期</h2><p>简化流程：</p>
<ol>
<li><p>详细流程(根据日志打印)：</p>
</li>
<li>实例化BeanFactoryPostProcessor实现类; </li>
<li>BeanFactoryPostProcessor#postProcessBeanFactory();</li>
<li>实例化BeanPostProcessor实现类</li>
<li>实例化InstantiationAwareBeanPostProcessorAdapter实现类</li>
<li>InstantiationAwareBeanPostProcessorAdapter#postProcessBeforeInstatiation()</li>
<li>bean构造器</li>
<li>InstantiationAwareBeanPostProcessorAdapter#postProcessPropertyValues()</li>
<li>bean设置属性值; </li>
<li>如果实现了BeanNameAware接口,调用setBeanName设置Bean的ID或者Name; </li>
<li>如果实现BeanFactoryAware接口,调用setBeanFactory设置BeanFactory; </li>
<li>如果实现ApplicationContextAware,调用setApplicationContext设置ApplicationContext </li>
<li>调用BeanPostProcessor#postProcessBeforeInitialization(); </li>
<li>调用InitializingBean#afterPropertiesSet(); </li>
<li>调用bean属性中设置的init-method方法； </li>
<li>调用BeanPostProcessor#postProcessAfterInitialization();</li>
<li>InstantiationAwareBeanPostProcessorAdapter#postProcessAfterInstatiation()</li>
<li>DiposibelBean#destroy()</li>
<li>执行bean属性中设置的destroy-method方法</li>
</ol>
<h2 id="多bean加载顺序"><a href="#多bean加载顺序" class="headerlink" title="多bean加载顺序"></a>多bean加载顺序</h2><ol>
<li>xml配置的bean优先于注解bean</li>
<li>优先加载BeanPostProcessor实现的bean; </li>
<li>按bean文件(例如import标签)和bean的定义顺序装载,</li>
<li>如果顺序执行中，beanA通过属性ref引用别的beanB，加载完beanA后，加载beanB，然后再顺序执行</li>
<li>如果beanA属性中depen-on依赖beanB，则会优先装载beanB，然后装载beanA，然后顺序装载</li>
<li>BeanFactoryUtils类也会改变Bean的加载顺序</li>
</ol>
<h2 id="bean循环依赖问题"><a href="#bean循环依赖问题" class="headerlink" title="bean循环依赖问题"></a>bean循环依赖问题</h2>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>bean</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合之HashMap</title>
    <url>/2018/08/09/java-hashmap/</url>
    <content><![CDATA[<p>hasmap在jdk1.7和jdk1.8中做了很大的改进，</p>
<a id="more"></a>
<h2 id="put-K-V-方法"><a href="#put-K-V-方法" class="headerlink" title="put(K, V)方法"></a>put(K, V)方法</h2><pre><code>public V put(K key, V value) {
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
    if (key == null)
        return putForNullKey(value);
    // 先对map做一次查找，查看是否包含该元组，如果存在，则直接返回
    int hash = hash(key);
    // 返回 h &amp; (table.length-1)
    int i = indexFor(hash, table.length);
    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }
    // 每次对map修改一次，modCount加1
    modCount++;
    // i：bucketIndex
    addEntry(hash, key, value, i);
    return null;
}

// 添加
void addEntry(int hash, K key, V value, int bucketIndex) {
    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
        //自动扩容，并重新哈希
        resize(2 * table.length);
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = indexFor(hash, table.length);
    }

    createEntry(hash, key, value, bucketIndex);
}

// 在冲突链表头部插入新的entry
void createEntry(int hash, K key, V value, int bucketIndex) {
    Entry&lt;K,V&gt; e = table[bucketIndex];
    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
    size++;
}

static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    final K key;
    V value;
    Entry&lt;K,V&gt; next;
    int hash;

    ...
}
</code></pre><p>可以看到先通过hash(key)和table.length求得一个下标i，然后去遍历table[i]后面的Entry&lt;K,V&gt;链表,查找是否已经存储过该对象，如果存储过，则返回存储的e.value，并且重新赋值新的value；否则添加Entry</p>
<p>扩容机制可以看到，如果size &gt; threshold，则执行resize(2 * table.length)，</p>
<ol>
<li>在new HashMap()中默认threashold = DEFAULT_INITIAL_CAPACITY=16，否则为自定义值</li>
<li>在put(K,V)的时候先执行了inflateTable(threshold)，inflateTable中int capacity = roundUpToPowerOf2(toSize)，</li>
<li>所以inflateTable后现在threshold = capacity*0.75；</li>
</ol>
<p>同时可以看到在createEntry中size++，即当元素个数&gt;=0.75capacity时，扩容为2table.length = 2capacity</p>
<pre><code>private void inflateTable(int toSize) {
    // Find a power of 2 &gt;= toSize
    int capacity = roundUpToPowerOf2(toSize);

    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);
    table = new Entry[capacity];
    initHashSeedAsNeeded(capacity);
}

private static int roundUpToPowerOf2(int number) {
    // assert number &gt;= 0 : &quot;number must be non-negative&quot;;
    return number &gt;= MAXIMUM_CAPACITY
            ? MAXIMUM_CAPACITY
            : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;
}
</code></pre><h2 id="resize-int-方法"><a href="#resize-int-方法" class="headerlink" title="resize(int)方法"></a>resize(int)方法</h2><pre><code>void resize(int newCapacity) {
    Entry[] oldTable = table;
    int oldCapacity = oldTable.length;
        threshold = Integer.MAX_VALUE;
        if (oldCapacity == MAXIMUM_CAPACITY) {
        return;
    }

    Entry[] newTable = new Entry[newCapacity];

    // 扩容后进行重hash操作
    transfer(newTable, initHashSeedAsNeeded(newCapacity));
    table = newTable;
    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
}

void transfer(Entry[] newTable, boolean rehash) {
    int newCapacity = newTable.length;

    // 遍历元素重hash
    for (Entry&lt;K,V&gt; e : table) {
        while(null != e) {
            Entry&lt;K,V&gt; next = e.next;
            if (rehash) {
                e.hash = null == e.key ? 0 : hash(e.key);
            }
            int i = indexFor(e.hash, newCapacity);
            e.next = newTable[i];
            newTable[i] = e;
            e = next;
        }
    }
}
</code></pre><p>可以看到在resize后，要对所有的元素重hash进行存储</p>
<h2 id="get-Object"><a href="#get-Object" class="headerlink" title="get(Object)"></a>get(Object)</h2><pre><code>public V get(Object key) {
    if (key == null)
        return getForNullKey();
    Entry&lt;K,V&gt; entry = getEntry(key);

    return null == entry ? null : entry.getValue();
}

final Entry&lt;K,V&gt; getEntry(Object key) {
    if (size == 0) {
        return null;
    }

    //先通过hash()函数得到key对应buckets的下标，然后依次遍历冲突链表
    int hash = (key == null) ? 0 : hash(key);
    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];
         e != null;
         e = e.next) {
        Object k;
        if (e.hash == hash &amp;&amp;
            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
            return e;
    }
    return null;
}
</code></pre><p>可以看到其实查找元素就是先通过hash(key)定位到数组，然后再去遍历数组后的链表</p>
<h2 id="containsKey-Object"><a href="#containsKey-Object" class="headerlink" title="containsKey(Object)"></a>containsKey(Object)</h2><pre><code>public boolean containsKey(Object key) {
    return getEntry(key) != null;
}
</code></pre><p>可以看到其实containsKey(Object)走的也是一个get(Object)</p>
<h2 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h2><pre><code>public int size() {
    return size;
}
</code></pre><p>可以看到HashMap查找长度，其实就是返回了一个属性，Java集合中大多都是返回size属性，不同的是ConcurrentHashMap需要实时去查找。因为ConcurrentHashMap是线程安全的</p>
<h2 id="hash冲突"><a href="#hash冲突" class="headerlink" title="hash冲突"></a>hash冲突</h2><h2 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h2><p>加载因子越大,填满的元素越多,好处是,空间利用率高了,但冲突的机会加大了。链表长度会越来越长,查找效率降低。</p>
<p>反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但空间浪费多了。表中的数据将过于稀疏（很多空间还没用，就开始扩容了）</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol>
<li>key、value都允许为null值</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>村上春树和三毛</title>
    <url>/2018/08/08/thinking-in-today/</url>
    <content><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=410161216&auto=1&height=66"></iframe>

<p>不知道是因为下雨的原因，还是立秋的原因，今天走出门口，感觉凉凉的，有一点秋天的感觉。我想，也许有两者都有吧。然后赶往另一个地方，不经意间，就想起杨宗纬，想起村上春树，想起三毛。</p>
<a id="more"></a>
<p>想想自己来京一年多的时间里，自从去年在春雪未化的时候一个人去了碓臼峪，秋天去了中华民族园，去了香山。已经很久没有认真看过这个城市，正好搭公交去另一个地方。车上的人很少，大多是已上年纪的“老头”、“老太太”，依然选一个靠窗的位置坐下，开始百无聊赖的看窗外的故事。</p>
<p>窗外有三三两两骑着电动车带小孩子的母亲，我想附近应该是有个学校吧，男孩儿背着书包，安安静静的拉着母亲的衣角，倒是女孩儿显得有点调皮，东张西望的样子，又显得有点可爱。心里暗自在想，如果可以永远当一个长不大的孩子，永远没有烦恼该多好。一会儿，上来一位奶爸，抱着两三岁的女儿，一副很学究气的眼镜，给人一种学者的印象，运动休闲短裤，脚上是休闲的凉鞋，手上爆凸的青筋，正好坐在我的邻座，一路上爸爸和女儿有的没的说话，女儿一概不理，我想，假如有女本柔弱，为母则刚的话，这一定是男本刚强，为父则柔吧，心中顿生温暖。”静安庄到了，有到静安庄下车的乘客请注意”,车窗外是一位老爷爷，头发花白，应该在六十左右，双手背在身后，看着路上的一切，不知道在看些什么，也不知道在想些什么，三十而立，四十不惑，五十而知天命，六十而耳顺，七十而随心所欲不逾矩。如果我到了这个年纪，又会是什么样子呢？正当我陷入更多的思考后，车牌下一位头顶鸭舌帽，带着耳机，穿着短裤，我想她一定是个孤独而又对生活充满激情的人，有着年轻人该有的一切对生活不屈服的骄傲，一种来自内心的共鸣喷涌而出，如果说有什么让我坚持生活在这里，我想一定是:在这里，每个人都在努力而又认真的活着。扫视窗外，路旁的清洁工正在打扫落叶，”不知不觉，你已经离开我，后知后觉，又过了一个秋”。生活就是这样，琐碎而又充满乐趣。</p>
<p>此时此刻，村上春树、三毛更多的占据我的内心，使我迫不及待地想要把这一切记录下来。</p>
<p>村上春树</p>
<blockquote>
<p>天下的事在许多情况下并没有结论。那事情越是重要，这种倾向就越明显。越是脚踏实地大量收集第一手讯息，花费大量时间采访，事物的真相就越扑朔迷离。结论越发渐行渐远，视点越发四分五裂。注定如此。结果我们走投无路。孰对孰错，孰前孰后，我们渐渐不明就里了。 </p>
<p>我们每个人或多或少，都是一只蛋，是拥有独一无二的灵魂和包裹这灵魂的脆弱外壳的蛋。我是这样，你们也是。而且我们每个人或多或少，都面对着一堵坚固的高墙。这堵墙是有名字的，它叫作“体制”。这体制本应是保护我们的东西。可在某些时候，它会自行其是，会杀死我们，会让我们杀人。它冷酷，高效，而且有条不紊。 </p>
<p>年轻时音乐也好书也好，哪怕条件差一点，不也照样会不由分说地沁入心灵么？人的心中可以容纳无穷无尽的音乐。</p>
<p>结果，大多数东西都烟消云散了。在那个时代里曾经震撼我们心灵、洞穿我们肉体的东西，当十年逝去回首往昔时，我们才知道那大多不过是经过粉饰的约定。我们追求了，于是给了我们。然而我们追求的东西太多，结果给我们的东西大多坠入了类型化。 </p>
<p>在某些情况下，虚构会深深吞噬我们的真实存在。就像康拉德的小说将我们实际带入非洲原始森林深处一样。人们必须在某一时刻阖上书本，从那个场所回归现实。我们必须在与虚构不同的地点，恐怕是采取与虚构相互交换力量的形式，打造出抗击现实世界的自己。 </p>
<p>与之相比，我们则生活在效率极低的混沌的社会里。阅读每日的报纸便可一目了然。不难理解毫不留恋地想逃出这种鬼地方，迅速融入心旷神怡的同质共同体的心情。 </p>
<p>说得再深入些，我认为这里的外在混沌，不应当作他者和障碍加以排斥，而应视为我们内在混沌的反映接纳下来。其间的矛盾、庸俗、伪善和软弱，其实不正与我们内心暗藏的矛盾、庸俗、伪善和软弱相同吗？就像跳进大海时，包围身体的海水与我们内部的体液在成分上彼此呼应…… </p>
<p>不过有个肉眼可见的变化。就是乘坐电车时，会极其自然地环视周围的乘客，想道，“这里的这些人，各自都有深刻的人生啊”。想道，“是的。我们在某种意义上是孤独的，但在某种意义上又不孤独”。着手这件工作之前，我根本没有这样的念头。电车仅仅是电车，乘客无非是“陌路人”罢了。</p>
</blockquote>
<p>对于未来，正如村上春树所说那样：<strong>“世上所有的人终其一生，都在寻求某个宝贵的东西，但能找到的人不多。即使幸运地找到了，那东西也大多受到致命的损伤。但是，我们必须继续寻求。因为不这么做，活着的意义就不复存在。”</strong></p>
<p>三毛</p>
<blockquote>
<p>结婚，小半是为荷西情痴，大半仍是为了父母，至于我自己，本可以一辈子光棍下去，人的环境和追求并不只有那么一条狭路，怎么活，都是一场人生，不该在这件事上谈成败，论英雄。</p>
<p>“每夜你上床时，一定要觉得——今天可真活了个够——那么你的一生都不会有遗憾”</p>
<p>生命，在这样荒僻落后而贫苦的地方，一样欣欣向荣地滋长着，它，并不是挣扎着在生存，对于沙漠的居民而言，他们在此地的生老病死都好似是如此自然的事。我看着那些上升的烟火，觉得他们安详得近乎优雅起来。</p>
<p>物质的文明对人类并不能说是必要，但是在我们同样生活着的地球上居然还有连镜子都没有看过的人，的确令我惊愕交加，继而对他们无由地产生了一丝怜悯。这样的无知只是地理环境的限制，还是人为的因素，我久久找不到答案。</p>
<p>这条荒野里唯一的柏油路，照样被我日复一日地来回驶着，它乍看上去，好似死寂一片，没有生命，没有哀乐。其实它跟这世界上任何地方的一条街，一条窄弄，一弯溪流一样，载着它的过客和故事，来来往往地度着缓慢流动的年年月月。</p>
<p>夏日的撒哈拉就似它漫天飞扬、永不止息的尘埃，好似再也没有过去的一天，岁月在令人欲死的炎热下粘了起来，缓慢而无奈的日子，除了使人懒散和疲倦之外，竟对什么都迷迷糊糊的不起劲，心里空空洞洞地熬着汗渍渍的日子。</p>
<p>“看破的，遁入空门，痴迷的，枉送了性命，好一似，食尽鸟投林，落了片白茫茫大地真干净！”</p>
<p>我蹲在远远的沙地上，不停地发着抖，发着抖，四周暗得快看不清他们了。风，突然没有了声音，我渐渐地什么也看不见，只听见屠宰房里骆驼嘶叫的悲鸣越来越响，越来越高，整个的天空，渐渐充满了骆驼们哭泣着的巨大的回声，像雷鸣似的向我罩下来。</p>
</blockquote>
<p>对于今天，则应该像三毛所说的那样：<strong>“每夜你上床时，一定要觉得——今天可真活了个够——那么你的一生都不会有遗憾”</strong></p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life, reading</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL主从复制</title>
    <url>/2018/08/08/mysql-master-slave/</url>
    <content><![CDATA[<p>MySQL的集群(主从模式)主要解决单点故障问题，但是主从之间无法保证严格的’数据一致性’</p>
<a id="more"></a>
<h2 id="主从工作原理"><a href="#主从工作原理" class="headerlink" title="主从工作原理"></a>主从工作原理</h2><p>主从模式又分为单主单从、单注多从、级联(从节点下还有从节点)</p>
<ol>
<li>主库把数据更新记录到二进制日志</li>
<li><p>从库将主库的日志复制到自己的中继日志</p>
<blockquote>
<p>备库启动I/O线程，和主库建立一个客户端连接</p>
<p>主库启动特殊的转储线程，读取主库上二进制日志中的事件</p>
<p>备库I/O线程将接收到的事件记录到中继日志</p>
</blockquote>
</li>
<li><p>备库读取中继日志的事件，数据写入从数据库</p>
</li>
</ol>
<p>从库sql线程从中继日志读取事件、执行事件。</p>
<p>主从复制，又有不同的模式：基于语句的复制、基于行的复制</p>
<h3 id="基于语句的复制"><a href="#基于语句的复制" class="headerlink" title="基于语句的复制"></a>基于语句的复制</h3><p>主库会记录所有数据更新的sql，当备库读取重放这些事件时，实际上是把所有执行过的sql语句执行一遍。</p>
<p>优点：</p>
<p>缺点：</p>
<h3 id="基于行的复制"><a href="#基于行的复制" class="headerlink" title="基于行的复制"></a>基于行的复制</h3><p>将实际的数据记录在二进制日志中。</p>
<p>优点：</p>
<p>缺点：</p>
<h3 id="复制模式"><a href="#复制模式" class="headerlink" title="复制模式"></a>复制模式</h3><h4 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h4><h4 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h4><ol>
<li>rpl_semi_sync_master_wait_point=WAIT_AFTER_COMMIT，主库先完成commit提交后，再同步至从库，等待从库的ACK.</li>
</ol>
<p>问题：如果在同步之前，主库发生崩溃 ，会出现事务数据丢失，导致数据不一致。</p>
<ol start="2">
<li>rpl_semi_sync_master_wait_point=WAIT_AFTER_SYNC，<br>问题：</li>
</ol>
<p><strong>注意：</strong>主库在等待从库ACK超时，会降级为异步复制</p>
<h4 id="同步复制"><a href="#同步复制" class="headerlink" title="同步复制"></a>同步复制</h4><h3 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h3><p>由于服务器负载、网络拥堵等问题，Master和Slave之间数据一致性没有保证。</p>
<p>解决方案：</p>
<ol>
<li>在master insert/update操作后强制sleep几秒</li>
<li>把更新的数据保存在内存/或者保存在缓存中(例如redis)，当写操作完成后，读数据直接从缓存中读取。</li>
<li>使用MySQL Proxy代理实现。原理：在master、slave各维护一张count_table表，当master执行insert/delete/update操作时，触发器触发count_table表字段自增。当client请求proxy服务器时，proxy先查询master+slave的count_table表，如果一致，则查询slave，否则查询master</li>
</ol>
<p>补充：安装MySQL Proxy</p>
<h4 id="1032、1062错误"><a href="#1032、1062错误" class="headerlink" title="1032、1062错误"></a>1032、1062错误</h4><p>1032：从库上不存在记录<br>1062：从库上存在和主库要插入的重复的数据<br>从库可以通过修改参数解决这些错误：</p>
<ol>
<li>sql_slave_skip_counter=N<br>跳过1个事务，一个事务包括N个event，一个sql语句可能对于多个event</li>
<li>slave-skip-errors=1062<br>跳过错误</li>
<li>slave_exec_mode=’IDEMPOTENT’<br><code>slave_exec_mode</code>分为两种模式：<blockquote>
<p>STRICT：会出现以上的错误<br>IDEMPOTENT：依赖于’基于行复制’的bin log模式，在’基于语句复制’模式下不起作用，一般用于多主复制、NDB Cluster情况下</p>
</blockquote>
</li>
</ol>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="主库"><a href="#主库" class="headerlink" title="主库"></a>主库</h3><p>执行步骤：</p>
<ol>
<li>修改配置文件<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vi</span> /etc/my.<span class="keyword">cnf</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>配置参数<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">log_bin</span>=mysql-bin  </span><br><span class="line"><span class="attr">server-id</span>=<span class="number">1</span> </span><br><span class="line"><span class="attr">replay_log</span>=/var/lib/mysql/mysql-replay-bin</span><br><span class="line"><span class="attr">log_slave_updates</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">read_only</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">innodb_flush_log_at_trx_commit</span>=<span class="number">1</span> </span><br><span class="line"><span class="attr">sync_binlog</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>启动MySQL<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong> log_bin一定要开启，也可以是’log-bin’,如果不开启可能会报错：</p>
<p>ERROR 2006 (HY000): MySQL server has gone away<br>No connection. Trying to reconnect…<br>Connection id:    3<br>Current database: <strong><em> NONE </em></strong></p>
<p>Empty set (0.00 sec)</p>
<h4 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h4><p>2、创建一个供局域网内连接的用户(有的提到要加锁)</p>
<pre><code>grant replication slave on *.* to &apos;admin&apos;@&apos;192.168.117.%&apos; identified by &apos;xxxxxx&apos;;

flush privileges;
</code></pre><p><strong>注意：</strong> on后面是’<em>.</em>‘,否则可能会报错：</p>
<p>ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘to ‘admin-m‘@’192.168.117.%’ identified by ‘admin234’’ at line 1</p>
<ol start="3">
<li><p>查看主库</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">	mysql -uroot -p</span><br><span class="line">	show master status \G;</span><br><span class="line">```	</span><br><span class="line">### 从库 ###</span><br><span class="line">操作步骤：</span><br><span class="line"><span class="number">1.</span> 修改配置(有的提到修改/var/lib/mysql/auto.cnf文件)</span><br></pre></td></tr></table></figure>
<p> vi /etc/my.cnf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">配置参数：</span><br></pre></td></tr></table></figure>
<p> server_id=22<br> relay_log=relay-log-bin<br> skip_slave_start<br> read_only<br> relay_log_index=slave-relay-bin.index</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2.</span> 连接到主库</span><br></pre></td></tr></table></figure>
<p> change master to master_host=’192.168.117.135’,master_port=3306,master_user=’admin’,master_password=’xxxxx’,master_log_file=’mysql-bin.000003’,master_log_pos=154;</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">参数解释：</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 启动从库，查看是否启动成功</span><br></pre></td></tr></table></figure>
<p> start slave;<br> show slave status \G;</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">如果Slave_IO_Running: <span class="literal">YES</span> Slave_SQL_Running: <span class="literal">Yes</span>,则表明启动成功。</span><br><span class="line"></span><br><span class="line">参数Last_IO_Errno: 1236 Last_IO_Error显示失败的原因。</span><br><span class="line"></span><br><span class="line">错误1:中间重启从库mysql,启动后直接start slave;</span><br><span class="line"></span><br><span class="line">报错：<span class="builtin-name">ERROR</span> 1872 (HY000): Slave failed <span class="keyword">to</span> initialize relay log <span class="builtin-name">info</span> structure <span class="keyword">from</span> the repository</span><br><span class="line"></span><br><span class="line">解决：</span><br></pre></td></tr></table></figure>
<p> reset slave;<br> change master …..;<br> start slave;</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">启动成功；</span><br><span class="line"></span><br><span class="line">## MySQL读写分离 ##</span><br><span class="line">从库配置参数：</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>–skip-innodb<br>–skip-bdb<br>–low-priority-updates<br>–delay-key-write=ALL<br><code>`</code></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>主从</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring的IOC原理分析(1)</title>
    <url>/2018/08/08/spring-ioc/</url>
    <content><![CDATA[<p>BeanFactory</p>
<p>ListableBeanFactory</p>
<p>HierarchicalBeanFactory</p>
<p>AutowireCapableBeanFactory</p>
<p>ApplicationContext</p>
<h2 id="传统编程和IoC的对比"><a href="#传统编程和IoC的对比" class="headerlink" title="传统编程和IoC的对比"></a>传统编程和IoC的对比</h2><p>传统编程：决定使用哪个具体的实现类的控制权在调用类本身，在编译阶段就确定了。</p>
<p>IoC模式：调用类只依赖接口，而不依赖具体的实现类，减少了耦合。控制权交给了容器，在运行的时候才由容器决定将具体的实现动态的“注入”到调用类的对象中。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java, Spring, ioc</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机命令详解(三)</title>
    <url>/2018/08/07/java-jvm-cmd/</url>
    <content><![CDATA[<p>其实去年就一直在做这些东西，只是没有整理出来，这一段时间面试还是遇到很多问jvm的东西，特别整理以下</p>
<a id="more"></a>
<h2 id="jvm的默认参数"><a href="#jvm的默认参数" class="headerlink" title="jvm的默认参数"></a>jvm的默认参数</h2><p>安装完jdk后，先来看一看一些默认参数，以下统一以jdk1.8为例。</p>
<pre><code>java -XX:+PrintFlagsFinal -version | grep :
</code></pre><p>“=”:表示jvm参数的默认值，</p>
<p>“:=”:表示被用户或者jvm赋值的参数</p>
<pre><code> intx CICompilerCount                          := 2                                   {product}
uintx InitialHeapSize                          := 48234496                            {product}
uintx MaxHeapSize                              := 742391808                           {product}
uintx MaxNewSize                               := 247463936                           {product}
uintx MinHeapDeltaBytes                        := 524288                              {product}
uintx NewSize                                  := 15728640                            {product}
uintx OldSize                                  := 32505856                            {product}
 bool PrintFlagsFinal                          := true                                {product}
 bool UseCompressedClassPointers               := true                                {lp64_product}
 bool UseCompressedOops                        := true                                {lp64_product}
 bool UseParallelGC                            := true                                {product}
</code></pre><p>查看参数配置：</p>
<pre><code>java -XX:+PrintCommandLineFlags -version

-XX:InitialHeapSize=46359872 
-XX:MaxHeapSize=741757952 
-XX:+PrintCommandLineFlags 
-XX:+UseCompressedClassPointers 
-XX:+UseCompressedOops 
-XX:+UseParallelGC 
java version &quot;1.8.0_161&quot;
Java(TM) SE Runtime Environment (build 1.8.0_161-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)
</code></pre><h3 id="参数分析"><a href="#参数分析" class="headerlink" title="参数分析"></a>参数分析</h3><p>-XX:+UseParallelGC参数可知，使用的收集器为Parallel Scavenge + Serial Old(PS MarkSweep)组合。</p>
<h2 id="jstat-统计信息监控"><a href="#jstat-统计信息监控" class="headerlink" title="jstat: 统计信息监控"></a>jstat: 统计信息监控</h2><p>jstat option vmid [interval] [count]</p>
<h4 id="参数解释："><a href="#参数解释：" class="headerlink" title="参数解释："></a>参数解释：</h4><p>Options — 选项，我们一般使用 -gcutil 查看gc 情况</p>
<p>vmid — VM 的进程号，即当前运行的java 进程号</p>
<p>interval– 间隔时间，单位为秒或者毫秒</p>
<p>count — 打印次数，如果缺省则打印无数次</p>
<h4 id="具体参数如下："><a href="#具体参数如下：" class="headerlink" title="具体参数如下："></a>具体参数如下：</h4><p>-class：统计class loader行为信息</p>
<p>-compile：统计编译行为信息</p>
<p>-gc：统计jdk gc时heap信息</p>
<p>-gccapacity：统计不同的generations（不知道怎么翻译好，包括新生区，老年区，permanent区）相应的heap容量情况</p>
<p>-gccause：统计gc的情况，（同-gcutil）和引起gc的事件</p>
<p>-gcnew：统计gc时，新生代的情况</p>
<p>-gcnewcapacity：统计gc时，新生代heap容量</p>
<p>-gcold：统计gc时，老年区的情况</p>
<p>-gcoldcapacity：统计gc时，老年区heap容量</p>
<p>-gcpermcapacity：统计gc时，permanent区heap容量</p>
<p>-gcutil：统计gc时，heap情况</p>
<p>-printcompilation：不知道干什么的，一直没用过。</p>
<h4 id="案例分析："><a href="#案例分析：" class="headerlink" title="案例分析："></a>案例分析：</h4><p>S0 — Heap 上的 Survivor space 0 区已使用空间的百分比</p>
<p>S1 — Heap 上的 Survivor space 1 区已使用空间的百分比</p>
<p>E — Heap 上的 Eden space 区已使用空间的百分比</p>
<p>O — Heap 上的 Old space 区已使用空间的百分比</p>
<p>P — Perm space 区已使用空间的百分比</p>
<p>YGC — 从应用程序启动到采样时发生 Young GC 的次数</p>
<p>YGCT– 从应用程序启动到采样时 Young GC 所用的时间( 单位秒 )</p>
<p>FGC — 从应用程序启动到采样时发生 Full GC 的次数</p>
<p>FGCT– 从应用程序启动到采样时 Full GC 所用的时间( 单位秒 )</p>
<p>GCT — 从应用程序启动到采样时用于垃圾回收的总时间( 单位秒)</p>
<p>jstat -gc 1909</p>
<pre><code>S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU      CCSC   CCSU     YGC     YGCT    FGC    FGCT     GCT   

3456.0 3456.0 3456.0  0.0   28224.0  23968.9   70124.0    66785.0   43264.0 42270.5 4864.0  4588.8    128    1.487    8    0.779    2.266
</code></pre><p>jstat -gccapacity 1909</p>
<pre><code>NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC 

5440.0  83968.0  35136.0 3456.0 3456.0  28224.0    10944.0   167936.0    70124.0    70124.0      0.0 1087488.0  43264.0   0.0    1048576.0   4864.0  128     8
</code></pre><p>jstat -gcutil 1909</p>
<p>jstat -gcutil 1909 1000 100      #每1000ms打印一次，总共打印100次</p>
<pre><code>S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   

0.00   0.00   3.41  60.00  97.54  94.07    129    1.534     9    1.148    2.682
</code></pre><p>jstat -gcnew 1909</p>
<pre><code>S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT  

3584.0 3584.0    0.0    0.0  1  15 1728.0  29248.0   2123.2    129    1.534
</code></pre><p>jstat -gcnewcapacity 1909</p>
<pre><code>NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC 

5440.0    83968.0    36416.0   8384.0   3584.0   8384.0   3584.0    67200.0    29248.0   129     9
</code></pre><p>jstat -gcold pid</p>
<p>jstat -gcoldcapacity pid</p>
<p>jstat -gcpermcapacity pid</p>
<p>jstat -class 1909</p>
<pre><code>Loaded  Bytes  Unloaded  Bytes     Time   

6688 13143.8       24    31.1      52.45
</code></pre><p>jstat -compiler 1909</p>
<pre><code>Compiled Failed Invalid   Time   FailedType FailedMethod

7578      3       0    38.61          1 com/mysql/jdbc/AbandonedConnectionCleanupThread run
</code></pre><h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p>jmap option vmid</p>
<h4 id="具体参数如下：-1"><a href="#具体参数如下：-1" class="headerlink" title="具体参数如下："></a>具体参数如下：</h4><p>-dump</p>
<p>-heap</p>
<p>-histo</p>
<p>-finalizeerinfo</p>
<p>-permstat</p>
<p>-F</p>
<h4 id="案例分析：-1"><a href="#案例分析：-1" class="headerlink" title="案例分析："></a>案例分析：</h4><p>使用hprof二进制形式,输出jvm的heap内容到文件，.live子选项是可选的，假如指定live选项,那么只输出活的对象到文件. 【执行过程会暂停应用】</p>
<p>记录堆内存快照文件，然后利用第三方工具mat分析整个Heap的对象关联情况 【如果添加参数:live，JVM会先触发gc，然后再统计信息。】</p>
<pre><code>jmap -dump:format=b,file=[filename][pid]

jmap -dump:live,format=b,file=20170509.hprof 1909
</code></pre><p>打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况.</p>
<pre><code>jmap -heap 1909
</code></pre><p>打印每个class的实例数目,内存占用,类全名信息。VM的内部类名字开头会加上前缀”*”. 如果live子参数加上后,只统计活的对象数量. 【如果添加参数:live，JVM会先触发gc，然后再统计信息。】</p>
<pre><code>jmap -histo:live 1909 | head -n 100 &gt; jmaphisto.log
</code></pre><p>打印正等候回收的对象的信息</p>
<pre><code>jmap -finalizerinfo 1283
</code></pre><p>打印classload和jvm heap永久层的信息. 【执行过程会暂停应用】</p>
<p>包含每个classloader的名字,活泼性,地址,父classloader和加载的class数量. 另外,内部String的数量和占用内存数也会打印出来.</p>
<pre><code>jmap -permstat 1909
</code></pre><p>结合MAT分析。</p>
<h4 id="补充：保留现场，使用更快的gcore分析"><a href="#补充：保留现场，使用更快的gcore分析" class="headerlink" title="补充：保留现场，使用更快的gcore分析"></a>补充：保留现场，使用更快的gcore分析</h4><ol>
<li>Linux内核里面生成的core file文件相关的代码</li>
<li>core dump file 相关的设置</li>
<li>如何在程序中调用代码生成 core dump file，程序又不用退出。</li>
<li>使用gdb分析 core dump file 文件</li>
<li>用gdb 生成core文件</li>
</ol>
<h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><h4 id="具体参数如下：-2"><a href="#具体参数如下：-2" class="headerlink" title="具体参数如下："></a>具体参数如下：</h4><h4 id="案例分析：-2"><a href="#案例分析：-2" class="headerlink" title="案例分析："></a>案例分析：</h4><p>生成虚拟机当前时刻线程快照:<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">jstack -l <span class="number">1909</span></span><br><span class="line">jstack <span class="number">1909</span> &gt; jstack.log</span><br></pre></td></tr></table></figure></p>
<h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><h2 id="jcmd-新版jdk的命令，用于取代旧版本命令"><a href="#jcmd-新版jdk的命令，用于取代旧版本命令" class="headerlink" title="jcmd: 新版jdk的命令，用于取代旧版本命令"></a>jcmd: 新版jdk的命令，用于取代旧版本命令</h2><h4 id="具体参数如下：-3"><a href="#具体参数如下：-3" class="headerlink" title="具体参数如下："></a>具体参数如下：</h4><h4 id="案例分析：-3"><a href="#案例分析：-3" class="headerlink" title="案例分析："></a>案例分析：</h4><p>查看jvm的pid,类似于jps命令</p>
<pre><code>jcmd -l
1283 org.apache.catalina.startup.Bootstrap start
2293 sun.tools.jcmd.JCmd -l
27449 org.apache.activemq.apollo.boot.Apollo /usr/local/tbroker/lib\;/usr/local/apollo-1.7.1/lib org.apache.activemq.apollo.cli.Apollo run

jps
1283 Bootstrap
27449 Apollo
2315 Jps
</code></pre><p>查看 JVM 的启动时长：</p>
<pre><code>jcmd PID VM.uptime
</code></pre><p>查看 JVM 的类信息：这个可以查看每个类的实例数量和占用空间大小。</p>
<pre><code>jcmd PID GC.class_histogram
</code></pre><p>查看 JVM 的线程快照：</p>
<pre><code>jcmd PID Thread.print
</code></pre><p>查看 JVM 的Heap Dump：</p>
<pre><code>jcmd PID GC.heap_dump FILE_NAME
</code></pre><p><strong>注意</strong>，如果只指定文件名，默认会生成在启动 JVM 的目录里。</p>
<p>查看 JVM 的属性信息：</p>
<pre><code>jcmd 1283 VM.system_properties
1283:
java.lang.OutOfMemoryError: Java heap space
</code></pre><p>查看 JVM 的启动参数：注意，可以看到 -X 和 -XX 的参数信息，比较有用。</p>
<pre><code>jcmd 1283 VM.flags
1283:
-XX:CICompilerCount=2 -XX:InitialHeapSize=16777216 -XX:MaxHeapSize=262144000 -XX:MaxNewSize=87359488 -XX:MinHeapDeltaBytes=196608 -XX:NewSize=5570560 -XX:OldSize=11206656 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops 
</code></pre><p>查看 JVM 的启动命令行：</p>
<pre><code>jcmd 1283 VM.command_line
</code></pre><p>对JVM执行 java.lang.System.runFinalization()：</p>
<pre><code>jcmd 1283 GC.run_finalization
</code></pre><p>对JVM执行 java.lang.System.gc()：</p>
<pre><code>jcmd 1283 GC.run
</code></pre><p><strong>注意：</strong>告诉垃圾收集器打算进行垃圾收集，而垃圾收集器进不进行收集是不确定的。</p>
<p>查看 JVM 的性能：</p>
<p>jcmd PID PerfCounter.print</p>
<p><strong>补充</strong> </p>
<p>常用命令</p>
<pre><code>top
top -p 1909 -H
free 
free -m
</code></pre><p>高内存占用分析</p>
<pre><code>ps -mp 1909 -o THREAD,tid,time,rss,size,%mem
</code></pre><p>查看进程内存</p>
<pre><code>pmap -x 5454
pmap -q 5454
pmap -d -q 5454
</code></pre>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java, jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql中的锁lock(三)</title>
    <url>/2018/08/07/mysql-lock/</url>
    <content><![CDATA[<p>MySQL中的锁机制</p>
<a id="more"></a>
<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><h3 id="1-表级锁-MyISAM-："><a href="#1-表级锁-MyISAM-：" class="headerlink" title="1. 表级锁(MyISAM)："></a>1. 表级锁(MyISAM)：</h3><blockquote>
<p>开销小，加锁快</p>
<p>不会出现死锁</p>
<p>锁定力度大，发生锁冲突概率最高，并发度低</p>
</blockquote>
<h4 id="表共享读锁、表独占写锁"><a href="#表共享读锁、表独占写锁" class="headerlink" title="表共享读锁、表独占写锁"></a>表共享读锁、表独占写锁</h4><p>MyISAM在执行select语句时，会自动给相关表加读锁；<br>执行insert/update/delete    语句时，自动加写锁；<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LOCK</span> <span class="keyword">tables</span> table1 <span class="keyword">read</span> <span class="keyword">local</span>, table2 <span class="keyword">read</span> <span class="keyword">local</span>;</span><br><span class="line"><span class="keyword">select</span> ***</span><br><span class="line"><span class="keyword">select</span> ***</span><br><span class="line"><span class="keyword">Unlock</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure></p>
<p>local：</p>
<p>锁升级：</p>
<h3 id="2-行级锁-InnoDB-："><a href="#2-行级锁-InnoDB-：" class="headerlink" title="2. 行级锁(InnoDB)："></a>2. 行级锁(InnoDB)：</h3><p>特性：</p>
<blockquote>
<p>开销大，加锁慢</p>
<p>会导致死锁</p>
<p>锁定粒度最小，发生锁冲突最低，并发度也最高</p>
</blockquote>
<h4 id="事务ACID"><a href="#事务ACID" class="headerlink" title="事务ACID"></a>事务ACID</h4><p>原子性<br>一致性<br>隔离性<br>持久性</p>
<h4 id="事务带来的问题"><a href="#事务带来的问题" class="headerlink" title="事务带来的问题"></a>事务带来的问题</h4><p>更新丢失<br>脏读：<br>不可重复度：<br>幻读：</p>
<h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><ol>
<li>加锁</li>
<li>MVCC多版本控制</li>
</ol>
<table>
<thead>
<tr>
<th>隔离级别/读数据一致性及允许的并发副作用</th>
<th style="text-align:center">读数据一致性</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>未提交读(Read uncommitted)</td>
<td style="text-align:center">最低级别，只能保证不读取物理上损坏的数据</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td>已提交度(Read committed)</td>
<td style="text-align:center">语句级</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td>可重复读(Repeatable read)</td>
<td style="text-align:center">事务级</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td>可序列化(Serializable)</td>
<td style="text-align:center">最高级别，事务级</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
<p>查看系统行级锁占用<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'innodb_row_lock%'</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="意向共享锁-IS-、意向排他锁-IX"><a href="#意向共享锁-IS-、意向排他锁-IX" class="headerlink" title="意向共享锁(IS)、意向排他锁(IX)"></a>意向共享锁(IS)、意向排他锁(IX)</h4><p>这两种锁都是<strong>表锁</strong>，这两种意向锁和共享锁、排他锁有兼容、互斥的关系，在获取共享锁和排他锁之前必须先获取意向锁，而这两种锁都是数据库自动添加的，不需要开发人员显式添加。</p>
<p><strong>注意：</strong>只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁！</p>
<h4 id="共享锁-S-、排他锁-X"><a href="#共享锁-S-、排他锁-X" class="headerlink" title="共享锁(S)、排他锁(X)"></a>共享锁(S)、排他锁(X)</h4><p>这两种锁都是行锁。<br>显式加锁：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">共享锁（S）：<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span></span><br><span class="line">排他锁（X）：<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure></p>
<h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p>使用范围查询时，该条件作用在索引上，InnoDB会对符合条件的范围加锁，索引键值在范围内但是该记录并不存在的称为“间隙”，这些间隙也会被加锁。间隙锁 + 行锁 = Next-Key锁。</p>
<h3 id="3-页面锁："><a href="#3-页面锁：" class="headerlink" title="3. 页面锁："></a>3. 页面锁：</h3><pre><code>&gt; 开锁、加锁时间介于表锁和行锁之间，
&gt; 
&gt; 会导致死锁
&gt; 
&gt; 粒度介于两者之间，并发度一般
</code></pre><h2 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h2>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2018/08/07/java-threadpool/</url>
    <content><![CDATA[<p>目前的经验，实际中一般应用在发送邮件、发送短信的场景</p>
<a id="more"></a>
<h2 id="Executors中的静态工厂方法"><a href="#Executors中的静态工厂方法" class="headerlink" title="Executors中的静态工厂方法"></a>Executors中的静态工厂方法</h2><ol>
<li><p>newFixedThreadPool:创建一个固定长度的线程池，(无界的阻塞队列LinkedBlockingQueue)</p>
</li>
<li><p>newSingleThreadExecutor:创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程代替(无界的阻塞队列LinkedBlockingQueue)</p>
<p> <strong>注意：</strong> 因为以上两个都是使用的无界队列，允许请求队列长度为Integer.MAX_VALUE，所以可能堆积大量的请求，导致OOM</p>
</li>
<li><p>newCachedThreadPool:创建一个可缓存的线程池，(队列SynchronizedQueue)</p>
</li>
<li><p>newScheduledThreadPool:创建一个固定长度的线程池，而且以延迟或者定时的方式来执行任务,类似于Timer</p>
</li>
</ol>
<p><strong>注意：</strong>以上两个允许创建线程数为Integer.MAX_VALUE,可能创建大量线程，导致OOM</p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="创建与销毁"><a href="#创建与销毁" class="headerlink" title="创建与销毁"></a>创建与销毁</h3><pre><code>public ThreadPoolExecutor(int corePoolSize,
                      int maximumPoolSize,
                      long keepAliveTime,
                      TimeUnit unit,
                      BlockingQueue&lt;Runnable&gt; workQueue,
                      ThreadFactory threadFactory,
                      RejectedExecutionHandler handler) {

}
</code></pre><p>corePoolSize:没有任务执行时线程池的大小，当工作队列满了的时候，才会创建超出该数量的线程</p>
<p>maximumPoolSize:表示可同时活动的线程数量的上限</p>
<p>keepAliveTime:空闲线程存活时间，如果某个线程的空闲时间超过了keepAliveTIme，则被标记为可回收，并且当线程池当前大小超出corePoolSize时，这个线程将被终止。</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>基本的任务队列有3种：</p>
<ol>
<li><p>无界队列：</p>
<blockquote>
<p>ArrayBlockingQueue：先进先出队列，任务的执行顺序和到达顺序一致</p>
</blockquote>
</li>
<li><p>有界队列：</p>
<blockquote>
<p>LinkedBlockingQueue：用链表实现的队列，可以是有界的，也可以是无界的</p>
<p>PriorityBlockingQueue：根据任务优先级安排任务，可以进一步控制任务的执行顺序</p>
</blockquote>
<p> 有界队列可以避免资源耗尽，同时带来问题，当队列已满的时候，新任务需要配合饱和策略执行。</p>
</li>
<li><p>同步移交</p>
<blockquote>
<p>SynchronouseQueue：对于非常大或者无界的线程池，可以通过使用该队列避免任务排队。原理：如果有线程等待，直接移交给线程；如果没有线程，且当前线程数量corePoolSize，则创建一个新线程移交；否则根据饱和策略处理。所以使用SynchronouseQueue时，maximumPoolSize是不起作用的。</p>
</blockquote>
</li>
</ol>
<h3 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h3><p>当线程池已满，同时队列也满了以后，根据饱和策略处理请求线程</p>
<p>JDK提供了4种饱和策略：</p>
<blockquote>
<p>AbortPolicy:默认的饱和策略，当队列满时，将抛出未检查的RejectedExecutionException</p>
<p>CallerRunsPolicy:该策略不会抛弃任务，也不会抛出异常，而是将任务交给提交任务的线程执行，从而降低新任务的流量</p>
<p>DiscardPolicy:当新提交的任务无法保存到队列时，该策略将抛弃该任务</p>
<p>DiscardOldestPolicy:该策略将抛弃下一个被执行的任务(即最早排队而尚未执行的任务)，然后重新提交新任务</p>
</blockquote>
<h3 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h3><p>默认的线程工厂方法将创建一个新的、非守护的线程，并且不包含特殊的配置信息</p>
<pre><code>public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), defaultHandler);
}
</code></pre><p>可以看到默认情况下，使用DefaultThreadFactory线程工厂，AbortPolicy策略</p>
<h2 id="Thread-Pool使用不当导致的死锁"><a href="#Thread-Pool使用不当导致的死锁" class="headerlink" title="Thread Pool使用不当导致的死锁"></a>Thread Pool使用不当导致的死锁</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>三十而立(Thirtysomething)</title>
    <url>/2018/07/24/thinking-about-thirty/</url>
    <content><![CDATA[<p>虽说不是三十，却也是即将奔三。</p>
<p>2018年2月份的时候离开上家公司，当初胸怀大志，希望出来能在一个更好的平台上施展一番。如今已经过去四之三，却感觉收获寥寥无几。其实这半年经历了很多的事情，也想了很多很多的东西：关于爱情，关于工作，关于生活。正好最近空闲下来，好好整理下自己，也整理一下生活。</p>
<a id="more"></a>
<h3 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h3><p>一塌糊涂的爱情，和她见过最后一面，吃过最后一顿饭，走过最后一段，我想，也许我还没有放下，但生活总要继续。过年去姑姑家拜年的时候，也是各种被劝说，一直以来自己也想了很多，但是缘分这种事情，也是急不来的。从《不能承受的生命之轻》到《霍乱时期的爱情》，爱情观被不断的冲击，最近开始让自己静下来，遇到真正合适的再义无反顾的去争取吧。</p>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>三月份来到新的公司，项目组是新组建的，管理上一塌糊涂，哎。对写代码的热情被慢慢的消耗，很多时候我都在想，什么才是有意义的工作，怎样才能发挥自己最大的价值，究竟该选择什么方向努力。希望能尽快步入正轨吧。</p>
<h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>四月份飞了重庆，当初说好带她去重庆的，结果是自己一个人去，中间在三生有信还看到一个女生一边抹着眼泪，一边给某人写着寄语。</p>
<p>五月份第一次远程骑行到十三陵，摔了膝盖疼了好几天，骑行中间还突然下了一场雨，感觉好狼狈，由于没有远程骑行经验，中间轮子还掉了两次。。。最后终于在十一点多回家，累到倒床就睡。</p>
<p>上周末搬了家，终于从一个“北京村”，搬到了另一个“北京村”，好在新的“村”是个小区，虽然环境不是那么理想，但终于脱离了那种杂乱的环境，为了再接再厉吧！</p>
<p>今年可以说是熬夜最多的一年，更多的还是因为生活中一些不如意的事情吧。有些时候我是一个很情绪化的人，遇到一些苦恼的事情，就会像很多很多，最后一觉醒来，也就没那么多烦恼。前一段时间，终于狠心办了张健身卡，终于第一次去健身房，想想也是自 工作以来，很少去健身房锻炼了，以后还是要规律饮食，勤去健身房才好。</p>
<h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><p>《人类简史》 终于完结了一下，真的是从2017年读到2018年，拖延症太可怕</p>
<p>《黑客与画家》 思想论的东西，和写代码有关，不得不佩服格雷厄姆思想的深刻，毕竟是硅谷创业之父啊</p>
<p>《引爆点》 有点心理学的意味，大多是在地铁上读完的，其实生活中很多的行为都是被潜移默化的影响</p>
<p>《商业的本质》 管理学，大师的作品，正好自己也有兴趣，正好就在地铁上完成吧</p>
<p>《小王子》 重读了一遍，还是有很多不同的感受</p>
<p>《无比无杂的心绪》 很符合今年上半年的心绪，又是偶然发现，村上村树的作品，写的很深刻，直入内心的触动，需要多读几遍</p>
<p>《独居的一年》 感觉有昆德拉的影子在里面，正在读</p>
<p>距离2019年还有五个月的时间，希望自己能在不断的思考中，更成熟、更深刻、更充实。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life, thirty</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoo--容器启动过程(二)</title>
    <url>/2018/07/12/springboot-tomcat/</url>
    <content><![CDATA[<p>SpringBoot内嵌web容器tomcat，</p>
<a id="more"></a>
<h2 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h2>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>java, springboot, 源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/03/02/hello-world/</url>
    <content><![CDATA[<p>从高中上网都不会的小白，到从事这个行业，我知道我是真心地喜欢这个行业，只不过一直在探索最终的方向，如果可以，我真的希望自己可以写到退休，然后达到研究者的水平，像linus torvalds一样。<br>这个行业有太多太多的偏见，毕竟“文人相轻”的道理还是存在的，你只需要做好自己，追求极致。<br>最后，在这条路上见过了太多太多的大佬。<br>2020，我的目标：成为这样的大佬，未来做出自己的开源产品:)(2020.08.01)<br>博客间歇式更新 PS: 今年对很多东西有了重新的认识，整个博客的内容，大部分会推翻，重新构建(2020.08.27)<br>凡事问一下：</p>
<ol>
<li>她是什么？what</li>
<li>她用来做什么？for</li>
<li>她解决了什么问题？solve</li>
<li>她的设计原理是什么？design</li>
<li>你自己如何实现她？practice</li>
</ol>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=444267928&auto=1&height=66"></iframe>

<h2 id="计划："><a href="#计划：" class="headerlink" title="计划："></a>计划：</h2><p><del>2019主线目标：造轮子(有进步，改了两个开源产品的简单功能，继续努力)</del><br>2020主线目标：做出一款自己的产品</p>
<a id="more"></a>
<h2 id="npm包管理"><a href="#npm包管理" class="headerlink" title="npm包管理"></a>npm包管理</h2><p>现在很多的语言框架都会采用包管理，像Maven、Gradle、Cargo、Go，npm的包管理原理差不多，无非要考虑全局/本地问题、镜像问题、包路径问题。</p>
<h3 id="配置镜像"><a href="#配置镜像" class="headerlink" title="配置镜像"></a>配置镜像</h3><p>配置淘宝镜像(个人感觉不是很好用)<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">npm <span class="built_in">config</span> set registry https:<span class="comment">//registry.npm.taobao.org/</span></span><br><span class="line">npm <span class="built_in">config</span> <span class="built_in">get</span> registry</span><br></pre></td></tr></table></figure></p>
<p>配置代理，npm只支持http，如果使用socks代理，需要安装插件<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> proxy <span class="keyword">http</span>://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">1087</span></span><br><span class="line">npm config <span class="built_in">set</span> <span class="keyword">https</span>-proxy <span class="keyword">http</span>://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">1087</span></span><br><span class="line"><span class="comment"># 设置用户密码的代理</span></span><br><span class="line">npm config <span class="built_in">set</span> proxy <span class="string">"http://username:password@localhost:8080"</span></span><br><span class="line">npm confit <span class="built_in">set</span> <span class="keyword">https</span>-proxy <span class="string">"http://username:password@localhost:8080"</span></span><br></pre></td></tr></table></figure></p>
<p>也可以使用cnpm来代替npm<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sudo npm <span class="keyword">install</span> -g cnpm <span class="comment">--registry=https://registry.npm.taobao.org</span></span><br><span class="line">cnpm <span class="keyword">install</span> xxx</span><br></pre></td></tr></table></figure></p>
<p>查看配置<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">npm<span class="built_in"> config </span>list</span><br></pre></td></tr></table></figure></p>
<h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-<span class="keyword">index</span> <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
<h3 id="卸载依赖包"><a href="#卸载依赖包" class="headerlink" title="卸载依赖包"></a>卸载依赖包</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">uninstall</span> hexo-generator-<span class="keyword">index</span> <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
<h3 id="查看安装的模块"><a href="#查看安装的模块" class="headerlink" title="查看安装的模块"></a>查看安装的模块</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">ls</span> <span class="params">--depth</span> 0</span><br></pre></td></tr></table></figure>
<h3 id="升级npm包"><a href="#升级npm包" class="headerlink" title="升级npm包"></a>升级npm包</h3><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> update</span><br></pre></td></tr></table></figure>
<h3 id="npm自升级"><a href="#npm自升级" class="headerlink" title="npm自升级"></a>npm自升级</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">sudo npm install npm -g</span><br><span class="line">sudo npm install <span class="symbol">npm@</span><span class="number">6.13</span><span class="number">.4</span> -g  <span class="comment">// 指定升级版本</span></span><br></pre></td></tr></table></figure>
<h2 id="Hexo搭建博客"><a href="#Hexo搭建博客" class="headerlink" title="Hexo搭建博客"></a>Hexo搭建博客</h2><p><a href="https://github.com/theme-next/hexo-theme-next.git" target="_blank" rel="noopener">Hexo GitHub仓库</a></p>
<h3 id="新建博客"><a href="#新建博客" class="headerlink" title="新建博客"></a>新建博客</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="built_in">new</span> <span class="string">"My New Post"</span>/hexo <span class="built_in">new</span> <span class="built_in">post</span> hello-world</span><br></pre></td></tr></table></figure>
<p>详情: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="生成草稿"><a href="#生成草稿" class="headerlink" title="生成草稿"></a>生成草稿</h3><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> <span class="type">draft</span> hello-world</span><br></pre></td></tr></table></figure>
<h3 id="发布草稿"><a href="#发布草稿" class="headerlink" title="发布草稿"></a>发布草稿</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo publish [post] hello-world</span><br></pre></td></tr></table></figure>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate/hexo g</span><br></pre></td></tr></table></figure>
<p>详情: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="运行服务"><a href="#运行服务" class="headerlink" title="运行服务"></a>运行服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo </span><br><span class="line">$ hexo server/hexo s  // 本地运行</span><br></pre></td></tr></table></figure>
<p>详情: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="发布博客到github"><a href="#发布博客到github" class="headerlink" title="发布博客到github"></a>发布博客到github</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy/hexo d</span><br></pre></td></tr></table></figure>
<p>详情: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h2 id="优化博客"><a href="#优化博客" class="headerlink" title="优化博客"></a>优化博客</h2><h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><p>采用Next</p>
<h3 id="添加RSS，RSS迁移-添加Search本地搜索"><a href="#添加RSS，RSS迁移-添加Search本地搜索" class="headerlink" title="添加RSS，RSS迁移; 添加Search本地搜索"></a>添加RSS，RSS迁移; 添加Search本地搜索</h3><p>rss:<br>hexo-generator-feed插件<br>修改主题下config文件，添加 <code>rss: /atom.xml</code></p>
<p>search:</p>
<h3 id="添加博客访问量PV-UV"><a href="#添加博客访问量PV-UV" class="headerlink" title="添加博客访问量PV/UV"></a>添加博客访问量PV/UV</h3><p>两种方法：<br>1). 在<code>$HEXO_BLOG/themes/next/layout/_partials/footer.swig</code>添加’不蒜子’js脚本、统计标签</p>
<p>2).直接开启config配置</p>
<h3 id="添加博客字数、阅读时长-修改博客国际化"><a href="#添加博客字数、阅读时长-修改博客国际化" class="headerlink" title="添加博客字数、阅读时长; 修改博客国际化"></a>添加博客字数、阅读时长; 修改博客国际化</h3><p>统计也遇到两种方法：<br>1）、hexo-wordcount插件 + 开启config + 修改post-swig添加统计</p>
<p>2）、hexo-symbols-count-time插件，只需要开启config即可</p>
<h3 id="修改博文底部标签样式-添加Read-more"><a href="#修改博文底部标签样式-添加Read-more" class="headerlink" title="修改博文底部标签样式; 添加Read more"></a>修改博文底部标签样式; 添加<code>Read more</code></h3><p>修改模板 <code>$HEXO_BLOG/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将’#’换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p>
<h3 id="增加博文置顶功能"><a href="#增加博文置顶功能" class="headerlink" title="增加博文置顶功能"></a>增加博文置顶功能</h3><p>两种方案：<br>1）hexo-generator-index</p>
<p>2）hexo-generator-index-pin-top</p>
<p>找到<code>$HEXO_BLOG/themes/next/layout/_macro/post.swig</code>文件，定位到<code>&lt;div class=&quot;post-meta&quot;&gt;</code>标签下，插入代码：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> post.top %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-thumb-tack"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">7D26CD</span>&gt;</span>置顶<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-divider"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure>
<h3 id="添加评论功能"><a href="#添加评论功能" class="headerlink" title="添加评论功能"></a>添加评论功能</h3><h3 id="修改域名"><a href="#修改域名" class="headerlink" title="修改域名"></a>修改域名</h3><h3 id="网站备案"><a href="#网站备案" class="headerlink" title="网站备案"></a>网站备案</h3><h3 id="支持LaTex"><a href="#支持LaTex" class="headerlink" title="支持LaTex"></a>支持LaTex</h3><p>总结一下<br>markdown文件对LaTex数学公式的支持，最开始在windows上博客编辑使用<code>Markdown Pad 2</code>，可以支持实时预览。最近更换到<code>VSCode</code>，看了支持实时预览的大概几种方案：Tex Live(MaxTex)体积太大；MikTex对中文的支持不是很好；Overleaf采用线上编译模式。<br>最后放弃实时预览，只在编译后的博客中支持。<br>Hexo的Next主题已经提供了对LaTex的支持，只需要使用npm安装插件，编辑config配置文件开启即可，目前Next支持<code>Mathjax</code>和<code>Katex</code>两种编译引擎。<br><strong> 注意：不同的主题配置方式不同 </strong></p>
<ol>
<li><p>npm安装插件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">cd $BLOG_HOME</span><br><span class="line"></span><br><span class="line">安装hexo-math</span><br><span class="line">$ npm <span class="keyword">install</span> hexo-math <span class="comment">--save</span></span><br><span class="line"></span><br><span class="line">卸载默认引擎，安装支持latex的引擎</span><br><span class="line">$ npm <span class="keyword">uninstall</span> hexo-renderer-marked <span class="comment">--save</span></span><br><span class="line">$ npm <span class="keyword">install</span> hexo-renderer-kramed <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改npm插件的编译规则<br>Latex和Markdown的一些语法一致导致render渲染规则存在冲突，可以通过修改插件的正则表达式来避免冲突。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">vi $BLOG<span class="emphasis">_HOME/node_</span>modules/kramed/lib/rules/inline.js</span><br><span class="line"></span><br><span class="line">调整为</span><br><span class="line">escape: /^\\([<span class="string">`*\[\</span>](<span class="link"></span>)#$+\-.!_&gt;])/,</span><br><span class="line">em: /^\<span class="emphasis">*((?:\*</span>\<span class="emphasis">*|[\s\S])+?)\*</span>(?!\*)/,</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<code>$HEXO_BLOG/themes/next/_config.yml</code>开启功能按钮<br>这里有人在Hexo的根目录下直接修改<code>_config.yml</code>，要注意themes的区别。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta"># Math Equations Render Support</span></span><br><span class="line"><span class="symbol">math:</span></span><br><span class="line"><span class="symbol">  enable:</span> true</span><br><span class="line">  <span class="meta"># 默认值为true， 只在添加了`mathjax: true`的文章中价值latex脚本。false会在所有的文章页加载`mathjax / katex`脚本</span></span><br><span class="line"><span class="symbol">  per_page:</span> true</span><br><span class="line"><span class="symbol">  engine:</span> mathjax</span><br><span class="line">  <span class="meta">#engine: katex</span></span><br><span class="line"></span><br><span class="line">  <span class="meta"># 安装 hexo-renderer-pandoc (or hexo-renderer-kramed)</span></span><br><span class="line"><span class="symbol">  mathjax:</span></span><br><span class="line"><span class="symbol">    enable:</span> true</span><br><span class="line"><span class="symbol">    per_page:</span> false</span><br><span class="line">		<span class="meta"># 这块儿js文件路径注意是否能正常访问</span></span><br><span class="line">    <span class="meta"># cdn: <span class="comment">//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span></span><br><span class="line"><span class="symbol">    cdn:</span> <span class="comment">//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML</span></span><br><span class="line">    <span class="meta"># See: https:<span class="comment">//mhchem.github.io/MathJax-mhchem/</span></span></span><br><span class="line">    <span class="meta">#mhchem: <span class="comment">//cdn.jsdelivr.net/npm/mathjax-mhchem@3</span></span></span><br><span class="line">    <span class="meta">#mhchem: <span class="comment">//cdnjs.cloudflare.com/ajax/libs/mathjax-mhchem/3.3.0</span></span></span><br><span class="line"></span><br><span class="line">  <span class="meta"># 插件2 hexo install hexo-renderer-markdown-it-plus (or hexo-renderer-markdown-it with markdown-it-katex plugin)</span></span><br><span class="line">  <span class="meta"># katex:</span></span><br><span class="line">  <span class="meta">#   cdn: <span class="comment">//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css</span></span></span><br><span class="line">  <span class="meta">#   #cdn: <span class="comment">//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css</span></span></span><br><span class="line"></span><br><span class="line">  <span class="meta">#   copy_tex:</span></span><br><span class="line">  <span class="meta">#     # See: https:<span class="comment">//github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span></span><br><span class="line">  <span class="meta">#     enable: false</span></span><br><span class="line">  <span class="meta">#     copy_tex_js: <span class="comment">//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js</span></span></span><br><span class="line">  <span class="meta">#     copy_tex_css: <span class="comment">//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>文章头添加<code>mathjax: true</code>标识。<br>使用数学公式验证一下</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> evidence_&#123;i&#125;=\sum_&#123;j&#125;W_&#123;ij&#125;x_&#123;j&#125;+b_&#123;i&#125; <span class="symbol">$</span><span class="symbol">$</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">$</span><span class="symbol">$</span> \<span class="built-in">frac</span>&#123;m&#125;&#123;n&#125; %n分之m <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>本地启动<br><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">s</span></span><br></pre></td></tr></table></figure></p>
<p><strong> 加载会变慢，js脚本可以考虑使用镜像 </strong></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">1. 错误1</span><br><span class="line">seems to be corrupted. Trying <span class="keyword">one</span> <span class="keyword">more</span> time</span><br><span class="line">解决方案</span><br><span class="line">更换网络：数据网络、代理、镜像，墙内世界总有一款适合你</span><br><span class="line"></span><br><span class="line">2. 错误2 权限问题</span><br><span class="line">Unhandled rejection <span class="keyword">Error</span>: EACCES: permission denied, <span class="keyword">mkdir</span></span><br><span class="line">解决方案</span><br><span class="line">sudo chown -R <span class="variable">$USER</span>:<span class="variable">$GROUP</span> ~/.npm</span><br><span class="line">sudo chown -R <span class="variable">$USER</span>:<span class="variable">$GROUP</span> ~/.config</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hello</category>
      </categories>
      <tags>
        <tag>Hello</tag>
      </tags>
  </entry>
</search>
