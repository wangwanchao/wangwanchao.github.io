---
title: 类和接口
date: 2018-05-06 10:23:45
tags:
---

#### 第14条

退化类：

改进：

(1)如果类可以在它所在的包外部进行访问，就提供访问方法，以保留将来改变该类的内部表示法的灵活性(但是如果域是不可变的final,直接public暴露)

反例：java.awt.Point/Dimension类

(2)如果类是包级私有的，或是私有的嵌套类，可以直接暴露它的数据域

<!-- more -->

#### 第15条

不可变类：实例所包含的信息在创建时被提供，并在整个生命周期内固定不变。例如：String、基本类型的封装类、BigInteger、BegDecimal

不可变类的五条原则：

1、不要提供任何会修改对象状态的方法

2、保证类不会被扩展，使这个类成为final类;或者让类的所有构造器变成私有的/包级私有的，并添加公有的静态工厂

3、使所有的域都是final的

4、使所有的域都是私有的(虽然技术上允许public, 但是以后不能再将public降级为private)

5、确保对于任何可变组件的互斥访问

> 如果类具有指向可变对象的域，必须确保客户端无法获得指向这些对象的引用；永远不要用客户端提供的对象引用来初始化这样的域；永远不要从任何方法中返回该对象引用。

> 在构造器、访问方法、readObject中使用保护性拷贝


注意：
> 实际上，许多不可变类拥有一个或多个非final的域，它们在第一次被请求执行这些计算时，把开销昂贵的计算结果缓存在这些域。例如String的延迟初始化
> 
> 如果让自定义的不可变类实现Serializable接口，并且包含一个或多个指向可变对象的域，就必须提供一个显式的readObject/readResolve方法

>不要为每个get方法编写一个相应的set方法，

>构造器应该创建完全初始化的对象，并建立起所有的约束关系，不要在构造器或者静态工厂之外再提供公有的初始化方法。

函数的

过程的

命令式的

不可变对象的优点：

1、不可变对象比较简单

2、不可变对象本质上是线程安全的，它们不要求同步，所以可以被自由共享

public static final Complex ZERO = new Complex(0, 0);

可以提供一些静态工厂，把频繁被请求的实例缓存起来，例如BigInteger、基本类型包装类

不需要为不可变类提供clone方法、拷贝构造器

3、不仅可以共享不可变对象，甚至可以共享它们的内部信息。例如：BigInteger类内部使用了符号数值表示法

4、不可变对象为其它对象提供了大量的构件。一旦不可变对象进入映射或集合中，尽管这破坏了映射或者集合的不可变性约束，但是也不用担心它们的值会发生变化

不可变类的缺点：

1、不可变对象对于每个不同的值都需要一个单独的对象。例如：String的可变配套类StringBuilder，Big Integer的BitSet

为了潜在的性能问题，java.util.Date、java.awt.Point本应该是不可变的，实际上却不是

#### 第16条

该条讨论的继承指的是class extends class,而不是class implements interface、interface extends interface

包内使用继承非常安全，跨包使用继承则非常危险。

复合代替继承，使用转发类代替接口实现类实现接口

注意：

> 包装类不适
> 合用在回调框架中

> 在Java类库中，违反复合原则的有:Stack并不是Vector，Properties也不是HashTable

> 在使用继承而不是复合之前，要确定将要扩展的类中API有没有缺陷


#### 第17条

接口优于实现类

骨架实现类(结合接口和抽象类的优点)。例如：AbstractCollection、AbstractSet、AbstractList、AbstractMap

抽象类的演变比接口的演变容易的多


#### 第19条

常量接口是一种不良使用，接口应该只被用来定义类型

导出常量的三种方式：

> 直接放在类、接口中

> 枚举类型

> 工具类，如果工具类常量太多，可以通过静态导入机制实现

#### 第20条

标签类：如何定义

改进：

类层次

