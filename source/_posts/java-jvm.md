---
title: Java虚拟机(一)
date: 2018-09-28 23:53:05
tags: java, jvm
categories: JVM
---
JVM运行时栈帧模型

<!-- more --> 
## Java内存区域

### 程序计数器
可以看作当前线程所执行的字节码的行号执行器。通过改变这个计数器的值来选取下一条要执行的字节码指令。

每个线程有自己独立的程序计数器，各线程之间计数器互不影响，独立存储。

### Java虚拟机栈
线程私有，生命周期和线程相同。
描述的Java方法执行的内存模型，每个方法在执行时都会创建一个栈帧：
> 存储局部变量表、
> 操作数栈、
> 动态链接、
> 方法出口。

### 本地方法栈
和Java虚拟机栈类似，用于存储本地方法的执行栈

### Java堆
被所有线程共享的一块区域，在虚拟机启动时创建。该内存区的唯一目的就是存放对象实例。

逃逸分析技术：

栈上分配

标量替换

### 方法区
所有线程共享的内存区。用于存储：
> 被虚拟机加载的类信息：
> 常量
> 静态变量
> 即时编译器编译后的代码

#### 运行时常量池

属于方法区的一部分。Class文件中的常量池在类加载后也会进入方法区的运行时常量池。还有常量池：编译期生成的各种字面量、符号引用、直接引用()。

例如String.intern()方法。

#### PernGen和Metaspace
PermGen：
永久代只是方法区在HotSpot虚拟机中的一种实现。其它类型的虚拟机没有永久代的概念。

jdk1.7:
原来存储在永久代的部分数据，现在分配到Java Heap/Native Heap。

jdk1.8:
> 符号引用转移到native heap
> 字面量转移到Java heap
> 类的静态变量转移到Java heap
> 参数`-XX:PermSize -XX:MaxPermSize`已经失效
> MetaSpac不在jvm中，而是使用本地内存，默认情况下，仅受本地内存限制，
> 参数`-XX:MetaspaceSize -XX:MaxMetaspaceSize`，用于限制元数据区空间，**默认**大小为20MB
> 参数`-XX:MinMetaspaceFreeRation -XX:MaxMetaspaceFreeRation`，用于控制GC后剩余空间容纳的百分比
> 参数`-XX:MinMetaspaceExpansion -XX:MaxMetaspaceExpansion`，用于控制元空间增长幅度
> 参数`-XX:+UseCompressedClassPointers -XX:+UseCompressedOops`会在Metaspace空间分配空间，导致默认20MB失效

Metaspace的优点：
> jar包和应用的class文件存放在永久代，如果jar包很多，可能导致永久代溢出
> 每个应用都有自己的永久代，改用Metaspace后，应用可以共享同样的class内存空间，例如：两个项目都引用rt.jar，在元空间只保留一份

Metaspace对GC性能的提升：
> Full GC中，指向元数据的指针不需要扫描，减少了GC开销；减少了GC Roots对象的扫描
> 元空间只有少量的指针指向Java heap，
> 避免了元数据压缩的开销

### 直接内存



## 虚拟机对象

### 对象的创建

**注意:** 仅限于普通Java对象，不包括数组、Class对象。

1. 当虚拟机遇到new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析、初始化过。如果没有，则执行相应的类加载过程。

2. 为新生对象分配内存
> 指针碰撞分配
> 
> 空闲列表分配
> 
> 内存分配的并发问题：
> 
> CAS + 失败重试
> 
> 本地线程分配缓冲(TLAB)

3. 对象进行必要的设置
4. 执行<init>方法

### 对象的内存布局

对象在内存中存储包括3块区域:

> 对象头：
>      1、存储对象自身的运行时数据：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳
> 		2、类型指针：该对象指向它的类元数据的指针
> 
> 实例数据：真正存储的有效信息，也就是在程序代码中定义的各种类型的字段内容。
> 
> 对齐填充：非必须，起占位符的作用

### 对象的定位访问

1、句柄访问

优点：

在对象被移动时，只会改变句柄中的实例数据指针

2、直接指针访问

优点：

访问速度快，节省了一次指针定位的时间开销


