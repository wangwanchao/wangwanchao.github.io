---
title: Java多线程
date: 2018-09-28 23:53:05
tags: Java
categories: Java
---

## 物理内存模型

缓存一致性：

处理器访问缓存(cache)时遵守的一些协议：MSI、MESI、MOSI、Synapse、Firefly、Dragon Protocol

指令重排序：


## JVM的内存模型：

主内存：所有的变量都存储在主内存，类似于物理机的主内存。对应于Java堆中对象实例数据部分。

工作内存：每条线程都有自己的工作内存，该区域保存了该线程使用到的变量的副本拷贝，类似于物理机的高速缓存。对应于虚拟机栈中的部分区域。


### volatile

volatile的2种特性：

1、保证此变量对所有线程的可见性

2、禁止指令重排序优化。

volatile在单例模式中的应用：


### 原子性、可见性、有序性

1. 原子性：

2. 可见性：

	volatile：
	
	synchronized：对一个变量执行unlock操作之前，必须先把此变量同步回主内存。
	
	final：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把this的引用传递出去，那在其他线程中就能看见final字段的值。

3. 有序性

<!-- more --> 
### 先行发生原则

用于判断数据是否存在竞争、线程是否安全

原则：

> 程序次序原则
> 
> 管程锁定原则
> 
> volatile变量原则
> 
> 线程启动原则
> 
> 线程终止原则
> 
> 线程中断原则
> 
> 对象终结原则
> 
> 传递性

如果两个操作之间的关系不存在此列，并且无法由此规则推导出来，它们之间就没有顺序性保障，虚拟机可以对它们进行重排序。

## 并发与并行

并发不一定要依赖多线程，PHP中很常见的多进程并发。

实现线程有3种方式：

1. 使用内核线程实现
2. 使用用户线程实现
3. 使用用户线程 + 轻量级进程混合实现

Java线程的实现：

jdk1.2之前，基于用户线程实现

jdk1.2中，基于操作系统原生线程模型实现

### Java线程调度

线程调度的2种方式：

1. 协同式调度：线程的执行时间是由线程本身控制的
2. 抢占式调度：每个线程由系统来分配执行时间。Java使用的就是抢占式调度

### Java线程的状态

1. 新建
2. 运行：处于此状态的线程可能正在执行，也可能正在等待CPU为它分配执行时间
3. 无限期等待：此状态的线程不会被分配CPU执行时间，需要等待其它线程显式唤醒
4. 限期等待：此状态的线程也不会被分配CPU执行时间，不过无需等待被其它线程显式唤醒，在一定时间后由系统自动唤醒。
5. 阻塞：线程被阻塞，等待其它排他锁
6. 结束：

## Java线程安全的实现：

1. 互斥同步(阻塞同步)：synchronized、ReentrantLock
2. 非阻塞同步：基于冲突检测的乐观并发策略，
	
	CAS：比较并交换。CAS存在ABA问题
	
	
3. 无同步方案

	可重入代码(纯代码)：
	
	线程本地存储：
	
## 锁优化

1. 自旋锁、自适应自旋锁
2. 锁消除：
3. 锁粗化：
4. 轻量级锁：在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量带来的性能消耗
5. 偏向锁：消除数据在无竞争的情况下的同步原语，进一步提高程序的运行性能。偏向锁可以提高带有同步但无竞争的程序性能。









