---
title: java动态代理
categories: java
date: 2018-08-30 23:51:41
tags: reflect
---
代理模式可以将具体的实现与调用方法解耦，将具体的实现隐藏在内部。

<!-- more -->
## 反射
通过反射，可以在运行时访问Java对象的属性、方法、构造方法。
**注意：**final属性也可以通过反射进行访问

### 加载过程

### 应用场景
1. Spring中通过xml实现bean的实例化。
2. AOP切面编程。动态代理实现，最终也是通过反射实现
3. 注解。
4. Class类浏览器、对象监视器、代码分析工具

### 特点
缺陷：
1. 性能开销。反射需要查找到Class进行动态解析，也会影响jvm的优化，性能较差
2. 破坏封装性。反射调用时可以忽略权限检查，可能导致安全性问题
3. 丧失编译时检查。无法在编译时检查，可能导致运行时异常

## 静态代理 ##
在编译阶段将接口、实现类、代理类全部编译完成。

## 动态代理 ##
在程序运行期间根据需要动态的创建代理类及其实例。

### JDK动态代理 ###

利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理;
只能对实现了接口的类生成代理，而不能针对类

JDK代理要求：
```
	实现InvocationHandler接口
	使用Proxy.newProxyInstance产生代理对象
	被代理的对象必须实现接口，如果该对象没有实现接口则不能生成代理对象
```
案例：


### CGLIB动态代理 ###


#### 为什么需要动态代理？ ####

1. 需要动态的增强具体业务的逻辑，比如AOP
2. 业务增强逻辑相同，可以统一处理。例如log管理、权限认证
3. 可以灵活地控制被代理类，很好的解耦


## 代理在Spring中的应用 ##

JDK代理和CGLIB代理在Spring中的应用：

> 如果对象实现了接口，则默认采用JDK代理实现AOP
> 
> 如果对象没有实现接口，则必须采用CGLIB代理实现AOP

强制使用CGLIB实现AOP：
1. 添加CGLIB库，cglib/*.jar
2. 在spring配置文件中加入<aop:aspectj-autoproxy proxy-target-class="true"/>