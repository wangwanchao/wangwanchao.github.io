---
title: Linux-IO模型
date: 2020-08-17 22:28:16
tags:
categpries: Linux
---
系统中数据传输通常包含两个阶段：
1. 等待数据准备好，将数据复制到内核缓冲区
2. 将数据从内核缓冲区复制到进程缓冲区

<!-- more -->
## 阻塞式I/O


1. 进程发起系统调用recvfrom，进程阻塞
2. recvfrom等待直到数据被复制到进程缓冲区才返回
3. 内核返回成功，进程处理返回的数据

UDP:
TCP:

## 非阻塞式I/O


1. 进程发起系统调用recvfrom，如果内核缓冲区无数据，则返回WOULDBLOCK错误
2. 进程不断轮询，直到数据被复制到进程缓冲区
3. 内核返回成功，进程处理返回的数据

## I/O复用


1. 进程发起系统调用select，无数据则进入阻塞状态。
2. 直到数据可读，内核返回可读状态
3. 进程重新发起recvfrom系统调用，数据从内核缓冲区复制到进程缓冲区
4. 内核返回成功，进程处理返回的数据

## 信号驱动式I/O


1. 进程发起系统调用sigaction，安一个信号处理函数，内核立即返回，进程继续工作
2. 直到数据可读，内核向进程发起SIGIO信号
3. 进程重新发起recvfrom系统调用，数据从内核缓冲区复制到进程缓冲区
4. 内核返回成功，进程处理返回的数据

IO多路复用有多种实现：
### select


缺点：
> 单个进程监听的文件描述符数量存在最大限制
> 数据就绪后，对socket进程扫描是线性扫描，效率低
> 用户空间和内核空间在传递时开销大

### poll


缺点：

### epoll
epoll是select和poll的增强版
epoll的核心概念是`epoll instance`，从用户空间来看，实质上是两个列表的容器
1. `interest list`
2. `ready list`

#### LT模式 Level-triggered
水平触发模式

#### ET模式 edge-triggered
边缘触发模式

## 异步I/O