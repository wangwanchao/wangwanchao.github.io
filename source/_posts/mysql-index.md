---
title: MySQL索引
date: 2018-09-28 23:53:05
tags: 索引
categories: MySQL
---
MySQL索引
<!-- more -->

## 索引类型 ##
### 按照划分：
#### 聚簇索引：
一个表只能有一个聚簇索引，InnoDB默认选择主键作为聚簇索引，如果没有主键，则选择一个唯一的非空索引替代。如果没有唯一非空列，则自定义一个主键作为聚簇索引。
叶子节点存储行的全部数据，节点只存储索引信息。
每一个叶子节点结构：主键值 + 事务ID + 回滚指针 + 剩余列的值。

缺点：
1. 更新索引列代价很高。由于聚簇索引需要是有序的，对更新的行，会强制移动到新的位置。如果插入新的记录，或者主键被更新导致移动行，可能造成'页分裂'问题，页分裂会占用更多的磁盘空间，因为数据不连续导致全表扫面变慢
2. 二级索引回表查询问题。由于二级只存储索引和主键信息，根据二级索引过滤时，需要先查询二级索引，再查找主索引，二次I/O导致性能变差

#### 非聚簇索引

### 按照划分：
1. B-Tree索引。索引统称
	B-Tree的特点：
	> 所有的值按照顺序存储
	> 每一个叶子节点到根的距离相同
	> 适合查找范围数据

	B-Tree的限制：
	> 如果不是按照索引的最左列开始查找，则无法使用索引
	>  
	> 不能跳过索引中的列
	>
	> 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找
	
实际上，NDB使用的是T-Tree， MyISAM使用前缀压缩技术存储使得索引更小，索引通过物理地址查找记录；InnoDB引擎使用的是B+Tree，索引按照原数据格式存储，根据主键查找记录

B-Tree索引生效：

B-Tree索引失效：


2. 哈希索引
3. 空间数据索引(R-Tree)
4. 全文索引

### MyISAM和InnoDB的不同： ###
MyISAM使用前缀压缩使索引更小，而InnoDB按照原数据格式进行存储。

MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键饮用被索引的行。

## 高性能索引策略

1. 索引列表达式：对索引列增加表达式，导致索引失效
前缀索引/索引唯一性：如果索引列太长，会导致索引变得很慢，可以采用索引部分前缀实现索引，但是要注意索引的唯一性，避免影响效率。前缀索引也导致`group by`和`order by`失效，也不能作为覆盖索引使用
2. 多列索引：不同于复合索引/联合索引，假如一张表多个列需要创建索引，每个列创建单列索引并不会提高效率。存储引擎会对OR/AND语句做一些优化，索引也会经过索引，但是性能很低
索引顺序：多列索引中，在不考虑排序、分组的情况下，将唯一性区分度比较高的列放在最前面，
3. 覆盖索引：不是所有的索引列都可以成为覆盖索引，MySQL只支持'B-Tree'类型索引为覆盖索引。EXPLAIN执行计划Extra列`Using index`表示覆盖索引生效，`Using where`表示覆盖索引失效，`Using where,Using index`表示进行了延迟关联。
4. 索引排序：EXPLAIN执行计划Extra列
5. 压缩索引：MyISAM引擎通过压缩索引前缀来减少内存占用，
6. 重复索引/冗余索引：重复索引因为需要逐个过滤，所以会导致性能损耗。冗余索引不等于重复索引。冗余索引和重复索引都会导致INSERT、UPDATE、DELETE速度变慢。Percona提供了一些工具类来实现对冗余索引的分析。
7. 闲置索引：有些索引可能 很少使用或者永远不使用，
8. 索引和锁：InnoDB的行锁可以减少对锁的争用，在索引过滤数据完成后会立即释放锁，而不需要等到整个事务提交，如果索引失效，会导致全表扫描。InnoDB在二级索引上使用共享锁(S)，在主键索引上使用排他锁(X)，这就导致覆盖索引会失效，


## 底层原理



