---
title: 第二天
date: 2020-10-02 22:20:09
tags:
categpries: OS
---
从学习汇编开始，我就一直觉得寄存器是一个很抽象的东西，尤其是通过地址去操作。这次学习重新打开《汇编语言》，巩固一下。

<!-- more -->
第一天主要使用的是字节码来编程，今天改为汇编
## 实战
`helloos.asm`也切换到`ipl.asm`，让它看起来像个系统。这里改变的主要是显示部分。
优化前：
```
;　程序主体

	DB		0xb8, 0x00, 0x00, 0x8e, 0xd0, 0xbc, 0x00, 0x7c
	DB		0x8e, 0xd8, 0x8e, 0xc0, 0xbe, 0x74, 0x7c, 0x8a
	DB		0x04, 0x83, 0xc6, 0x01, 0x3c, 0x00, 0x74, 0x09
	DB		0xb4, 0x0e, 0xbb, 0x0f, 0x00, 0xcd, 0x10, 0xeb
	DB		0xee, 0xf4, 0xeb, 0xfd

;　信息显示部分

	DB		0x0a, 0x0a		;　换行
	DB		"hello, world"
	DB		0x0a			;
	DB		0

```
优化后：
```
; 程序核心

entry:
    MOV		AX,0			; 初始化寄存器
    MOV		SS,AX
    MOV		SP,0x7c00
    MOV		DS,AX
    MOV		ES,AX
    MOV		SI,msg

putloop:
    MOV		AL,[SI]         ; 指向msg字符串
    ADD		SI,1			; 遍历指针 
    CMP		AL,0			; 比较是否到字符串末尾
    JE		fin
    MOV		AH,0x0e			; 
    MOV		BX,15			; 
    INT		0x10			; 中断显示字符
    JMP		putloop

fin:
	HLT						; 
	JMP		fin				; 

msg:
	DB		0x0a, 0x0a		; 
	DB		"hello, world"
	DB		0x0a			; 
	DB		0
```
看起来变化很大， 其实只是从机器码转换为汇编，贴出一部分操作码：
| 汇编 | 字节码 |
|:-|:-:|
| MOV AX | 0xb8 |
| MOV SS | 0x8e |
| MOV SP | 0xbc |
| MOV DS,AX | 0x8e 0xd8|
| MOV ES,AX | 0x8e 0xc0|

## 寄存器

#### 8位寄存器
| 符号 | 名称 |用途|
|:-|:-:|:-:|
|AL|累加寄存器低位||
|CL|计数寄存器低位||
|DL|数据寄存器低位||
|BL|基址寄存器低位||
|AH|累加寄存器高位||
|CH|计数寄存器高位||
|DH|数据寄存器高位||
|BH|基址寄存器高位||

SP、BP、SI、DI不分高位和低位。

#### 16位寄存器
| 符号 | 名称 |用途|
|:-|:-:|:-:|
|AX|累加寄存器||
|CX|计数寄存器||
|DX|数据寄存器||
|BX|基址寄存器||
|SP|栈指针寄存器||
|BP|基址指针寄存器||
|SI|源变址寄存器||
|DI|目的变址寄存器||

#### 32位寄存器
EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI都是32位寄存器，但是低16位和对应的16位寄存器共用。如果使用高16位，则需要通过移位实现。

#### 段寄存器
| 符号 | 名称 |用途|
|:-|:-:|:-:|
|ES|附加段寄存器||
|CS|代码段寄存器||
|SS|栈段寄存器||
|DS|数据段寄存器||
|FS|-||
|GS|-||

**注意：**在和C语言联合使用中，只有EAX、ECX、EDX这3个寄存器能自由使用，其他寄存器，只能使用其值，而不能修改值。

## 汇编
'ORG': 指定文件装载到内存的地址，默认情况下从`0x`开始装载。内存`0x0000`用来存放BIOS不同功能程序，`0xf0000`用来存放BIOS程序本身。所以一般使用`0x7c00`-`0x7dff`用来存放启动区程序，这个位置起源于IBM。附近'$'的含义变为将要读入的内存地址。
'JMP': 跳转到指定的内存地址。
'MOV': 移动，类似于复制拷贝。
'ADD':
'CMP': 比较指令。
'JE': 条件跳转指令，根据CMP比较结果决定跳转或不跳转。
'INT': 软件中断指令。电脑主板ROM中通常写入一些经常用到的控制硬件的函数，INT就是用来调用其中函数的指令，通过不同的参数调用相应的函数来控制硬件的反应。例如：`INT 0x10`用来控制显卡显示字符。这块儿涉及到BIOS对寄存器的一些默认操作
```
显示1个字符：
AH=0x0e
AL=字符编码
BH=0
BL=字符颜色
返回值：无
注：

设置显卡模式：
AH=0x00
AL=模式 0x03 0x12 0x13 0x6a
返回值：无
```
'HLT': 停止CPU动作的指令，类似于待机/休眠状态，按下键盘、移动鼠标都会唤醒CPU。

## BIOS
对BIOS有没有兴趣？哈哈，这块儿的资料实在太少了
[FreeBSD BIOS](https://www.freebsd.org/doc/en_US.ISO8859-1/books/arch-handbook/boot-bios.html)

