---
title: Shenandoah论文(译)
date: 2020-12-10 17:43:49
tags:
categpries:
---
Shenandoah垃圾回收器在JDK15进入生产阶段。

<!-- more -->
Shenandoah是一种面向大堆的基于region、低停顿、并行、并发的垃圾回收算法。SATB并发标记和Brooks风格间接指针。
现代机器有更多的内存、更多的处理器。SLA应用保证响应时间在10-500ms。

## 导论

### 问题
压缩垃圾回收算法比CMS算法有更少的内存指纹、更好的本地缓存。达到这种效果要求垃圾回收算法可以在Java运行中压缩堆。

### 优势


## 思想
并发压缩是复杂的，当移动一个可能正在使用当对象时，你可能不得不原子性的更新对象的引用，简单点就需要扫描整个堆。S的解决方案是为每个对象添加一个前向指针`forwarding pointer`，所有使用这个对象都需要经过这个指针，这就使得即便应用正在运行，仍然可以移动这个对象。GC线程和增量线程使用原子性的CAS操作来更新这个指针。如果多个线程竞争移动同一个对象也只会有一个线程成功。引用的更新在下一个并发标记阶段完成。

## 实现

### 对象布局
每个对象有2个header，一个指向class；另一个叫`mark word`，用来作为forwarding pointer、年龄、锁、哈希值。Shenandoah为每个对象添加了一个word，这个word只有在使用S回收器时才被分配，允许不更新引用就可以移动这个对象。移动这个对象的线程通过CAS算法原子的修改这个word使它指向新的地址。所有对这个对象的使用都通过`forwarding pointer`指向新的地址。

### 堆布局
堆被划分成相等大小的region，一个region可以包括新对象、长时间存活的对象、或者混合的对象。

### GC
初始标记: STW，扫描`GC root`
并发标记:
最终标记: STW，重新扫描`GC root`，初始化并发压缩，释放上一次压缩后所有放空的regions
并发压缩: 从目标regions中抽取所有存活的对象。

