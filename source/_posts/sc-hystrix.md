---
title: 微服务--断路器(四)
date: 2020-08-28 21:20:00
tags: 断路器
categpries: SpringCloud
---
今天某图的面试官又问了我这个问题，我把bucket给忘了，心塞，所以我觉得该把整个Hystrix的文档“抄”一遍了。对一个中间件完全、深入的学习，我始终没有找到一个很好的方向，经某图研发主管指点，我悟了！以后每个中间件的学习我都会引入以下5个问题，这些问题要能涵盖所有核心的东西，粒度要合适，太小容易限于细节而失去大局观，太大则容易失去对核心的把握：
1. 中间件是什么？what
2. 中间件用来做什么？for
3. 中间件解决了什么问题？solve
4. 中间件的设计原理是什么？design
5. 你自己如何实现中间件？practice

如果能够在几分钟内把以上几个问题复述清楚，那么对整体的理解算是入门了，之后就是更深入的源码级别的问题了。
答：
1) 在分布式系统中，服务之间的依赖不可避免的会失败，hystrix主要用来处理两个问题：请求超时、请求错误。服务之间是通过请求隔离实现的，避免跨服务之间的级联失败。同时提供了降级来保证系统的健壮性。在Netflix，hystrix每天可以支撑100亿线程隔离、1000亿信号量隔离的调用

2) 主要用来做以下的事情:
> 处理服务调用超时、失败问题
> 在复杂的分布式系统中阻止级联失败
> 快速失败、快速恢复
> 回退、优雅的降级
> 实时的监控、告警

3) 问题3可能和问题2有混淆的地方。复杂系统中，应用可能依赖很多服务，任何服务都可能失败，如果当前主机应用没有和其他失败的服务隔离，该服务也会变成不可用。例如：单个服务满足可用性99.99%，30个依赖服务就会导致可用性降为99.99。最终即使0.01%的服务宕机都可能导致一个月内几个小时的不可用。

4) 设计原理：
> 阻止单个依赖耗尽容器(Tomcat)的用户线程。将所有对依赖服务的请求包装在的`HystrixCommand or HystrixObservableCommand`对象中，这两个对象运行在一个隔离的线程中。每一个依赖服务都会维护一个小型线程池/信号量，如果满了以后，请求会被直接拒绝而不是排队等待。
> 快速失败避免阻塞。请求错误率达到一个阈值后，要么手动的/自动的触发一个断路器来阻止对某个服务的请求
> 在可行的地方提供回退机制避免直接失败。当一个请求失败、超时、被拒绝、断路后悔进入fallback回退逻辑。
> 使用隔离技术(bulkhead舱壁隔离、swimlane泳道、circuit breaker断路器)限制依赖的影响
> 实时的统计、监控、告警实现及时发现问题。统计的具体包括：成功、失败、超时、线程拒绝
> 低延时的反馈回路允许修改配置，支持动态的修改属性
> 对client整个执行过程中依赖调用进行保护，而不仅仅是网络过程

5) 如果是你，你如何实现？

<!-- more -->
## Hystrix ##
注意服务熔断和服务降级是两个不同的概念。
服务熔断：一般是指软件系统中，由于某些原因使得服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施，所以很多地方把熔断亦称为过载保护。很多时候刚开始可能只是系统出现了局部的、小规模的故障，然而由于种种原因，故障影响的范围越来越大，最终导致了全局性的后果。
服务降级：当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。
### 工作原理
熔断器:Circuit Breaker
每个请求都会先经过熔断器，判断是否打开状态，每个熔断器维护10个bucket，每个bucket记录(成功、失败、超时、拒绝)的次数，每秒创建一个bucket，旧的bucket会被抛弃

#### 熔断机制
默认是5s内20次调用失败，就会触发熔断机制。也可以通过以下参数调整。
配置属性：
```
hystrix.command.default.metrics.rollingStats.timeInMilliseconds 	
circuitBreaker:
    forceClosed： true      # 是否强制关闭熔断
	requestVolumeThreshold: 20   	# 滑动窗口大小，默认20次/10s
	sleepWindowInMilliseconds: 5000  # 过多久断路器再次检测是否开启
	errorThresholdPercentage: 50  	# 错误率
```
1. 快照时间窗口：timeInMilliseconds 默认为10s
2. 请求总数阀值: requestVolumeThreshold 在快照时间窗内，必须满足请求总数阀值才有资格熔断。例如：默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足20次，即使所有的请求都超时或其他原因失败，断路器都不会打开
3. 错误百分比阀值：errorThresholdPercentage 默认50，主要根据依赖(强依赖、弱依赖)重要性进行调整，当请求总数在快照时间窗内请求失败率超过了该阀值，则打开断路器
**注意**
**默认**超过50%的请求失败，将打开断路器()，不再调用后端服务而直接失败，调用降级服务`fallback`，过一段时间后尝试一部分请求到后端()，如果成功则关闭断路器()，否则重新打开

#### 超时时间
可以手动设置，当调用后端服务超过超时时间时，直接返回/执行fallback逻辑
```
execution.isolation.thread.timeoutInMilliseconds # 超时时间	
默认值：1000
在THREAD模式下，达到超时时间，可以中断
在SEMAPHORE模式下，会等待执行完成后，再去判断是否超时
```

级别：
1. 全局级别
2. 接口级别
3. 服务级别

### 线程池
默认情况下，使用线程池模式
每个请求对于一个线程池，接收请求后提交到线程池，下游服务在各自的单独线程中执行，达到资源隔离的作用。
微服务之间的调用包裹在HystrixCommand类中，这样每次都会启动一个新的线程执行

#### 配置属性
```
coreSize
execution.isolation.thread.interruptOnTimeout=true  #是否打开超时线程中断
execution.timeout.enabled: true  # 是否打开超时	
maxQueueSize: -1   # 请求等待队列	默认值：-1 如果使用正数，队列将从SynchronizeQueue改为LinkedBlockingQueue
```

### 信号量
本服务接收请求和下游服务的执行都在一个线程内执行，内部通过一个计数器(信号量)实现线程计数，当线程的并发数大于信号量阈值时将进入fallback。

#### 配置属性：调整为信号量模式
```
execution.isolation.strategy = ExecutionIsolationStrategy.SEMAPHORE
execution.isolation.semaphore.maxConcurrentRequests=1000  # 限制下游服务调用，当并发请求数达到阈值时，请求线程可以快速失败，执行降级
```

### 应用场景：

1. 隔离（线程隔离、信号量隔离）：主要是限制调用分布式服务的资源，避免个别服务出现问题时对其他服务产生影响
2. 熔断（容错）：当失败率达到一定阈值时，熔断器触发快速失败
3. 降级（超时降级、熔断降级）：触发降级时可以使用回调方法返回托底数据
4. 缓存：请求缓存、请求合并
5. 实时监控、报警

### 线程池和信号量的区别
线程池：

信号量：

### 统计监控
在`HystrixCommands and HystrixObservableCommands`命令执行的时候，会对执行结果/执行频率生成统计向量，这对开发者来说是非常有用的，可以更深入地看到系统运行行为，Hystrix对每个执行命令都提供了细粒度的统计(甚至是秒级别的)。

#### 事件类型
`HystrixCommand` 单个返回值，SUCCESS事件返回值，同时表示请求完成。
`HystrixObservableCommand` 可能返回多个值，EMIT事件返回值，其它事件表示请求终止，
事件又分为：执行事件、回退事件、命令事件、线程池事件、崩溃事件

#### 向量存储
统计向量生成后，在被转移之前需要被存储一段时间，Hystrix选择将这些统计向量存储在内存中，以便后续的查询。这些向量存储结构在1.5.0版本被重构。
1.4.x版本：
HystrixRollingNumber用来统计所有事件，HystrixRollingPercentile只统计定制事件，例如：执行频率、崩溃次数。这些向量在执行过程中同步写入，支持滚动模式只保持最新的统计。

#### 向量读取
读取只返回聚合结果，例如：对一个请求失败率50%的监控，但是我们可能需要知道该接口在不同国家的失败率，可能在墨西哥、巴西失败率为0%，但是在美国失败率为98%，如果只是简单的聚合会丢失精度。
为了解决以上的问题，引入了`HystrixRequestLog`，使用日志进行更深度的分析，这可能不是最佳的方案，请求结束后，可以结合上下文环境对HTTP请求做一些分析，从而根据HTTP请求路径对请求结果/请求频率做一个划分。
1.5.x版本：
在1.5版本对向量统计进行了重新设计，可以允许更灵活的消费。每一个向量都会生成stream流，每一个`HystrixCommandKey`和`HystrixThreadPoolKey`都有一个开始事件-结束事件流，每一个`HystrixCollapserKey`都有一个专门处理崩溃事件的流。

## Sentinel(阿里) ##
### 原理
特性：

1. 轻量级、高性能： sentinel-core不到200KB，单机超过25W QPS才会有影响
2. 流量控制：以不同的运行指标为基准，
	> 直接拒绝模式
	> 慢启动预热模式
	> 匀速度模式
3. 系统负载保护

### 应用场景：

1. 和Dubbo整合，通过限流实现服务的高可用
2. 和RocketMQ整合，通过匀速请求和冷启动保障服务的稳定性

### Hystrix和Sentinel的对比 ###
